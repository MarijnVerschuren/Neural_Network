; Listing generated by Microsoft (R) Optimizing Compiler Version 19.33.31630.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation@		; `string'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0DK@CKLHOJNA@Alignment?5must?5be?5at?5least?5size@ ; `string'
PUBLIC	??_C@_1MG@ODDCIJJL@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@ ; `string'
PUBLIC	??_C@_1PM@EGIIFBMJ@?$AAa?$AAl?$AAi?$AAg?$AAn?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAi@ ; `string'
PUBLIC	??_C@_1MO@MNMFCLKA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@ ; `string'
PUBLIC	??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@ ; `string'
PUBLIC	??_C@_1MO@IEDNFCAN@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@ ; `string'
PUBLIC	??_C@_1EO@NAOGFKEJ@?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN@ ; `string'
PUBLIC	??_C@_0CP@LINCKCAG@Invalid?5sizes?5when?5resizing?5a?5m@ ; `string'
PUBLIC	??_C@_1DBO@BCDCEIEF@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl@ ; `string'
PUBLIC	??_C@_1MO@GPGLNDGM@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@ ; `string'
PUBLIC	??_C@_1FO@DGNPLEBJ@?$AAd?$AAs?$AAt?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd@ ; `string'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@8 ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R4?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@6B@ ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::`RTTI Complete Object Locator'
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_7?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@6B@ ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::`vftable'
PUBLIC	??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_R0?AV?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@@8 ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> > `RTTI Type Descriptor'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	_CTA2?AVbad_alloc@std@@
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@8 ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@8 ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::`RTTI Base Class Array'
PUBLIC	?_Fake_alloc@std@@3U_Fake_allocator@1@B		; std::_Fake_alloc
PUBLIC	??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	_TI2?AVbad_alloc@std@@
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
EXTRN	__imp_?good@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?precision@ios_base@std@@QEAA_J_J@Z:PROC
EXTRN	__imp_?width@ios_base@std@@QEBA_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEAA_J_J@Z:PROC
EXTRN	__imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z:PROC
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue
EXTRN	__imp_?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z:PROC
EXTRN	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync
EXTRN	__imp_?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ:PROC
EXTRN	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
EXTRN	__imp_?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z:PROC
EXTRN	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
EXTRN	__imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z:PROC
EXTRN	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
EXTRN	__imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z:PROC
EXTRN	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow
EXTRN	__imp_?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ:PROC
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	__imp_?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ:PROC
EXTRN	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ:PROC
EXTRN	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z:PROC
EXTRN	__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z:PROC
EXTRN	__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z:PROC
EXTRN	__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD0@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAADD@Z:PROC
EXTRN	__imp_?copyfmt@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAAEAV12@AEBV12@@Z:PROC
EXTRN	__imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp__invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__wassert:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__imp___std_terminate:PROC
EXTRN	__imp_free:PROC
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	__imp___std_exception_copy:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?uncaught_exceptions@std@@YAHXZ:PROC
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??_V@YAXPEAXW4align_val_t@std@@@Z:PROC		; operator delete[]
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	__imp___std_exception_destroy:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp___CxxFrameHandler4:PROC
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ios_base@std@@8
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT _TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
_TI2?AVbad_alloc@std@@ DD 00H
	DD	imagerel ??1bad_alloc@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	imagerel ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	098H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD imagerel ??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 01H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	098H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	imagerel ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
	DD	imagerel ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 01H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	imagerel ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
	DD	imagerel ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	DD	imagerel ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	DD	imagerel ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ?_Fake_alloc@std@@3U_Fake_allocator@1@B
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT ??_R2?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@8
rdata$r	SEGMENT
??_R2?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@8 DD imagerel ??_R1A@?0A@EA@?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@8 ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@8
rdata$r	SEGMENT
??_R3?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@8 DD 00H ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT _CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
_CTA2?AVbad_alloc@std@@ DD 02H
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DQ FLAT:??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DQ	FLAT:??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R0?AV?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@@8
data$rs	SEGMENT
??_R0?AV?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@@8 DQ FLAT:??_7type_info@@6B@ ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@'
	DB	'Neural@@', 00H
data$rs	ENDS
;	COMDAT ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DQ FLAT:??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DQ	FLAT:??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
	DQ	FLAT:?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
	DQ	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ
	DQ	FLAT:?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ
	DQ	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
	DQ	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
	DQ	FLAT:?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DQ	FLAT:?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DQ	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z
	DQ	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@6B@
CONST	SEGMENT
??_7?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@6B@ DQ FLAT:??_R4?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@6B@ ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::`vftable'
	DQ	FLAT:?get_data@?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@UEAA?AV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@_K@Z
	DQ	FLAT:?get_label@?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@UEAAC_K@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$rs	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	088H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT ??_R4?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@6B@
rdata$r	SEGMENT
??_R4?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@6B@ DD 01H ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@@8
	DD	imagerel ??_R3?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@8
	DD	imagerel ??_R4?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@6B@
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$rs	SEGMENT
??_R0?AVios_base@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVios_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocato'
	DB	'r@D@2@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@8 DD imagerel ??_R0?AV?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@@8 ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$alloc'
	DB	'ator@D@2@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	imagerel ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_1FO@DGNPLEBJ@?$AAd?$AAs?$AAt?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd@
CONST	SEGMENT
??_C@_1FO@DGNPLEBJ@?$AAd?$AAs?$AAt?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd@ DB 'd'
	DB	00H, 's', 00H, 't', 00H, '.', 00H, 'r', 00H, 'o', 00H, 'w', 00H
	DB	's', 00H, '(', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'd', 00H, 's', 00H, 't', 00H, 'R', 00H, 'o', 00H, 'w', 00H
	DB	's', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'd', 00H, 's'
	DB	00H, 't', 00H, '.', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 's', 00H
	DB	'(', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'd'
	DB	00H, 's', 00H, 't', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1MO@GPGLNDGM@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@
CONST	SEGMENT
??_C@_1MO@GPGLNDGM@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'm', 00H, 'a', 00H, 'r', 00H, 'i', 00H, 'j'
	DB	00H, '\', 00H, 'O', 00H, 'n', 00H, 'e', 00H, 'D', 00H, 'r', 00H
	DB	'i', 00H, 'v', 00H, 'e', 00H, '\', 00H, 'D', 00H, 'o', 00H, 'c'
	DB	00H, 'u', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'e', 00H
	DB	'n', 00H, '\', 00H, 'G', 00H, 'i', 00H, 't', 00H, 'H', 00H, 'u'
	DB	00H, 'b', 00H, '\', 00H, 'N', 00H, 'e', 00H, 'u', 00H, 'r', 00H
	DB	'a', 00H, 'l', 00H, '_', 00H, 'N', 00H, 'e', 00H, 't', 00H, 'w'
	DB	00H, 'o', 00H, 'r', 00H, 'k', 00H, '\', 00H, 'd', 00H, 'e', 00H
	DB	'p', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'n', 00H, 'c'
	DB	00H, 'i', 00H, 'e', 00H, 's', 00H, '\', 00H, 'E', 00H, 'i', 00H
	DB	'g', 00H, 'e', 00H, 'n', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'C', 00H, 'o', 00H, 'r', 00H, 'e', 00H, '\', 00H
	DB	'A', 00H, 's', 00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'E'
	DB	00H, 'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DBO@BCDCEIEF@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl@
CONST	SEGMENT
??_C@_1DBO@BCDCEIEF@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl@ DB '('
	DB	00H, '!', 00H, '(', 00H, 'R', 00H, 'o', 00H, 'w', 00H, 's', 00H
	DB	'A', 00H, 't', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H
	DB	'!', 00H, '=', 00H, 'D', 00H, 'y', 00H, 'n', 00H, 'a', 00H, 'm'
	DB	00H, 'i', 00H, 'c', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, '(', 00H, 'r', 00H, 'o', 00H, 'w', 00H, 's', 00H, '='
	DB	00H, '=', 00H, 'R', 00H, 'o', 00H, 'w', 00H, 's', 00H, 'A', 00H
	DB	't', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, ')', 00H
	DB	')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '(', 00H, '!'
	DB	00H, '(', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 's', 00H, 'A', 00H
	DB	't', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, '!', 00H
	DB	'=', 00H, 'D', 00H, 'y', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'i'
	DB	00H, 'c', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H
	DB	'(', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 's', 00H, '=', 00H, '='
	DB	00H, 'C', 00H, 'o', 00H, 'l', 00H, 's', 00H, 'A', 00H, 't', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'i', 00H, 'l', 00H, 'e'
	DB	00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, ')', 00H, ')', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '(', 00H, '!', 00H, '('
	DB	00H, 'R', 00H, 'o', 00H, 'w', 00H, 's', 00H, 'A', 00H, 't', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'i', 00H, 'l', 00H, 'e'
	DB	00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, '=', 00H, '=', 00H
	DB	'D', 00H, 'y', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'i', 00H, 'c'
	DB	00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'M', 00H, 'a', 00H
	DB	'x', 00H, 'R', 00H, 'o', 00H, 'w', 00H, 's', 00H, 'A', 00H, 't'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'i', 00H, 'l', 00H
	DB	'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, '!', 00H, '='
	DB	00H, 'D', 00H, 'y', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'i', 00H
	DB	'c', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, '('
	DB	00H, 'r', 00H, 'o', 00H, 'w', 00H, 's', 00H, '<', 00H, '=', 00H
	DB	'M', 00H, 'a', 00H, 'x', 00H, 'R', 00H, 'o', 00H, 'w', 00H, 's'
	DB	00H, 'A', 00H, 't', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e'
	DB	00H, ')', 00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'(', 00H, '!', 00H, '(', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 's'
	DB	00H, 'A', 00H, 't', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e'
	DB	00H, '=', 00H, '=', 00H, 'D', 00H, 'y', 00H, 'n', 00H, 'a', 00H
	DB	'm', 00H, 'i', 00H, 'c', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'M', 00H, 'a', 00H, 'x', 00H, 'C', 00H, 'o', 00H, 'l', 00H
	DB	's', 00H, 'A', 00H, 't', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, '!', 00H, '=', 00H, 'D', 00H, 'y', 00H, 'n', 00H, 'a'
	DB	00H, 'm', 00H, 'i', 00H, 'c', 00H, ')', 00H, ' ', 00H, '|', 00H
	DB	'|', 00H, ' ', 00H, '(', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 's'
	DB	00H, '<', 00H, '=', 00H, 'M', 00H, 'a', 00H, 'x', 00H, 'C', 00H
	DB	'o', 00H, 'l', 00H, 's', 00H, 'A', 00H, 't', 00H, 'C', 00H, 'o'
	DB	00H, 'm', 00H, 'p', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'T', 00H
	DB	'i', 00H, 'm', 00H, 'e', 00H, ')', 00H, ')', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 'r', 00H, 'o', 00H, 'w', 00H, 's', 00H
	DB	'>', 00H, '=', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'c', 00H, 'o', 00H, 'l', 00H, 's', 00H, '>', 00H, '=', 00H
	DB	'0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"', 00H, 'I'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 's', 00H, ' '
	DB	00H, 'w', 00H, 'h', 00H, 'e', 00H, 'n', 00H, ' ', 00H, 'r', 00H
	DB	'e', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, ' ', 00H, 'a', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 't', 00H
	DB	'r', 00H, 'i', 00H, 'x', 00H, ' ', 00H, 'o', 00H, 'r', 00H, ' '
	DB	00H, 'a', 00H, 'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '.', 00H
	DB	'"', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LINCKCAG@Invalid?5sizes?5when?5resizing?5a?5m@
CONST	SEGMENT
??_C@_0CP@LINCKCAG@Invalid?5sizes?5when?5resizing?5a?5m@ DB 'Invalid size'
	DB	's when resizing a matrix or array.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@NAOGFKEJ@?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN@
CONST	SEGMENT
??_C@_1EO@NAOGFKEJ@?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN@ DB 'o'
	DB	00H, 't', 00H, 'h', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'r', 00H
	DB	'o', 00H, 'w', 00H, 's', 00H, '(', 00H, ')', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '1', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, 'o', 00H, 't', 00H, 'h', 00H, 'e', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'o', 00H, 'l', 00H, 's', 00H, '(', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1MO@IEDNFCAN@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@
CONST	SEGMENT
??_C@_1MO@IEDNFCAN@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'm', 00H, 'a', 00H, 'r', 00H, 'i', 00H, 'j'
	DB	00H, '\', 00H, 'O', 00H, 'n', 00H, 'e', 00H, 'D', 00H, 'r', 00H
	DB	'i', 00H, 'v', 00H, 'e', 00H, '\', 00H, 'D', 00H, 'o', 00H, 'c'
	DB	00H, 'u', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'e', 00H
	DB	'n', 00H, '\', 00H, 'G', 00H, 'i', 00H, 't', 00H, 'H', 00H, 'u'
	DB	00H, 'b', 00H, '\', 00H, 'N', 00H, 'e', 00H, 'u', 00H, 'r', 00H
	DB	'a', 00H, 'l', 00H, '_', 00H, 'N', 00H, 'e', 00H, 't', 00H, 'w'
	DB	00H, 'o', 00H, 'r', 00H, 'k', 00H, '\', 00H, 'd', 00H, 'e', 00H
	DB	'p', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'n', 00H, 'c'
	DB	00H, 'i', 00H, 'e', 00H, 's', 00H, '\', 00H, 'E', 00H, 'i', 00H
	DB	'g', 00H, 'e', 00H, 'n', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'C', 00H, 'o', 00H, 'r', 00H, 'e', 00H, '\', 00H
	DB	'P', 00H, 'l', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'O', 00H, 'b'
	DB	00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'B', 00H, 'a', 00H
	DB	's', 00H, 'e', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@
CONST	SEGMENT
??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@ DB 'i'
	DB	00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '('
	DB	00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1MO@MNMFCLKA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@
CONST	SEGMENT
??_C@_1MO@MNMFCLKA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'm', 00H, 'a', 00H, 'r', 00H, 'i', 00H, 'j'
	DB	00H, '\', 00H, 'O', 00H, 'n', 00H, 'e', 00H, 'D', 00H, 'r', 00H
	DB	'i', 00H, 'v', 00H, 'e', 00H, '\', 00H, 'D', 00H, 'o', 00H, 'c'
	DB	00H, 'u', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'e', 00H
	DB	'n', 00H, '\', 00H, 'G', 00H, 'i', 00H, 't', 00H, 'H', 00H, 'u'
	DB	00H, 'b', 00H, '\', 00H, 'N', 00H, 'e', 00H, 'u', 00H, 'r', 00H
	DB	'a', 00H, 'l', 00H, '_', 00H, 'N', 00H, 'e', 00H, 't', 00H, 'w'
	DB	00H, 'o', 00H, 'r', 00H, 'k', 00H, '\', 00H, 'd', 00H, 'e', 00H
	DB	'p', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'n', 00H, 'c'
	DB	00H, 'i', 00H, 'e', 00H, 's', 00H, '\', 00H, 'E', 00H, 'i', 00H
	DB	'g', 00H, 'e', 00H, 'n', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'C', 00H, 'o', 00H, 'r', 00H, 'e', 00H, '\', 00H
	DB	'D', 00H, 'e', 00H, 'n', 00H, 's', 00H, 'e', 00H, 'C', 00H, 'o'
	DB	00H, 'e', 00H, 'f', 00H, 'f', 00H, 's', 00H, 'B', 00H, 'a', 00H
	DB	's', 00H, 'e', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1PM@EGIIFBMJ@?$AAa?$AAl?$AAi?$AAg?$AAn?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAi@
CONST	SEGMENT
??_C@_1PM@EGIIFBMJ@?$AAa?$AAl?$AAi?$AAg?$AAn?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAi@ DB 'a'
	DB	00H, 'l', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'm', 00H, 'e', 00H
	DB	'n', 00H, 't', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, 'o', 00H, 'f', 00H, '(', 00H
	DB	'v', 00H, 'o', 00H, 'i', 00H, 'd', 00H, '*', 00H, ')', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, '(', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'g', 00H, 'n', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't'
	DB	00H, ' ', 00H, '&', 00H, ' ', 00H, '(', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'g', 00H, 'n', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't'
	DB	00H, '-', 00H, '1', 00H, ')', 00H, ')', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, '"', 00H, 'A', 00H, 'l', 00H, 'i', 00H, 'g', 00H, 'n', 00H
	DB	'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'm', 00H, 'u'
	DB	00H, 's', 00H, 't', 00H, ' ', 00H, 'b', 00H, 'e', 00H, ' ', 00H
	DB	'a', 00H, 't', 00H, ' ', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 's'
	DB	00H, 't', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	'o', 00H, 'f', 00H, '(', 00H, 'v', 00H, 'o', 00H, 'i', 00H, 'd'
	DB	00H, '*', 00H, ')', 00H, ' ', 00H, 'a', 00H, 'n', 00H, 'd', 00H
	DB	' ', 00H, 'a', 00H, ' ', 00H, 'p', 00H, 'o', 00H, 'w', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, '2', 00H
	DB	'"', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1MG@ODDCIJJL@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@
CONST	SEGMENT
??_C@_1MG@ODDCIJJL@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'm', 00H, 'a', 00H, 'r', 00H, 'i', 00H, 'j'
	DB	00H, '\', 00H, 'O', 00H, 'n', 00H, 'e', 00H, 'D', 00H, 'r', 00H
	DB	'i', 00H, 'v', 00H, 'e', 00H, '\', 00H, 'D', 00H, 'o', 00H, 'c'
	DB	00H, 'u', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'e', 00H
	DB	'n', 00H, '\', 00H, 'G', 00H, 'i', 00H, 't', 00H, 'H', 00H, 'u'
	DB	00H, 'b', 00H, '\', 00H, 'N', 00H, 'e', 00H, 'u', 00H, 'r', 00H
	DB	'a', 00H, 'l', 00H, '_', 00H, 'N', 00H, 'e', 00H, 't', 00H, 'w'
	DB	00H, 'o', 00H, 'r', 00H, 'k', 00H, '\', 00H, 'd', 00H, 'e', 00H
	DB	'p', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'n', 00H, 'c'
	DB	00H, 'i', 00H, 'e', 00H, 's', 00H, '\', 00H, 'E', 00H, 'i', 00H
	DB	'g', 00H, 'e', 00H, 'n', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'C', 00H, 'o', 00H, 'r', 00H, 'e', 00H, '\', 00H
	DB	'u', 00H, 't', 00H, 'i', 00H, 'l', 00H, '\', 00H, 'M', 00H, 'e'
	DB	00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@CKLHOJNA@Alignment?5must?5be?5at?5least?5size@
CONST	SEGMENT
??_C@_0DK@CKLHOJNA@Alignment?5must?5be?5at?5least?5size@ DB 'Alignment mu'
	DB	'st be at least sizeof(void*) and a power of 2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
$SG4294967289 DB 'AVX SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2', 00H
$SG4294967136 DB 00H
$SG4294967162 DB 0aH, 00H
$SG4294967135 DB 00H
$SG4294967134 DB 00H
$SG4294967164 DB 'dat/test_images.idx3-ubyte', 00H
$SG4294967133 DB 00H
$SG4294967161 DB 0aH, 00H
	ORG $+2
$SG4294967163 DB 'dat/test_labels.idx1-ubyte', 00H
	ORG $+1
$SG4294967132 DB 0aH, 00H
	ORG $+2
$SG4294967160 DB 09H, 09H, 'ans: ', 00H
$SG4294967159 DB 'calc: ', 00H
	ORG $+1
$SG4294967131 DB ' ', 00H
PUBLIC	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
PUBLIC	??$pstoret@NU__m256d@@$0CA@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z ; Eigen::internal::pstoret<double,__m256d,32>
PUBLIC	??$ploadt@U__m256d@@$0CA@@internal@Eigen@@YA?AU__m256d@@PEBN@Z ; Eigen::internal::ploadt<__m256d,32>
PUBLIC	??$assignPacket@$0CA@U__m256d@@@?$assign_op@NN@internal@Eigen@@QEBAXPEANAEBU__m256d@@@Z ; Eigen::internal::assign_op<double,double>::assignPacket<32,__m256d>
PUBLIC	??$packet@$0CA@U__m256d@@@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEBA?AU__m256d@@_J@Z ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >::packet<32,__m256d>
PUBLIC	?assignCoeff@?$assign_op@NN@internal@Eigen@@QEBAXAEANAEBN@Z ; Eigen::internal::assign_op<double,double>::assignCoeff
PUBLIC	?coeff@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEBAAEBN_J@Z ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >::coeff
PUBLIC	?coeffRef@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAAAEAN_J@Z ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::coeffRef
PUBLIC	?assignCoeff@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAAX_J@Z ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::assignCoeff
PUBLIC	??$run@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@@?$unaligned_dense_assignment_loop@$0A@@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@12@_J1@Z ; Eigen::internal::unaligned_dense_assignment_loop<0>::run<Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0> >
PUBLIC	??$assignPacket@$0CA@$0CA@U__m256d@@@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAAX_J@Z ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::assignPacket<32,32,__m256d>
PUBLIC	??$run@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@@?$unaligned_dense_assignment_loop@$00@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@12@_J1@Z ; Eigen::internal::unaligned_dense_assignment_loop<1>::run<Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0> >
PUBLIC	??$first_aligned@$0CA@N_J@internal@Eigen@@YA_JPEBN_J@Z ; Eigen::internal::first_aligned<32,double,__int64>
PUBLIC	??$resize_if_allowed@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@NN@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z ; Eigen::internal::resize_if_allowed<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,double,double>
PUBLIC	?rows@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::rows
PUBLIC	?cols@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::cols
PUBLIC	?size@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::size
PUBLIC	?innerSize@?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::DenseBase<Eigen::Matrix<double,28,28,0,28,28> >::innerSize
PUBLIC	?innerSize@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::innerSize
PUBLIC	?data@?$DenseStorage@N$0DBA@$0BM@$0BM@$0A@@Eigen@@QEBAPEBNXZ ; Eigen::DenseStorage<double,784,28,28,0>::data
PUBLIC	?outerStride@?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEBA_JXZ ; Eigen::Matrix<double,28,28,0,28,28>::outerStride
PUBLIC	?derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::derived
PUBLIC	?rows@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::rows
PUBLIC	?cols@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::cols
PUBLIC	?data@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEBAPEBNXZ ; Eigen::DenseStorage<double,-1,-1,-1,0>::data
PUBLIC	?data@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAPEANXZ ; Eigen::DenseStorage<double,-1,-1,-1,0>::data
PUBLIC	?outerStride@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEBA_JXZ ; Eigen::Matrix<double,-1,-1,0,-1,-1>::outerStride
PUBLIC	?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@$02@Eigen@@QEBA_JXZ ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,28,28,0,28,28>,3>::outerStride
PUBLIC	?data@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAPEBNXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::data
PUBLIC	?size@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::size
PUBLIC	?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$02@Eigen@@QEBA_JXZ ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,-1,0,-1,-1>,3>::outerStride
PUBLIC	?data@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAPEBNXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::data
PUBLIC	?data@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAPEANXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::data
PUBLIC	??0?$evaluator_base@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >::evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >
PUBLIC	??0?$plainobjectbase_evaluator_data@N$0BM@@internal@Eigen@@QEAA@PEBN_J@Z ; Eigen::internal::plainobjectbase_evaluator_data<double,28>::plainobjectbase_evaluator_data<double,28>
PUBLIC	??0?$evaluator_base@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >::evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >
PUBLIC	??0?$plainobjectbase_evaluator_data@N$0?0@internal@Eigen@@QEAA@PEBN_J@Z ; Eigen::internal::plainobjectbase_evaluator_data<double,-1>::plainobjectbase_evaluator_data<double,-1>
PUBLIC	?rows@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEBA_JXZ ; Eigen::DenseStorage<double,-1,-1,-1,0>::rows
PUBLIC	?cols@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEBA_JXZ ; Eigen::DenseStorage<double,-1,-1,-1,0>::cols
PUBLIC	??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >
PUBLIC	??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >
PUBLIC	?size@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEBA_JXZ ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::size
PUBLIC	?dstDataPtr@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEBAPEBNXZ ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::dstDataPtr
PUBLIC	?const_cast_derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::const_cast_derived
PUBLIC	?rows@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::rows
PUBLIC	?cols@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::cols
PUBLIC	?run@?$checkTransposeAliasing_impl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@3@@Z ; Eigen::internal::checkTransposeAliasing_impl<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,0>::run
PUBLIC	??1?$evaluator_base@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >::~evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >
PUBLIC	??0?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@@Z ; Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >::evaluator<Eigen::Matrix<double,28,28,0,28,28> >
PUBLIC	??1?$evaluator_base@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >::~evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >
PUBLIC	??0?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@Z ; Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >
PUBLIC	??0?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAA@AEAU?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@12@AEBU?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@12@AEBU?$assign_op@NN@12@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@Z ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>
PUBLIC	?run@?$dense_assignment_loop@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@$02$0A@@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@23@@Z ; Eigen::internal::dense_assignment_loop<Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>,3,0>::run
PUBLIC	??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::~evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >
PUBLIC	??1?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >::~evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >
PUBLIC	??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >::~evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >
PUBLIC	??1?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >::~evaluator<Eigen::Matrix<double,28,28,0,28,28> >
PUBLIC	??$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z ; Eigen::internal::call_dense_assignment_loop<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,Eigen::internal::assign_op<double,double> >
PUBLIC	??$check_for_aliasing@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@@internal@Eigen@@YAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@@Z ; Eigen::internal::check_for_aliasing<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28> >
PUBLIC	??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z ; Eigen::internal::construct_elements_of_array<double>
PUBLIC	??$conditional_aligned_malloc@$00@internal@Eigen@@YAPEAX_K@Z ; Eigen::internal::conditional_aligned_malloc<1>
PUBLIC	??$check_size_for_overflow@N@internal@Eigen@@YAX_K@Z ; Eigen::internal::check_size_for_overflow<double>
PUBLIC	?run@?$Assignment@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@UDense2Dense@52@X@internal@Eigen@@SAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@3@AEBU?$assign_op@NN@23@@Z ; Eigen::internal::Assignment<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,Eigen::internal::assign_op<double,double>,Eigen::internal::Dense2Dense,void>::run
PUBLIC	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
PUBLIC	??$call_assignment_no_alias@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z ; Eigen::internal::call_assignment_no_alias<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,Eigen::internal::assign_op<double,double> >
PUBLIC	??$run@_J@?$check_rows_cols_for_overflow@$0?0@internal@Eigen@@SAX_J0@Z ; Eigen::internal::check_rows_cols_for_overflow<-1>::run<__int64>
PUBLIC	??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
PUBLIC	?rows@?$DenseStorage@N$0DBA@$0BM@$0BM@$0A@@Eigen@@SA_JXZ ; Eigen::DenseStorage<double,784,28,28,0>::rows
PUBLIC	?cols@?$DenseStorage@N$0DBA@$0BM@$0BM@$0A@@Eigen@@SA_JXZ ; Eigen::DenseStorage<double,784,28,28,0>::cols
PUBLIC	?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z ; Eigen::DenseStorage<double,-1,-1,-1,0>::resize
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?rows@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::rows
PUBLIC	?cols@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::cols
PUBLIC	?derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::derived
PUBLIC	?resize@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAX_J0@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::resize
PUBLIC	??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
PUBLIC	??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$construct_at@PEADAEBQEADX@std@@YAPEAPEADQEAPEADAEBQEAD@Z ; std::construct_at<char *,char * const &,void>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * const &>
PUBLIC	??$max@_J@std@@YAAEB_JAEB_J0@Z			; std::max<__int64>
PUBLIC	??$_set_noalias@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::_set_noalias<Eigen::Matrix<double,28,28,0,28,28> >
PUBLIC	??$resizeLike@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::resizeLike<Eigen::Matrix<double,28,28,0,28,28> >
PUBLIC	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Get_buffer_view@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AU_Buffer_view@12@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Get_buffer_view
PUBLIC	?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
PUBLIC	?run@?$default_digits10_impl@N$00$0A@@internal@Eigen@@SAHXZ ; Eigen::internal::default_digits10_impl<double,1,0>::run
PUBLIC	?digits10@?$GenericNumTraits@N@Eigen@@SAHXZ	; Eigen::GenericNumTraits<double>::digits10
PUBLIC	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	??0?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@XZ ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >
PUBLIC	??0?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ ; Eigen::DenseStorage<double,-1,-1,-1,0>::DenseStorage<double,-1,-1,-1,0>
PUBLIC	?_check_template_params@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@SAXXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::_check_template_params
PUBLIC	?coeff@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBN_J0@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::coeff
PUBLIC	?run@?$significant_decimals_impl@N@internal@Eigen@@SAHXZ ; Eigen::internal::significant_decimals_impl<double>::run
PUBLIC	?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2
PUBLIC	??0?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@XZ ; Eigen::MatrixBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::MatrixBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Voidify_iter@PEAPEAD@std@@YAPEAXPEAPEAD@Z	; std::_Voidify_iter<char * *>
PUBLIC	??$construct_at@PEADAEAPEADX@std@@YAPEAPEADQEAPEADAEAPEAD@Z ; std::construct_at<char *,char * &,void>
PUBLIC	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z	; std::forward<char * &>
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$_Voidify_iter@PEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAXPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@@Z ; std::_Voidify_iter<std::_String_val<std::_Simple_types<char> >::_Bxty *>
PUBLIC	??$construct_at@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$VX@std@@YAPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@QEAT120@@Z ; std::construct_at<std::_String_val<std::_Simple_types<char> >::_Bxty,void>
PUBLIC	??$addressof@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@AEAT120@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> >::_Bxty>
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$conditional_aligned_free@$00@internal@Eigen@@YAXPEAX@Z ; Eigen::internal::conditional_aligned_free<1>
PUBLIC	??$destruct_elements_of_array@N@internal@Eigen@@YAXPEAN_K@Z ; Eigen::internal::destruct_elements_of_array<double>
PUBLIC	??$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z ; Eigen::internal::print_matrix<Eigen::Matrix<double,1,-1,1,1,-1> >
PUBLIC	??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> ><Eigen::Matrix<double,28,28,0,28,28> >
PUBLIC	??$forward@AEBD@std@@YAAEBDAEBD@Z		; std::forward<char const &>
PUBLIC	??$_Voidify_iter@PEAD@std@@YAPEAXPEAD@Z		; std::_Voidify_iter<char *>
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?derived@?$BaseExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@@symbolic@Eigen@@QEBAAEBV?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@23@XZ ; Eigen::symbolic::BaseExpr<Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag> >::derived
PUBLIC	??0?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@symbolic@Eigen@@QEAA@AEBV?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@12@AEBV?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@12@@Z ; Eigen::symbolic::AddExpr<Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag>,Eigen::symbolic::ValueExpr<Eigen::internal::FixedInt<1> > >::AddExpr<Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag>,Eigen::symbolic::ValueExpr<Eigen::internal::FixedInt<1> > >
PUBLIC	??0?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@symbolic@Eigen@@QEAA@XZ ; Eigen::symbolic::ValueExpr<Eigen::internal::FixedInt<1> >::ValueExpr<Eigen::internal::FixedInt<1> >
PUBLIC	?derived@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::derived
PUBLIC	?eval@?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$00$0?0$00$00$0?0@2@XZ ; Eigen::DenseBase<Eigen::Matrix<double,1,-1,1,1,-1> >::eval
PUBLIC	??1IOFormat@Eigen@@QEAA@XZ			; Eigen::IOFormat::~IOFormat
PUBLIC	??0?$FixedInt@$00@internal@Eigen@@QEAA@XZ	; Eigen::internal::FixedInt<1>::FixedInt<1>
PUBLIC	??$ignore_unused_variable@_J@internal@Eigen@@YAXAEB_J@Z ; Eigen::internal::ignore_unused_variable<__int64>
PUBLIC	??$construct_at@DAEBDX@std@@YAPEADQEADAEBD@Z	; std::construct_at<char,char const &,void>
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z	; std::_Deallocate<16,0>
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
PUBLIC	??$_Construct_in_place@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$V@std@@YAXAEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@@Z ; std::_Construct_in_place<std::_String_val<std::_Simple_types<char> >::_Bxty>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$addressof@D@std@@YAPEADAEAD@Z		; std::addressof<char>
PUBLIC	??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
PUBLIC	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$_Convert_size@_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64>
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z		; std::max<char *>
PUBLIC	??$conditional_aligned_delete_auto@N$00@internal@Eigen@@YAXPEAN_K@Z ; Eigen::internal::conditional_aligned_delete_auto<double,1>
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z ; Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >
PUBLIC	??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBU?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z ; Eigen::Matrix<double,-1,-1,0,-1,-1>::Matrix<double,-1,-1,0,-1,-1><Eigen::Matrix<double,28,28,0,28,28> >
PUBLIC	??$?H$00@?$BaseExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@@symbolic@Eigen@@QEBA?AV?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@12@V?$FixedInt@$00@internal@2@@Z ; Eigen::symbolic::BaseExpr<Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag> >::operator+<1>
PUBLIC	?innerSize@?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::DenseBase<Eigen::Matrix<double,1,-1,1,1,-1> >::innerSize
PUBLIC	?data@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEBAPEBNXZ ; Eigen::DenseStorage<double,-1,1,-1,1>::data
PUBLIC	?outerStride@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEBA_JXZ ; Eigen::Matrix<double,1,-1,1,1,-1>::outerStride
PUBLIC	?outerStride@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$02@Eigen@@QEBA_JXZ ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,1,-1,1,1,-1>,3>::outerStride
PUBLIC	?rows@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@SA_JXZ ; Eigen::DenseStorage<double,-1,1,-1,1>::rows
PUBLIC	?cols@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEBA_JXZ ; Eigen::DenseStorage<double,-1,1,-1,1>::cols
PUBLIC	?data@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAPEBNXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::data
PUBLIC	??0?$evaluator_base@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >::evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >
PUBLIC	??0?$plainobjectbase_evaluator_data@N$0A@@internal@Eigen@@QEAA@PEBN_J@Z ; Eigen::internal::plainobjectbase_evaluator_data<double,0>::plainobjectbase_evaluator_data<double,0>
PUBLIC	?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z	; std::_Char_traits<char,int>::assign
PUBLIC	?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z	; std::_Char_traits<char,int>::assign
PUBLIC	?derived@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$00$0?0$00$00$0?0@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::derived
PUBLIC	?rows@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::rows
PUBLIC	?cols@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::cols
PUBLIC	??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >
PUBLIC	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::move
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??0?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@XZ ; Eigen::DenseBase<Eigen::Matrix<double,28,28,0,28,28> >::DenseBase<Eigen::Matrix<double,28,28,0,28,28> >
PUBLIC	?derived@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$00$0?0$00$00$0?0@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::derived
PUBLIC	?rows@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::rows
PUBLIC	?cols@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::cols
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??1?$evaluator_base@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >::~evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >
PUBLIC	?coeffRef@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAAAEAN_J@Z ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >::coeffRef
PUBLIC	??0?$evaluator@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$00$0?0$00$00$0?0@2@@Z ; Eigen::internal::evaluator<Eigen::Matrix<double,1,-1,1,1,-1> >::evaluator<Eigen::Matrix<double,1,-1,1,1,-1> >
PUBLIC	??0?$MatrixBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@XZ ; Eigen::MatrixBase<Eigen::Matrix<double,28,28,0,28,28> >::MatrixBase<Eigen::Matrix<double,28,28,0,28,28> >
PUBLIC	??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >::~evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >
PUBLIC	??1?$evaluator@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator<Eigen::Matrix<double,1,-1,1,1,-1> >::~evaluator<Eigen::Matrix<double,1,-1,1,1,-1> >
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	?eq@?$_Narrow_char_traits@DH@std@@SA_NAEBD0@Z	; std::_Narrow_char_traits<char,int>::eq
PUBLIC	?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
PUBLIC	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z ; std::_Narrow_char_traits<char,int>::not_eof
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??0?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@AEBV01@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >
PUBLIC	?size@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::size
PUBLIC	?coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,1,-1,1,1,-1>,1>::coeffRef
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ		; std::fpos<_Mbstatet>::operator __int64
PUBLIC	?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z ; std::pointer_traits<char *>::pointer_to
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
PUBLIC	??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	??0?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@QEAA@XZ ; Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag>::SymbolExpr<Eigen::internal::symbolic_last_tag>
PUBLIC	??R?$FixedInt@$00@internal@Eigen@@QEBA?AV012@XZ	; Eigen::internal::FixedInt<1>::operator()
PUBLIC	??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
PUBLIC	??1?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@QEAA@XZ ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::~Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >
PUBLIC	?get_data@?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@UEAA?AV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@_K@Z ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::get_data
PUBLIC	?get_label@?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@UEAAC_K@Z ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::get_label
PUBLIC	??0?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEAA@AEBV01@@Z ; Eigen::Matrix<double,28,28,0,28,28>::Matrix<double,28,28,0,28,28>
PUBLIC	??0?$initializer_list@I@std@@QEAA@PEBI0@Z	; std::initializer_list<unsigned int>::initializer_list<unsigned int>
PUBLIC	??1?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ ; Eigen::DenseStorage<double,-1,-1,-1,0>::~DenseStorage<double,-1,-1,-1,0>
PUBLIC	??A?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,1,-1,1,1,-1>,1>::operator[]
PUBLIC	??1?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEAA@XZ ; Eigen::DenseStorage<double,-1,1,-1,1>::~DenseStorage<double,-1,1,-1,1>
PUBLIC	?__autoclassinit2@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEAAX_K@Z ; Eigen::Matrix<double,1,-1,1,1,-1>::__autoclassinit2
PUBLIC	??1?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEAA@XZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::~PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >
PUBLIC	??1?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEAA@XZ	; Eigen::Matrix<double,1,-1,1,1,-1>::~Matrix<double,1,-1,1,1,-1>
PUBLIC	??1?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA@XZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::~PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >
PUBLIC	??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ ; Eigen::Matrix<double,-1,-1,0,-1,-1>::~Matrix<double,-1,-1,0,-1,-1>
PUBLIC	?__autoclassinit2@Data_Set@Mnist@@QEAAX_K@Z	; Mnist::Data_Set::__autoclassinit2
PUBLIC	??1Data_Set@Mnist@@QEAA@XZ			; Mnist::Data_Set::~Data_Set
PUBLIC	?__autoclassinit2@Network@Neural@@QEAAX_K@Z	; Neural::Network::__autoclassinit2
PUBLIC	main
PUBLIC	?get_label@Data_Set@Mnist@@UEAAC_K@Z		; Mnist::Data_Set::get_label
PUBLIC	?get_data@Data_Set@Mnist@@UEAA?AV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@_K@Z ; Mnist::Data_Set::get_data
PUBLIC	??0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z ; Eigen::IOFormat::IOFormat
PUBLIC	??0all_t@internal@Eigen@@QEAA@XZ		; Eigen::internal::all_t::all_t
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??$pstoreu@NU__m256d@@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z ; Eigen::internal::pstoreu<double,__m256d>
PUBLIC	??$pstore@NU__m256d@@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z ; Eigen::internal::pstore<double,__m256d>
PUBLIC	??$ploadu@U__m256d@@@internal@Eigen@@YA?AU__m256d@@PEBN@Z ; Eigen::internal::ploadu<__m256d>
PUBLIC	??$pload@U__m256d@@@internal@Eigen@@YA?AU__m256d@@PEBN@Z ; Eigen::internal::pload<__m256d>
PUBLIC	?aligned_free@internal@Eigen@@YAXPEAX@Z		; Eigen::internal::aligned_free
PUBLIC	?aligned_malloc@internal@Eigen@@YAPEAX_K@Z	; Eigen::internal::aligned_malloc
PUBLIC	?check_that_malloc_is_allowed@internal@Eigen@@YAXXZ ; Eigen::internal::check_that_malloc_is_allowed
PUBLIC	?handmade_aligned_free@internal@Eigen@@YAXPEAX@Z ; Eigen::internal::handmade_aligned_free
PUBLIC	?handmade_aligned_malloc@internal@Eigen@@YAPEAX_K0@Z ; Eigen::internal::handmade_aligned_malloc
PUBLIC	?throw_std_bad_alloc@internal@Eigen@@YAXXZ	; Eigen::internal::throw_std_bad_alloc
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??0bad_alloc@std@@QEAA@XZ			; std::bad_alloc::bad_alloc
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	?max@?$numeric_limits@_J@std@@SA_JXZ		; std::numeric_limits<__int64>::max
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4014000000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@40dfffc000000000
PUBLIC	__real@c014000000000000
PUBLIC	__xmm@80000000000000008000000000000000
EXTRN	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z:PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z:PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__chkstk:PROC
EXTRN	exp:PROC
EXTRN	memcmp:PROC
EXTRN	memmove:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
EXTRN	_tls_index:DWORD
?last@Eigen@@3V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@1@B DB 01H DUP (?) ; Eigen::last
	ALIGN	4

?all@Eigen@@3Uall_t@internal@1@B DB 01H DUP (?)		; Eigen::all
	ALIGN	4

?lastp1@Eigen@@3V?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@symbolic@1@B DW 01H DUP (?) ; Eigen::lastp1
	ALIGN	4

??$fix@$00@Eigen@@3V?$FixedInt@$00@internal@1@B DB 01H DUP (?) ; Eigen::fix<1>
	ALIGN	4

?end@placeholders@Eigen@@3V?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@symbolic@2@B DW 01H DUP (?) ; Eigen::placeholders::end
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$pstoret@NU__m256d@@$0CA@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z DD imagerel $LN5
	DD	imagerel $LN5+58
	DD	imagerel $unwind$??$pstoret@NU__m256d@@$0CA@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$ploadt@U__m256d@@$0CA@@internal@Eigen@@YA?AU__m256d@@PEBN@Z DD imagerel $LN5
	DD	imagerel $LN5+88
	DD	imagerel $unwind$??$ploadt@U__m256d@@$0CA@@internal@Eigen@@YA?AU__m256d@@PEBN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$assignPacket@$0CA@U__m256d@@@?$assign_op@NN@internal@Eigen@@QEBAXPEANAEBU__m256d@@@Z DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$??$assignPacket@$0CA@U__m256d@@@?$assign_op@NN@internal@Eigen@@QEBAXPEANAEBU__m256d@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$packet@$0CA@U__m256d@@@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEBA?AU__m256d@@_J@Z DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$??$packet@$0CA@U__m256d@@@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEBA?AU__m256d@@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assignCoeff@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAAX_J@Z DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$?assignCoeff@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAAX_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$run@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@@?$unaligned_dense_assignment_loop@$0A@@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@12@_J1@Z DD imagerel $LN6
	DD	imagerel $LN6+78
	DD	imagerel $unwind$??$run@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@@?$unaligned_dense_assignment_loop@$0A@@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@12@_J1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$assignPacket@$0CA@$0CA@U__m256d@@@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAAX_J@Z DD imagerel $LN3
	DD	imagerel $LN3+146
	DD	imagerel $unwind$??$assignPacket@$0CA@$0CA@U__m256d@@@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAAX_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$first_aligned@$0CA@N_J@internal@Eigen@@YA_JPEBN_J@Z DD imagerel $LN10
	DD	imagerel $LN10+162
	DD	imagerel $unwind$??$first_aligned@$0CA@N_J@internal@Eigen@@YA_JPEBN_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$resize_if_allowed@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@NN@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z DD imagerel $LN7
	DD	imagerel $LN7+170
	DD	imagerel $unwind$??$resize_if_allowed@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@NN@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rows@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$?rows@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cols@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$?cols@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?size@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?innerSize@?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN7
	DD	imagerel $LN7+90
	DD	imagerel $unwind$?innerSize@?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?innerSize@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN7
	DD	imagerel $LN7+90
	DD	imagerel $unwind$?innerSize@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?outerStride@?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$?outerStride@?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rows@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$?rows@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cols@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$?cols@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?outerStride@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$?outerStride@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@$02@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@$02@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?data@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAPEBNXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?data@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAPEBNXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?size@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$02@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$02@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?data@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAPEBNXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?data@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAPEBNXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?data@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAPEANXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?data@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAPEANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$plainobjectbase_evaluator_data@N$0BM@@internal@Eigen@@QEAA@PEBN_J@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??0?$plainobjectbase_evaluator_data@N$0BM@@internal@Eigen@@QEAA@PEBN_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+106
	DD	imagerel $unwind$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z@4HA DD imagerel ?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+106
	DD	imagerel $unwind$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z@4HA DD imagerel ?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?size@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dstDataPtr@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEBAPEBNXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?dstDataPtr@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEBAPEBNXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rows@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?rows@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cols@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?cols@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??0?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??0?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?run@?$dense_assignment_loop@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@$02$0A@@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@23@@Z DD imagerel $LN8
	DD	imagerel $LN8+201
	DD	imagerel $unwind$?run@?$dense_assignment_loop@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@$02$0A@@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z DD imagerel $LN5
	DD	imagerel $LN5+197
	DD	imagerel $unwind$??$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z@4HA DD imagerel ?dtor$0@?0???$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z@4HA
	DD	imagerel ?dtor$0@?0???$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z@4HA DD imagerel ?dtor$1@?0???$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z@4HA
	DD	imagerel ?dtor$1@?0???$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$check_for_aliasing@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@@internal@Eigen@@YAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+73
	DD	imagerel $unwind$??$check_for_aliasing@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@@internal@Eigen@@YAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z DD imagerel $LN13
	DD	imagerel $LN13+101
	DD	imagerel $unwind$??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z@4HA DD imagerel ?catch$0@?0???$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z@4HA
	DD	imagerel ?catch$0@?0???$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z@4HA+50
	DD	imagerel $unwind$?catch$0@?0???$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$conditional_aligned_malloc@$00@internal@Eigen@@YAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??$conditional_aligned_malloc@$00@internal@Eigen@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$check_size_for_overflow@N@internal@Eigen@@YAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+36
	DD	imagerel $unwind$??$check_size_for_overflow@N@internal@Eigen@@YAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?run@?$Assignment@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@UDense2Dense@52@X@internal@Eigen@@SAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@3@AEBU?$assign_op@NN@23@@Z DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$?run@?$Assignment@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@UDense2Dense@52@X@internal@Eigen@@SAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@3@AEBU?$assign_op@NN@23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z DD imagerel $LN12
	DD	imagerel $LN12+87
	DD	imagerel $unwind$??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z@4HA DD imagerel ?catch$0@?0???$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z@4HA
	DD	imagerel ?catch$0@?0???$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z@4HA+46
	DD	imagerel $unwind$?catch$0@?0???$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$call_assignment_no_alias@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??$call_assignment_no_alias@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$run@_J@?$check_rows_cols_for_overflow@$0?0@internal@Eigen@@SAX_J0@Z DD imagerel $LN8
	DD	imagerel $LN8+128
	DD	imagerel $unwind$??$run@_J@?$check_rows_cols_for_overflow@$0?0@internal@Eigen@@SAX_J0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD imagerel $LN26
	DD	imagerel $LN26+1039
	DD	imagerel $unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD imagerel ?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD imagerel ?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	imagerel ?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA+83
	DD	imagerel $unwind$?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z DD imagerel $LN6
	DD	imagerel $LN6+158
	DD	imagerel $unwind$?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rows@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+19
	DD	imagerel $unwind$?rows@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cols@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+19
	DD	imagerel $unwind$?cols@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAX_J0@Z DD imagerel $LN5
	DD	imagerel $LN5+146
	DD	imagerel $unwind$?resize@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAX_J0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z DD imagerel $LN7
	DD	imagerel $LN7+369
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@PEADAEBQEADX@std@@YAPEAPEADQEAPEADAEBQEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??$construct_at@PEADAEBQEADX@std@@YAPEAPEADQEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@_J@std@@YAAEB_JAEB_J0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$max@_J@std@@YAAEB_JAEB_J0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_set_noalias@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$??$_set_noalias@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$resizeLike@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z DD imagerel $LN9
	DD	imagerel $LN9+351
	DD	imagerel $unwind$??$resizeLike@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+159
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_buffer_view@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AU_Buffer_view@12@XZ DD imagerel $LN7
	DD	imagerel $LN7+373
	DD	imagerel $unwind$?_Get_buffer_view@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AU_Buffer_view@12@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+103
	DD	imagerel $unwind$?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?digits10@?$GenericNumTraits@N@Eigen@@SAHXZ DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$?digits10@?$GenericNumTraits@N@Eigen@@SAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD imagerel $LN4
	DD	imagerel $LN4+98
	DD	imagerel $unwind$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN7
	DD	imagerel $LN7+174
	DD	imagerel $unwind$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA DD imagerel ?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA
	DD	imagerel ?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+233
	DD	imagerel $unwind$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+29
	DD	imagerel $unwind$?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN5
	DD	imagerel $LN5+72
	DD	imagerel $unwind$?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?coeff@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBN_J0@Z DD imagerel $LN5
	DD	imagerel $LN5+185
	DD	imagerel $unwind$?coeff@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBN_J0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?run@?$significant_decimals_impl@N@internal@Eigen@@SAHXZ DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$?run@?$significant_decimals_impl@N@internal@Eigen@@SAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??0?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN12
	DD	imagerel $LN12+134
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@PEADAEAPEADX@std@@YAPEAPEADQEAPEADAEAPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??$construct_at@PEADAEAPEADX@std@@YAPEAPEADQEAPEADAEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$VX@std@@YAPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@QEAT120@@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??$construct_at@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$VX@std@@YAPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@QEAT120@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD imagerel $LN5
	DD	imagerel $LN5+135
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$conditional_aligned_free@$00@internal@Eigen@@YAXPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??$conditional_aligned_free@$00@internal@Eigen@@YAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z DD imagerel $LN34
	DD	imagerel $LN34+1716
	DD	imagerel $unwind$??$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z@4HA DD imagerel ?dtor$0@?0???$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+84
	DD	imagerel $unwind$??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD imagerel $LN5
	DD	imagerel $LN5+174
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+138
	DD	imagerel $unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eval@?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$00$0?0$00$00$0?0@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?eval@?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$00$0?0$00$00$0?0@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1IOFormat@Eigen@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+135
	DD	imagerel $unwind$??1IOFormat@Eigen@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@DAEBDX@std@@YAPEADQEADAEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$??$construct_at@DAEBDX@std@@YAPEADQEADAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+85
	DD	imagerel $unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+71
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD imagerel $LN5
	DD	imagerel $LN5+135
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD imagerel $LN7
	DD	imagerel $LN7+532
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$V@std@@YAXAEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@@Z DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$??$_Construct_in_place@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$V@std@@YAXAEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN10
	DD	imagerel $LN10+558
	DD	imagerel $unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN10
	DD	imagerel $LN10+621
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$conditional_aligned_delete_auto@N$00@internal@Eigen@@YAXPEAN_K@Z DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$??$conditional_aligned_delete_auto@N$00@internal@Eigen@@YAXPEAN_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN25
	DD	imagerel $LN25+1068
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+83
	DD	imagerel $unwind$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z DD imagerel $LN10
	DD	imagerel $LN10+414
	DD	imagerel $unwind$??$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA DD imagerel ?dtor$0@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA DD imagerel ?dtor$1@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
	DD	imagerel ?dtor$1@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA DD imagerel ?dtor$2@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
	DD	imagerel ?dtor$2@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA+27
	DD	imagerel $unwind$?dtor$2@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA DD imagerel ?dtor$3@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
	DD	imagerel ?dtor$3@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA+27
	DD	imagerel $unwind$?dtor$3@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA DD imagerel ?dtor$4@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
	DD	imagerel ?dtor$4@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA+27
	DD	imagerel $unwind$?dtor$4@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$5@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA DD imagerel ?dtor$5@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
	DD	imagerel ?dtor$5@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$5@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA DD imagerel ?dtor$6@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
	DD	imagerel ?dtor$6@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA+27
	DD	imagerel $unwind$?dtor$6@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBU?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBU?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?H$00@?$BaseExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@@symbolic@Eigen@@QEBA?AV?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@12@V?$FixedInt@$00@internal@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$??$?H$00@?$BaseExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@@symbolic@Eigen@@QEBA?AV?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@12@V?$FixedInt@$00@internal@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?$fix@$00@Eigen@@YAXXZ DD imagerel ??__E?$fix@$00@Eigen@@YAXXZ
	DD	imagerel ??__E?$fix@$00@Eigen@@YAXXZ+21
	DD	imagerel $unwind$??__E?$fix@$00@Eigen@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?innerSize@?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN7
	DD	imagerel $LN7+92
	DD	imagerel $unwind$?innerSize@?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?outerStride@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$?outerStride@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$02@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$02@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?data@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAPEBNXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?data@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAPEBNXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$plainobjectbase_evaluator_data@N$0A@@internal@Eigen@@QEAA@PEBN_J@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??0?$plainobjectbase_evaluator_data@N$0A@@internal@Eigen@@QEAA@PEBN_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z DD imagerel $LN11
	DD	imagerel $LN11+166
	DD	imagerel $unwind$?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rows@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+19
	DD	imagerel $unwind$?rows@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cols@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?cols@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+107
	DD	imagerel $unwind$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z@4HA DD imagerel ?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN16
	DD	imagerel $LN16+306
	DD	imagerel $unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rows@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$?rows@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cols@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$?cols@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN4
	DD	imagerel $LN4+111
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+89
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$evaluator@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$00$0?0$00$00$0?0@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??0?$evaluator@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$00$0?0$00$00$0?0@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MatrixBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??0?$MatrixBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$evaluator@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1?$evaluator@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+144
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eq@?$_Narrow_char_traits@DH@std@@SA_NAEBD0@Z DD imagerel $LN5
	DD	imagerel $LN5+59
	DD	imagerel $unwind$?eq@?$_Narrow_char_traits@DH@std@@SA_NAEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z DD imagerel $LN5
	DD	imagerel $LN5+55
	DD	imagerel $unwind$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z DD imagerel $LN7
	DD	imagerel $LN7+80
	DD	imagerel $unwind$?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN7
	DD	imagerel $LN7+273
	DD	imagerel $unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z DD imagerel $LN4
	DD	imagerel $LN4+174
	DD	imagerel $unwind$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+197
	DD	imagerel $unwind$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+239
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+235
	DD	imagerel $unwind$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??0?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?size@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$?coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z@4HA DD imagerel ?dtor$0@?0??coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z@4HA
	DD	imagerel ?dtor$0@?0??coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN7
	DD	imagerel $LN7+209
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA DD imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+79
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+83
	DD	imagerel $unwind$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+145
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+87
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+128
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD imagerel $LN6
	DD	imagerel $LN6+65
	DD	imagerel $unwind$?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+137
	DD	imagerel $unwind$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN16
	DD	imagerel $LN16+782
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN6
	DD	imagerel $LN6+256
	DD	imagerel $unwind$?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ DD imagerel $LN8
	DD	imagerel $LN8+298
	DD	imagerel $unwind$?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD imagerel $LN25
	DD	imagerel $LN25+772
	DD	imagerel $unwind$?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN12
	DD	imagerel $LN12+459
	DD	imagerel $unwind$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+106
	DD	imagerel $unwind$??1?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get_data@?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@UEAA?AV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?get_data@?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@UEAA?AV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$??0?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??1?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z DD imagerel $LN5
	DD	imagerel $LN5+87
	DD	imagerel $unwind$??A?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??1?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??1?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@Data_Set@Mnist@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@Data_Set@Mnist@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Data_Set@Mnist@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1Data_Set@Mnist@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@Network@Neural@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@Network@Neural@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN14
	DD	imagerel $LN14+754
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main$dtor$0 DD imagerel main$dtor$0
	DD	imagerel main$dtor$0+39
	DD	imagerel $unwind$main$dtor$0
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main$dtor$1 DD imagerel main$dtor$1
	DD	imagerel main$dtor$1+39
	DD	imagerel $unwind$main$dtor$1
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main$dtor$2 DD imagerel main$dtor$2
	DD	imagerel main$dtor$2+36
	DD	imagerel $unwind$main$dtor$2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main$dtor$3 DD imagerel main$dtor$3
	DD	imagerel main$dtor$3+39
	DD	imagerel $unwind$main$dtor$3
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get_data@Data_Set@Mnist@@UEAA?AV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?get_data@Data_Set@Mnist@@UEAA?AV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z DD imagerel $LN13
	DD	imagerel $LN13+488
	DD	imagerel $unwind$??0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA DD imagerel ?dtor$0@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
	DD	imagerel ?dtor$0@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA DD imagerel ?dtor$1@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
	DD	imagerel ?dtor$1@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA+31
	DD	imagerel $unwind$?dtor$1@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA DD imagerel ?dtor$2@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
	DD	imagerel ?dtor$2@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA+31
	DD	imagerel $unwind$?dtor$2@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA DD imagerel ?dtor$3@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
	DD	imagerel ?dtor$3@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA+31
	DD	imagerel $unwind$?dtor$3@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA DD imagerel ?dtor$4@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
	DD	imagerel ?dtor$4@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA+34
	DD	imagerel $unwind$?dtor$4@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$5@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA DD imagerel ?dtor$5@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
	DD	imagerel ?dtor$5@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA+34
	DD	imagerel $unwind$?dtor$5@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA DD imagerel ?dtor$6@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
	DD	imagerel ?dtor$6@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA+34
	DD	imagerel $unwind$?dtor$6@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eall@Eigen@@YAXXZ DD imagerel ??__Eall@Eigen@@YAXXZ
	DD	imagerel ??__Eall@Eigen@@YAXXZ+21
	DD	imagerel $unwind$??__Eall@Eigen@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Elastp1@Eigen@@YAXXZ DD imagerel ??__Elastp1@Eigen@@YAXXZ
	DD	imagerel ??__Elastp1@Eigen@@YAXXZ+49
	DD	imagerel $unwind$??__Elastp1@Eigen@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Elast@Eigen@@YAXXZ DD imagerel ??__Elast@Eigen@@YAXXZ
	DD	imagerel ??__Elast@Eigen@@YAXXZ+21
	DD	imagerel $unwind$??__Elast@Eigen@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$ploadu@U__m256d@@@internal@Eigen@@YA?AU__m256d@@PEBN@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$??$ploadu@U__m256d@@@internal@Eigen@@YA?AU__m256d@@PEBN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$pload@U__m256d@@@internal@Eigen@@YA?AU__m256d@@PEBN@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$??$pload@U__m256d@@@internal@Eigen@@YA?AU__m256d@@PEBN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?aligned_free@internal@Eigen@@YAXPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?aligned_free@internal@Eigen@@YAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?aligned_malloc@internal@Eigen@@YAPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$?aligned_malloc@internal@Eigen@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?handmade_aligned_free@internal@Eigen@@YAXPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+37
	DD	imagerel $unwind$?handmade_aligned_free@internal@Eigen@@YAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?handmade_aligned_malloc@internal@Eigen@@YAPEAX_K0@Z DD imagerel $LN6
	DD	imagerel $LN6+195
	DD	imagerel $unwind$?handmade_aligned_malloc@internal@Eigen@@YAPEAX_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?throw_std_bad_alloc@internal@Eigen@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?throw_std_bad_alloc@internal@Eigen@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN11
	DD	imagerel $LN11+154
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@AEAA@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$??0bad_alloc@std@@AEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@exception@std@@UEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?what@exception@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBDH@Z
pdata	ENDS
CRT$XCU	SEGMENT
?last$initializer$@Eigen@@3P6AXXZEA DQ FLAT:??__Elast@Eigen@@YAXXZ ; Eigen::last$initializer$
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c014000000000000
CONST	SEGMENT
__real@c014000000000000 DQ 0c014000000000000r	; -5
CONST	ENDS
;	COMDAT __real@40dfffc000000000
CONST	SEGMENT
__real@40dfffc000000000 DQ 040dfffc000000000r	; 32767
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBDH@Z DD 011001H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@exception@std@@UEBAPEBDXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@AEAA@QEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?throw_std_bad_alloc@internal@Eigen@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?handmade_aligned_malloc@internal@Eigen@@YAPEAX_K0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?handmade_aligned_free@internal@Eigen@@YAXPEAX@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?aligned_malloc@internal@Eigen@@YAPEAX_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?aligned_free@internal@Eigen@@YAXPEAX@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$pload@U__m256d@@@internal@Eigen@@YA?AU__m256d@@PEBN@Z DD 021301H
	DD	05006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$ploadu@U__m256d@@@internal@Eigen@@YA?AU__m256d@@PEBN@Z DD 021301H
	DD	05006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Elast@Eigen@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Elastp1@Eigen@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eall@Eigen@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$5@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z DB 012H
	DB	00H
	DB	00H
	DB	'n'
	DB	02H
	DB	'H'
	DB	04H
	DB	'H'
	DB	06H
	DB	'H'
	DB	08H
	DB	'L'
	DB	0aH
	DB	'J'
	DB	0cH
	DB	'L'
	DB	0eH
	DB	01dH, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z DB 0eH
	DB	0eH
	DD	imagerel ?dtor$0@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z DB 028H
	DD	imagerel $stateUnwindMap$??0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z
	DD	imagerel $ip2state$??0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z DD 011711H
	DD	0e217H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get_data@Data_Set@Mnist@@UEAA?AV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main$dtor$3 DD 030801H
	DD	0d0044208H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main$dtor$2 DD 030801H
	DD	0d0044208H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main$dtor$1 DD 030801H
	DD	0d0044208H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main$dtor$0 DD 030801H
	DD	0d0044208H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$main DB 010H
	DB	00H
	DB	00H
	DB	'a', 02H
	DB	02H
	DB	090H
	DB	04H
	DB	0f2H
	DB	06H
	DB	'0'
	DB	0aH
	DB	0cdH, 04H
	DB	04H
	DB	'0'
	DB	02H
	DB	01aH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$main DB 0aH
	DB	0eH
	DD	imagerel main$dtor$0
	DB	02eH
	DD	imagerel main$dtor$1
	DB	02eH
	DD	imagerel main$dtor$2
	DB	02eH
	DD	imagerel main$dtor$3
	DB	07eH
	DD	imagerel main$dtor$3
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$main DB 028H
	DD	imagerel $stateUnwindMap$main
	DD	imagerel $ip2state$main
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	053319H
	DD	06480119H
	DD	0600b700cH
	DD	0500aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$main
	DD	031f6H
	DD	040H
	DD	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@Network@Neural@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Data_Set@Mnist@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@Data_Set@Mnist@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEAA@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get_data@?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@UEAA?AV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 011801H
	DD	0c218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD 011801H
	DD	0e218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ DD 011819H
	DD	0a209H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 010d01H
	DD	0820dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 021001H
	DD	0130110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	0a4H
	DB	02H
	DB	'j'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0a20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	0a5H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z DB 06H
	DB	00H
	DB	00H
	DB	'h'
	DB	02H
	DB	'<'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z DB 028H
	DD	imagerel $stateUnwindMap$?coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z
	DD	imagerel $ip2state$?coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z DD 010e11H
	DD	0a20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@AEBV01@@Z DD 031001H
	DD	0700c4210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ DD 010919H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010919H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010919H
	DD	0a209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z DD 010d01H
	DD	0820dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DB 060H
	DD	imagerel $ip2state$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 010e19H
	DD	0820eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eq@?$_Narrow_char_traits@DH@std@@SA_NAEBD0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 031501H
	DD	070116215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$evaluator@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MatrixBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$evaluator@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$00$0?0$00$00$0?0@2@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?cols@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?cols@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ DB 060H
	DD	imagerel $ip2state$?cols@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cols@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?cols@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?rows@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?rows@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ DB 060H
	DD	imagerel $ip2state$?rows@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rows@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?rows@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD 031001H
	DD	0700c6210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z DD 021401H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	02H
	DB	090H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z
	DD	imagerel $ip2state$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cols@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rows@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$plainobjectbase_evaluator_data@N$0A@@internal@Eigen@@QEAA@PEBN_J@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?data@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAPEBNXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$02@Eigen@@QEBA_JXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$02@Eigen@@QEBA_JXZ DB 060H
	DD	imagerel $ip2state$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$02@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$02@Eigen@@QEBA_JXZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$02@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?outerStride@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEBA_JXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?outerStride@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEBA_JXZ DB 060H
	DD	imagerel $ip2state$?outerStride@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?outerStride@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEBA_JXZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?outerStride@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?innerSize@?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?$fix@$00@Eigen@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?H$00@?$BaseExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@@symbolic@Eigen@@QEBA?AV?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@12@V?$FixedInt@$00@internal@2@@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBU?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$5@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z DB 01eH
	DB	00H
	DB	00H
	DB	'L'
	DB	02H
	DB	'*'
	DB	04H
	DB	'*'
	DB	06H
	DB	'*'
	DB	08H
	DB	'*'
	DB	0aH
	DB	'$'
	DB	0cH
	DB	0deH
	DB	0eH
	DB	'p'
	DB	0cH
	DB	01cH
	DB	0aH
	DB	016H
	DB	08H
	DB	01cH
	DB	06H
	DB	01cH
	DB	04H
	DB	01cH
	DB	02H
	DB	01cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z DB 0eH
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z
	DD	imagerel $ip2state$??$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z DD 021111H
	DD	0470111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0aH
	DB	00H
	DB	00H
	DB	0c1H, 03H
	DB	02H
	DB	'H'
	DB	04H
	DB	'}', 0aH
	DB	02H
	DB	098H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 038H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	0cbH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$conditional_aligned_delete_auto@N$00@internal@Eigen@@YAXPEAN_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 012219H
	DD	0e213H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 012219H
	DD	0e213H
	DD	imagerel __GSHandlerCheck
	DD	068H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$V@std@@YAXAEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD 022d19H
	DD	013011bH
	DD	imagerel __GSHandlerCheck
	DD	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@DAEBDX@std@@YAPEADQEADAEBD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1IOFormat@Eigen@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eval@?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$00$0?0$00$00$0?0@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD 011819H
	DD	0a209H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD 012219H
	DD	08213H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	'L'
	DB	02H
	DB	'H'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z
	DD	imagerel $ip2state$??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	0cdH, 07H
	DB	02H
	DB	'Q', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z
	DD	imagerel $ip2state$??$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z DD 022819H
	DD	0410116H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z
	DD	01faH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$conditional_aligned_free@$00@internal@Eigen@@YAXPEAX@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$VX@std@@YAPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@QEAT120@@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@PEADAEAPEADX@std@@YAPEAPEADQEAPEADAEAPEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?run@?$significant_decimals_impl@N@internal@Eigen@@SAHXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?coeff@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBN_J0@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 08H
	DB	00H
	DB	00H
	DB	0a0H
	DB	02H
	DB	'\'
	DB	04H
	DB	0c2H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010d11H
	DD	0620dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DB 06H
	DB	00H
	DB	00H
	DB	'~'
	DB	02H
	DB	096H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DB 028H
	DD	imagerel $stateUnwindMap$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	imagerel $ip2state$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 011d19H
	DD	0e20eH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	02H
	DB	'~'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	imagerel $ip2state$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 010d11H
	DD	0420dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?digits10@?$GenericNumTraits@N@Eigen@@SAHXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z DD 010801H
	DD	02208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Get_buffer_view@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AU_Buffer_view@12@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Get_buffer_view@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AU_Buffer_view@12@XZ DB 060H
	DD	imagerel $ip2state$?_Get_buffer_view@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AU_Buffer_view@12@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_buffer_view@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AU_Buffer_view@12@XZ DD 031f19H
	DD	0700cc210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?_Get_buffer_view@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AU_Buffer_view@12@XZ
	DD	053H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$resizeLike@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_set_noalias@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@_J@std@@YAAEB_JAEB_J0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@PEADAEBQEADX@std@@YAPEAPEADQEAPEADAEBQEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z DD 012719H
	DD	0a218H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAX_J0@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cols@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rows@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 0aH
	DB	00H
	DB	00H
	DB	'}', 03H
	DB	02H
	DB	'H'
	DB	04H
	DB	'M', 0aH
	DB	02H
	DB	098H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	imagerel $tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	imagerel $ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD 022819H
	DD	0190116H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	0bbH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$run@_J@?$check_rows_cols_for_overflow@$0?0@internal@Eigen@@SAX_J0@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$call_assignment_no_alias@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z DB 06H
	DB	00H
	DB	00H
	DB	'v'
	DB	02H
	DB	' '
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z DB 038H
	DD	imagerel $stateUnwindMap$??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z
	DD	imagerel $tryMap$??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z
	DD	imagerel $ip2state$??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?run@?$Assignment@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@UDense2Dense@52@X@internal@Eigen@@SAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@3@AEBU?$assign_op@NN@23@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$check_size_for_overflow@N@internal@Eigen@@YAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$conditional_aligned_malloc@$00@internal@Eigen@@YAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z DB 04H
	DB	00H
	DB	00H
	DB	01cH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z DB 038H
	DD	imagerel $stateUnwindMap$??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z
	DD	imagerel $tryMap$??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z
	DD	imagerel $ip2state$??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z DD 010e19H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$check_for_aliasing@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@@internal@Eigen@@YAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z DB 0aH
	DB	00H
	DB	00H
	DB	'j'
	DB	02H
	DB	'`'
	DB	04H
	DB	'r'
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z
	DD	imagerel $ip2state$??$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z DD 012219H
	DD	0e213H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z
	DD	06aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?run@?$dense_assignment_loop@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@$02$0A@@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@23@@Z DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cols@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rows@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dstDataPtr@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEBAPEBNXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEBA_JXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	02H
	DB	08eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z
	DD	imagerel $ip2state$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	02H
	DB	08eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z
	DD	imagerel $ip2state$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$plainobjectbase_evaluator_data@N$0BM@@internal@Eigen@@QEAA@PEBN_J@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?data@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAPEANXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?data@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAPEBNXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$02@Eigen@@QEBA_JXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$02@Eigen@@QEBA_JXZ DB 060H
	DD	imagerel $ip2state$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$02@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$02@Eigen@@QEBA_JXZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$02@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?data@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAPEBNXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@$02@Eigen@@QEBA_JXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@$02@Eigen@@QEBA_JXZ DB 060H
	DD	imagerel $ip2state$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@$02@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@$02@Eigen@@QEBA_JXZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@$02@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?outerStride@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEBA_JXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?outerStride@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEBA_JXZ DB 060H
	DD	imagerel $ip2state$?outerStride@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?outerStride@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEBA_JXZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?outerStride@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?cols@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?cols@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ DB 060H
	DD	imagerel $ip2state$?cols@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cols@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?cols@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?rows@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?rows@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ DB 060H
	DD	imagerel $ip2state$?rows@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rows@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?rows@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?outerStride@?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEBA_JXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?outerStride@?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEBA_JXZ DB 060H
	DD	imagerel $ip2state$?outerStride@?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?outerStride@?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEBA_JXZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?outerStride@?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?innerSize@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?innerSize@?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?cols@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?cols@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ DB 060H
	DD	imagerel $ip2state$?cols@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cols@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?cols@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?rows@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?rows@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ DB 060H
	DD	imagerel $ip2state$?rows@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rows@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?rows@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$resize_if_allowed@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@NN@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$first_aligned@$0CA@N_J@internal@Eigen@@YA_JPEBN_J@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$assignPacket@$0CA@$0CA@U__m256d@@@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAAX_J@Z DD 031b01H
	DD	0140112H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$run@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@@?$unaligned_dense_assignment_loop@$0A@@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@12@_J1@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assignCoeff@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAAX_J@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$packet@$0CA@U__m256d@@@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEBA?AU__m256d@@_J@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$assignPacket@$0CA@U__m256d@@@?$assign_op@NN@internal@Eigen@@QEBAXPEANAEBU__m256d@@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$ploadt@U__m256d@@$0CA@@internal@Eigen@@YA?AU__m256d@@PEBN@Z DD 021601H
	DD	05006f20dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$pstoret@NU__m256d@@$0CA@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
CRT$XCU	SEGMENT
?lastp1$initializer$@Eigen@@3P6AXXZEA DQ FLAT:??__Elastp1@Eigen@@YAXXZ ; Eigen::lastp1$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?all$initializer$@Eigen@@3P6AXXZEA DQ FLAT:??__Eall@Eigen@@YAXXZ ; Eigen::all$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?all$initializer$@placeholders@Eigen@@3P6AXXZEA DQ FLAT:??__Eall@placeholders@Eigen@@YAXXZ ; Eigen::placeholders::all$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?last$initializer$@placeholders@Eigen@@3P6AXXZEA DQ FLAT:??__Elast@placeholders@Eigen@@YAXXZ ; Eigen::placeholders::last$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?end$initializer$@placeholders@Eigen@@3P6AXXZEA DQ FLAT:??__Eend@placeholders@Eigen@@YAXXZ ; Eigen::placeholders::end$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??$fix@$00$initializer$@Eigen@@3P6AXXZEA DQ FLAT:??__E?$fix@$00@Eigen@@YAXXZ ; ??$fix@$00$initializer$@Eigen@@3P6AXXZEA
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 168  :     {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 169  :         (void)_Size;
; 170  :         return _Where;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR _Where$[rsp]

; 171  :     }

  0000f	c3		 ret	 0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 170  :     return __builtin_is_constant_evaluated();

  00000	32 c0		 xor	 al, al

; 171  : }

  00002	c3		 ret	 0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\limits
;	COMDAT ?max@?$numeric_limits@_J@std@@SA_JXZ
_TEXT	SEGMENT
?max@?$numeric_limits@_J@std@@SA_JXZ PROC		; std::numeric_limits<__int64>::max, COMDAT

; 642  :         return LLONG_MAX;

  00000	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH

; 643  :     }

  0000a	c3		 ret	 0
?max@?$numeric_limits@_J@std@@SA_JXZ ENDP		; std::numeric_limits<__int64>::max
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 16
_Message$ = 24
__formal$ = 32
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 66   :     {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  0001c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 65   :         : _Data()

  0001f	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00024	48 83 c0 08	 add	 rax, 8
  00028	48 8b f8	 mov	 rdi, rax
  0002b	33 c0		 xor	 eax, eax
  0002d	b9 10 00 00 00	 mov	 ecx, 16
  00032	f3 aa		 rep stosb

; 67   :         _Data._What = _Message;

  00034	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00039	48 8b 4c 24 18	 mov	 rcx, QWORD PTR _Message$[rsp]
  0003e	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 68   :     }

  00042	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 72   :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  0001b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 71   :         : _Data()

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00023	48 83 c0 08	 add	 rax, 8
  00027	48 8b f8	 mov	 rdi, rax
  0002a	33 c0		 xor	 eax, eax
  0002c	b9 10 00 00 00	 mov	 ecx, 16
  00031	f3 aa		 rep stosb

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00038	48 83 c0 08	 add	 rax, 8
  0003c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Other$[rsp]
  00041	48 83 c1 08	 add	 rcx, 8
  00045	48 8b d0	 mov	 rdx, rax
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___std_exception_copy

; 74   :     }

  0004e	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 89   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00015	48 89 08	 mov	 QWORD PTR [rax], rcx

; 90   :         __std_exception_destroy(&_Data);

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 83 c0 08	 add	 rax, 8
  00021	48 8b c8	 mov	 rcx, rax
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___std_exception_destroy

; 91   :     }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
tv69 = 0
this$ = 32
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 94   :     {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00013	74 0f		 je	 SHORT $LN3@what
  00015	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  0001a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001e	48 89 04 24	 mov	 QWORD PTR tv69[rsp], rax
  00022	eb 0b		 jmp	 SHORT $LN4@what
$LN3@what:
  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
  0002b	48 89 04 24	 mov	 QWORD PTR tv69[rsp], rax
$LN4@what:
  0002f	48 8b 04 24	 mov	 rax, QWORD PTR tv69[rsp]

; 96   :     }

  00033	48 83 c4 18	 add	 rsp, 24
  00037	c3		 ret	 0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1exception@std@@UEAA@XZ ; std::exception::~exception
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 18 00 00 00	 mov	 edx, 24
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0bad_alloc@std@@QEAA@XZ PROC				; std::bad_alloc::bad_alloc, COMDAT

; 121  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 120  :         : exception("bad allocation", 1)

  00009	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@GHFPNOJB@bad?5allocation@
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001b	e8 00 00 00 00	 call	 ??0exception@std@@QEAA@QEBDH@Z ; std::exception::exception

; 121  :     {

  00020	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
  0002c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 122  :     }

  0002f	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
??0bad_alloc@std@@QEAA@XZ ENDP				; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Message$ = 56
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 130  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 129  :         : exception(_Message, 1)

  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Message$[rsp]
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001e	e8 00 00 00 00	 call	 ??0exception@std@@QEAA@QEBDH@Z ; std::exception::exception

; 130  :     {

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
  0002f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 131  :     }

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UEAA@XZ
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 18 00 00 00	 mov	 edx, 24
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??1exception@std@@UEAA@XZ ; std::exception::~exception
  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 141  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 140  :         : bad_alloc("bad array new length")

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00010	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00015	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AEAA@QEBD@Z ; std::bad_alloc::bad_alloc

; 141  :     {

  0001a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  00026	48 89 08	 mov	 QWORD PTR [rax], rcx

; 142  :     }

  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UEAA@XZ
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 18 00 00 00	 mov	 edx, 24
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UEAA@XZ
  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 323  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN3:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 324  :     _THROW(bad_array_new_length{});

  00004	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QEAA@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
  00015	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0001a	e8 00 00 00 00	 call	 _CxxThrowException
$LN2@Throw_bad_:

; 325  : }

  0001f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00023	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR __that$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QEAA@AEBV01@@Z
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
  00029	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR __that$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ??0exception@std@@QEAA@AEBV01@@Z ; std::exception::exception
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
  00029	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 78   :         void* _Allocate(const size_t _Bytes) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 79   :         return ::operator new(_Bytes);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Bytes$[rsp]
  0000e	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 80   :     }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Back_shift$ = 32
_Ptr_container$ = 40
_Ptr_user$ = 48
_Min_back_shift$ = 56
_Ptr$ = 80
_Bytes$ = 88
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 147  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 148  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 149  :     _Bytes += _Non_user_size;

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR _Bytes$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 83 c0 27	 add	 rax, 39			; 00000027H
  0001a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Bytes$[rsp]
  0001f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 150  : 
; 151  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR _Ptr$[rsp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	48 89 44 24 30	 mov	 QWORD PTR _Ptr_user$[rsp], rax

; 152  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0002f	b8 08 00 00 00	 mov	 eax, 8
  00034	48 6b c0 ff	 imul	 rax, rax, -1
  00038	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Ptr_user$[rsp]
  0003d	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00041	48 89 44 24 28	 mov	 QWORD PTR _Ptr_container$[rsp], rax

; 153  : 
; 154  :     // If the following asserts, it likely means that we are performing
; 155  :     // an aligned delete on memory coming from an unaligned allocation.
; 156  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 157  : 
; 158  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 159  :     // in range [_Min_back_shift, _Non_user_size]
; 160  : #ifdef _DEBUG
; 161  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 162  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 163  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  00046	48 c7 44 24 38
	08 00 00 00	 mov	 QWORD PTR _Min_back_shift$[rsp], 8

; 164  : #endif // _DEBUG
; 165  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0004f	48 8b 44 24 50	 mov	 rax, QWORD PTR _Ptr$[rsp]
  00054	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Ptr_container$[rsp]
  00059	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005c	48 2b c1	 sub	 rax, rcx
  0005f	48 89 44 24 20	 mov	 QWORD PTR _Back_shift$[rsp], rax
$LN4@Adjust_man:

; 166  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00064	48 83 7c 24 20
	08		 cmp	 QWORD PTR _Back_shift$[rsp], 8
  0006a	72 0a		 jb	 SHORT $LN8@Adjust_man
  0006c	48 83 7c 24 20
	27		 cmp	 QWORD PTR _Back_shift$[rsp], 39 ; 00000027H
  00072	77 02		 ja	 SHORT $LN8@Adjust_man
  00074	eb 0c		 jmp	 SHORT $LN9@Adjust_man
$LN8@Adjust_man:
$LN7@Adjust_man:
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0007c	33 c0		 xor	 eax, eax
  0007e	85 c0		 test	 eax, eax
  00080	75 f4		 jne	 SHORT $LN7@Adjust_man
$LN9@Adjust_man:
  00082	33 c0		 xor	 eax, eax
  00084	85 c0		 test	 eax, eax
  00086	75 dc		 jne	 SHORT $LN4@Adjust_man

; 167  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00088	48 8b 44 24 50	 mov	 rax, QWORD PTR _Ptr$[rsp]
  0008d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Ptr_container$[rsp]
  00092	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN10@Adjust_man:

; 168  : }

  00095	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00099	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 1026 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT

; 1027 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	c3		 ret	 0
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1028 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	c3		 ret	 0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1294 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00014	c3		 ret	 0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1297 :     _CONSTEXPR20 void _Release() noexcept {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	c3		 ret	 0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2337 : [[noreturn]] inline void _Xlen_string() {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2338 :     _Xlength_error("string too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
$LN2@Xlen_strin:

; 2339 : }

  00011	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00015	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\Memory.h
;	COMDAT ?throw_std_bad_alloc@internal@Eigen@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?throw_std_bad_alloc@internal@Eigen@@YAXXZ PROC		; Eigen::internal::throw_std_bad_alloc, COMDAT

; 68   : {

$LN3:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 69   :   #ifdef EIGEN_EXCEPTIONS
; 70   :     throw std::bad_alloc();

  00004	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00009	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QEAA@XZ ; std::bad_alloc::bad_alloc
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI2?AVbad_alloc@std@@
  00015	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0001a	e8 00 00 00 00	 call	 _CxxThrowException
$LN2@throw_std_:

; 71   :   #else
; 72   :     std::size_t huge = static_cast<std::size_t>(-1);
; 73   :     #if defined(EIGEN_HIPCC)
; 74   :     //
; 75   :     // calls to "::operator new" are to be treated as opaque function calls (i.e no inlining),
; 76   :     // and as a consequence the code in the #else block triggers the hipcc warning :
; 77   :     // "no overloaded function has restriction specifiers that are compatible with the ambient context"
; 78   :     //
; 79   :     // "throw_std_bad_alloc" has the EIGEN_DEVICE_FUNC attribute, so it seems that hipcc expects
; 80   :     // the same on "operator new"
; 81   :     // Reverting code back to the old version in this #if block for the hipcc compiler
; 82   :     //
; 83   :     new int[huge];
; 84   :     #else
; 85   :     void* unused = ::operator new(huge);
; 86   :     EIGEN_UNUSED_VARIABLE(unused);
; 87   :     #endif
; 88   :   #endif
; 89   : }

  0001f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00023	c3		 ret	 0
?throw_std_bad_alloc@internal@Eigen@@YAXXZ ENDP		; Eigen::internal::throw_std_bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\Memory.h
;	COMDAT ?handmade_aligned_malloc@internal@Eigen@@YAPEAX_K0@Z
_TEXT	SEGMENT
original$ = 32
aligned$ = 40
size$ = 64
alignment$ = 72
?handmade_aligned_malloc@internal@Eigen@@YAPEAX_K0@Z PROC ; Eigen::internal::handmade_aligned_malloc, COMDAT

; 101  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 102  :   eigen_assert(alignment >= sizeof(void*) && (alignment & (alignment-1)) == 0 && "Alignment must be at least sizeof(void*) and a power of 2");

  0000e	48 83 7c 24 48
	08		 cmp	 QWORD PTR alignment$[rsp], 8
  00014	72 24		 jb	 SHORT $LN4@handmade_a
  00016	48 8b 44 24 48	 mov	 rax, QWORD PTR alignment$[rsp]
  0001b	48 ff c8	 dec	 rax
  0001e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR alignment$[rsp]
  00023	48 23 c8	 and	 rcx, rax
  00026	48 8b c1	 mov	 rax, rcx
  00029	48 85 c0	 test	 rax, rax
  0002c	75 0c		 jne	 SHORT $LN4@handmade_a
  0002e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DK@CKLHOJNA@Alignment?5must?5be?5at?5least?5size@
  00035	48 85 c0	 test	 rax, rax
  00038	75 1c		 jne	 SHORT $LN5@handmade_a
$LN4@handmade_a:
  0003a	41 b8 66 00 00
	00		 mov	 r8d, 102		; 00000066H
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1MG@ODDCIJJL@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1PM@EGIIFBMJ@?$AAa?$AAl?$AAi?$AAg?$AAn?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAi@
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00054	33 c0		 xor	 eax, eax
$LN5@handmade_a:

; 103  : 
; 104  :   EIGEN_USING_STD(malloc)
; 105  :   void *original = malloc(size+alignment);

  00056	48 8b 44 24 48	 mov	 rax, QWORD PTR alignment$[rsp]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR size$[rsp]
  00060	48 03 c8	 add	 rcx, rax
  00063	48 8b c1	 mov	 rax, rcx
  00066	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  0006d	48 0f 42 c1	 cmovb	 rax, rcx
  00071	48 8b c8	 mov	 rcx, rax
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0007a	48 89 44 24 20	 mov	 QWORD PTR original$[rsp], rax

; 106  :   
; 107  :   if (original == 0) return 0;

  0007f	48 83 7c 24 20
	00		 cmp	 QWORD PTR original$[rsp], 0
  00085	75 04		 jne	 SHORT $LN2@handmade_a
  00087	33 c0		 xor	 eax, eax
  00089	eb 33		 jmp	 SHORT $LN1@handmade_a
$LN2@handmade_a:

; 108  :   void *aligned = reinterpret_cast<void*>((reinterpret_cast<std::size_t>(original) & ~(std::size_t(alignment-1))) + alignment);

  0008b	48 8b 44 24 48	 mov	 rax, QWORD PTR alignment$[rsp]
  00090	48 ff c8	 dec	 rax
  00093	48 f7 d0	 not	 rax
  00096	48 8b 4c 24 20	 mov	 rcx, QWORD PTR original$[rsp]
  0009b	48 23 c8	 and	 rcx, rax
  0009e	48 8b c1	 mov	 rax, rcx
  000a1	48 03 44 24 48	 add	 rax, QWORD PTR alignment$[rsp]
  000a6	48 89 44 24 28	 mov	 QWORD PTR aligned$[rsp], rax

; 109  :   *(reinterpret_cast<void**>(aligned) - 1) = original;

  000ab	48 8b 44 24 28	 mov	 rax, QWORD PTR aligned$[rsp]
  000b0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR original$[rsp]
  000b5	48 89 48 f8	 mov	 QWORD PTR [rax-8], rcx

; 110  :   return aligned;

  000b9	48 8b 44 24 28	 mov	 rax, QWORD PTR aligned$[rsp]
$LN1@handmade_a:

; 111  : }

  000be	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c2	c3		 ret	 0
?handmade_aligned_malloc@internal@Eigen@@YAPEAX_K0@Z ENDP ; Eigen::internal::handmade_aligned_malloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\Memory.h
;	COMDAT ?handmade_aligned_free@internal@Eigen@@YAXPEAX@Z
_TEXT	SEGMENT
ptr$ = 48
?handmade_aligned_free@internal@Eigen@@YAXPEAX@Z PROC	; Eigen::internal::handmade_aligned_free, COMDAT

; 115  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 116  :   if (ptr) {

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  0000f	74 0f		 je	 SHORT $LN2@handmade_a

; 117  :     EIGEN_USING_STD(free)
; 118  :     free(*(reinterpret_cast<void**>(ptr) - 1));

  00011	48 8b 44 24 30	 mov	 rax, QWORD PTR ptr$[rsp]
  00016	48 8b 48 f8	 mov	 rcx, QWORD PTR [rax-8]
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@handmade_a:

; 119  :   }
; 120  : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
?handmade_aligned_free@internal@Eigen@@YAXPEAX@Z ENDP	; Eigen::internal::handmade_aligned_free
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\Memory.h
;	COMDAT ?check_that_malloc_is_allowed@internal@Eigen@@YAXXZ
_TEXT	SEGMENT
?check_that_malloc_is_allowed@internal@Eigen@@YAXXZ PROC ; Eigen::internal::check_that_malloc_is_allowed, COMDAT

; 168  : {}

  00000	c2 00 00	 ret	 0
?check_that_malloc_is_allowed@internal@Eigen@@YAXXZ ENDP ; Eigen::internal::check_that_malloc_is_allowed
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\Memory.h
;	COMDAT ?aligned_malloc@internal@Eigen@@YAPEAX_K@Z
_TEXT	SEGMENT
result$ = 32
size$ = 64
?aligned_malloc@internal@Eigen@@YAPEAX_K@Z PROC		; Eigen::internal::aligned_malloc, COMDAT

; 175  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 176  :   check_that_malloc_is_allowed();

  00009	e8 00 00 00 00	 call	 ?check_that_malloc_is_allowed@internal@Eigen@@YAXXZ ; Eigen::internal::check_that_malloc_is_allowed

; 177  : 
; 178  :   void *result;
; 179  :   #if (EIGEN_DEFAULT_ALIGN_BYTES==0) || EIGEN_MALLOC_ALREADY_ALIGNED
; 180  : 
; 181  :     EIGEN_USING_STD(malloc)
; 182  :     result = malloc(size);
; 183  : 
; 184  :     #if EIGEN_DEFAULT_ALIGN_BYTES==16
; 185  :     eigen_assert((size<16 || (std::size_t(result)%16)==0) && "System's malloc returned an unaligned pointer. Compile with EIGEN_MALLOC_ALREADY_ALIGNED=0 to fallback to handmade aligned memory allocator.");
; 186  :     #endif
; 187  :   #else
; 188  :     result = handmade_aligned_malloc(size);

  0000e	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR size$[rsp]
  00018	e8 00 00 00 00	 call	 ?handmade_aligned_malloc@internal@Eigen@@YAPEAX_K0@Z ; Eigen::internal::handmade_aligned_malloc
  0001d	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 189  :   #endif
; 190  : 
; 191  :   if(!result && size)

  00022	48 83 7c 24 20
	00		 cmp	 QWORD PTR result$[rsp], 0
  00028	75 0d		 jne	 SHORT $LN2@aligned_ma
  0002a	48 83 7c 24 40
	00		 cmp	 QWORD PTR size$[rsp], 0
  00030	74 05		 je	 SHORT $LN2@aligned_ma

; 192  :     throw_std_bad_alloc();

  00032	e8 00 00 00 00	 call	 ?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
$LN2@aligned_ma:

; 193  : 
; 194  :   return result;

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]

; 195  : }

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
?aligned_malloc@internal@Eigen@@YAPEAX_K@Z ENDP		; Eigen::internal::aligned_malloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\Memory.h
;	COMDAT ?aligned_free@internal@Eigen@@YAXPEAX@Z
_TEXT	SEGMENT
ptr$ = 48
?aligned_free@internal@Eigen@@YAXPEAX@Z PROC		; Eigen::internal::aligned_free, COMDAT

; 199  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 200  :   #if (EIGEN_DEFAULT_ALIGN_BYTES==0) || EIGEN_MALLOC_ALREADY_ALIGNED
; 201  : 
; 202  :     EIGEN_USING_STD(free)
; 203  :     free(ptr);
; 204  : 
; 205  :   #else
; 206  :     handmade_aligned_free(ptr);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$[rsp]
  0000e	e8 00 00 00 00	 call	 ?handmade_aligned_free@internal@Eigen@@YAXPEAX@Z ; Eigen::internal::handmade_aligned_free

; 207  :   #endif
; 208  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
?aligned_free@internal@Eigen@@YAXPEAX@Z ENDP		; Eigen::internal::aligned_free
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\arch\AVX\PacketMath.h
;	COMDAT ??$pload@U__m256d@@@internal@Eigen@@YA?AU__m256d@@PEBN@Z
_TEXT	SEGMENT
$T1 = 0
from$ = 80
??$pload@U__m256d@@@internal@Eigen@@YA?AU__m256d@@PEBN@Z PROC ; Eigen::internal::pload<__m256d>, COMDAT

; 578  : template<> EIGEN_STRONG_INLINE Packet4d pload<Packet4d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm256_load_pd(from); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 83 e5 e0	 and	 rbp, -32		; ffffffffffffffe0H
  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR from$[rsp]
  00018	c5 fd 10 00	 vmovupd ymm0, YMMWORD PTR [rax]
  0001c	c5 fd 11 45 00	 vmovupd YMMWORD PTR $T1[rbp], ymm0
  00021	c5 fd 10 45 00	 vmovupd ymm0, YMMWORD PTR $T1[rbp]
  00026	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0002a	5d		 pop	 rbp
  0002b	c3		 ret	 0
??$pload@U__m256d@@@internal@Eigen@@YA?AU__m256d@@PEBN@Z ENDP ; Eigen::internal::pload<__m256d>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\arch\AVX\PacketMath.h
;	COMDAT ??$ploadu@U__m256d@@@internal@Eigen@@YA?AU__m256d@@PEBN@Z
_TEXT	SEGMENT
$T1 = 0
from$ = 80
??$ploadu@U__m256d@@@internal@Eigen@@YA?AU__m256d@@PEBN@Z PROC ; Eigen::internal::ploadu<__m256d>, COMDAT

; 582  : template<> EIGEN_STRONG_INLINE Packet4d ploadu<Packet4d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm256_loadu_pd(from); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 83 e5 e0	 and	 rbp, -32		; ffffffffffffffe0H
  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR from$[rsp]
  00018	c5 fd 10 00	 vmovupd ymm0, YMMWORD PTR [rax]
  0001c	c5 fd 11 45 00	 vmovupd YMMWORD PTR $T1[rbp], ymm0
  00021	c5 fd 10 45 00	 vmovupd ymm0, YMMWORD PTR $T1[rbp]
  00026	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0002a	5d		 pop	 rbp
  0002b	c3		 ret	 0
??$ploadu@U__m256d@@@internal@Eigen@@YA?AU__m256d@@PEBN@Z ENDP ; Eigen::internal::ploadu<__m256d>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\arch\AVX\PacketMath.h
;	COMDAT ??$pstore@NU__m256d@@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z
_TEXT	SEGMENT
to$ = 8
from$ = 16
??$pstore@NU__m256d@@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z PROC ; Eigen::internal::pstore<double,__m256d>, COMDAT

; 623  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet4d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm256_store_pd(to, from); }

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR to$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR from$[rsp]
  00014	c5 fd 10 01	 vmovupd ymm0, YMMWORD PTR [rcx]
  00018	c5 fd 11 00	 vmovupd YMMWORD PTR [rax], ymm0
  0001c	c3		 ret	 0
??$pstore@NU__m256d@@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z ENDP ; Eigen::internal::pstore<double,__m256d>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\arch\AVX\PacketMath.h
;	COMDAT ??$pstoreu@NU__m256d@@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z
_TEXT	SEGMENT
to$ = 8
from$ = 16
??$pstoreu@NU__m256d@@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z PROC ; Eigen::internal::pstoreu<double,__m256d>, COMDAT

; 627  : template<> EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const Packet4d& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm256_storeu_pd(to, from); }

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR to$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR from$[rsp]
  00014	c5 fd 10 01	 vmovupd ymm0, YMMWORD PTR [rcx]
  00018	c5 fd 11 00	 vmovupd YMMWORD PTR [rax], ymm0
  0001c	c3		 ret	 0
??$pstoreu@NU__m256d@@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z ENDP ; Eigen::internal::pstoreu<double,__m256d>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
tv66 = 32
tv70 = 40
__t$ = 64
__s$ = 72
__n$ = 80
__f$ = 88
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN2@vector:
  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR __n$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR tv66[rsp], rax
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR __n$[rsp]
  00027	48 ff c8	 dec	 rax
  0002a	48 89 44 24 50	 mov	 QWORD PTR __n$[rsp], rax
  0002f	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv66[rsp], 0
  00035	76 2a		 jbe	 SHORT $LN3@vector
  00037	48 8b 44 24 58	 mov	 rax, QWORD PTR __f$[rsp]
  0003c	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  00041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __t$[rsp]
  00046	ff 54 24 28	 call	 QWORD PTR tv70[rsp]
  0004a	48 8b 44 24 48	 mov	 rax, QWORD PTR __s$[rsp]
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __t$[rsp]
  00054	48 03 c8	 add	 rcx, rax
  00057	48 8b c1	 mov	 rax, rcx
  0005a	48 89 44 24 40	 mov	 QWORD PTR __t$[rsp], rax
  0005f	eb b7		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\IndexedViewHelper.h
;	COMDAT ??__Elast@Eigen@@YAXXZ
text$di	SEGMENT
??__Elast@Eigen@@YAXXZ PROC				; Eigen::`dynamic initializer for 'last'', COMDAT

; 38   : static const symbolic::SymbolExpr<internal::symbolic_last_tag> last; // PLEASE use Eigen::last   instead of Eigen::placeholders::last

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?last@Eigen@@3V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@1@B
  0000b	e8 00 00 00 00	 call	 ??0?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@QEAA@XZ ; Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag>::SymbolExpr<Eigen::internal::symbolic_last_tag>
  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
??__Elast@Eigen@@YAXXZ ENDP				; Eigen::`dynamic initializer for 'last''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\IndexedViewHelper.h
;	COMDAT ??__Elastp1@Eigen@@YAXXZ
text$di	SEGMENT
$T1 = 32
??__Elastp1@Eigen@@YAXXZ PROC				; Eigen::`dynamic initializer for 'lastp1'', COMDAT

; 57   : static const symbolic::AddExpr<symbolic::SymbolExpr<internal::symbolic_last_tag>,symbolic::ValueExpr<Eigen::internal::FixedInt<1> > > lastp1(last+fix<1>());

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??$fix@$00@Eigen@@3V?$FixedInt@$00@internal@1@B
  00010	e8 00 00 00 00	 call	 ??R?$FixedInt@$00@internal@Eigen@@QEBA?AV012@XZ ; Eigen::internal::FixedInt<1>::operator()
  00015	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?lastp1@Eigen@@3V?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@symbolic@1@B
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?last@Eigen@@3V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@1@B
  00027	e8 00 00 00 00	 call	 ??$?H$00@?$BaseExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@@symbolic@Eigen@@QEBA?AV?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@12@V?$FixedInt@$00@internal@2@@Z ; Eigen::symbolic::BaseExpr<Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag> >::operator+<1>
  0002c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00030	c3		 ret	 0
??__Elastp1@Eigen@@YAXXZ ENDP				; Eigen::`dynamic initializer for 'lastp1''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\IndexedViewHelper.h
;	COMDAT ??0all_t@internal@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0all_t@internal@Eigen@@QEAA@XZ PROC			; Eigen::internal::all_t::all_t, COMDAT

; 137  : struct all_t { all_t() {} };

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
??0all_t@internal@Eigen@@QEAA@XZ ENDP			; Eigen::internal::all_t::all_t
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\IndexedViewHelper.h
;	COMDAT ??__Eall@Eigen@@YAXXZ
text$di	SEGMENT
??__Eall@Eigen@@YAXXZ PROC				; Eigen::`dynamic initializer for 'all'', COMDAT

; 171  : static const Eigen::internal::all_t all; // PLEASE use Eigen::all instead of Eigen::placeholders::all

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?all@Eigen@@3Uall_t@internal@1@B
  0000b	e8 00 00 00 00	 call	 ??0all_t@internal@Eigen@@QEAA@XZ ; Eigen::internal::all_t::all_t
  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
??__Eall@Eigen@@YAXXZ ENDP				; Eigen::`dynamic initializer for 'all''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\IndexedViewHelper.h
;	COMDAT ??__Eall@placeholders@Eigen@@YAXXZ
text$di	SEGMENT
??__Eall@placeholders@Eigen@@YAXXZ PROC			; Eigen::placeholders::`dynamic initializer for 'all'', COMDAT

; 179  :   EIGEN_DEPRECATED static const all_t  all  = Eigen::all;    // PLEASE use Eigen::all    instead of Eigen::placeholders::all

  00000	c2 00 00	 ret	 0
??__Eall@placeholders@Eigen@@YAXXZ ENDP			; Eigen::placeholders::`dynamic initializer for 'all''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\IndexedViewHelper.h
;	COMDAT ??__Elast@placeholders@Eigen@@YAXXZ
text$di	SEGMENT
??__Elast@placeholders@Eigen@@YAXXZ PROC		; Eigen::placeholders::`dynamic initializer for 'last'', COMDAT

; 180  :   EIGEN_DEPRECATED static const last_t last = Eigen::last;   // PLEASE use Eigen::last   instead of Eigen::placeholders::last

  00000	c2 00 00	 ret	 0
??__Elast@placeholders@Eigen@@YAXXZ ENDP		; Eigen::placeholders::`dynamic initializer for 'last''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\IndexedViewHelper.h
;	COMDAT ??__Eend@placeholders@Eigen@@YAXXZ
text$di	SEGMENT
??__Eend@placeholders@Eigen@@YAXXZ PROC			; Eigen::placeholders::`dynamic initializer for 'end'', COMDAT

; 181  :   EIGEN_DEPRECATED static const end_t  end  = Eigen::lastp1; // PLEASE use Eigen::lastp1 instead of Eigen::placeholders::end

  00000	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?lastp1@Eigen@@3V?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@symbolic@1@B
  00007	66 89 05 00 00
	00 00		 mov	 WORD PTR ?end@placeholders@Eigen@@3V?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@symbolic@2@B, ax
  0000e	c3		 ret	 0
??__Eend@placeholders@Eigen@@YAXXZ ENDP			; Eigen::placeholders::`dynamic initializer for 'end''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\IO.h
;	COMDAT ??0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z
_TEXT	SEGMENT
i$ = 32
tv69 = 40
tv77 = 48
tv85 = 56
tv93 = 64
tv133 = 72
tv141 = 80
tv149 = 88
tv170 = 96
this$ = 128
_precision$ = 136
_flags$ = 144
_coeffSeparator$ = 152
_rowSeparator$ = 160
_rowPrefix$ = 168
_rowSuffix$ = 176
_matPrefix$ = 184
_matSuffix$ = 192
_fill$ = 200
??0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z PROC ; Eigen::IOFormat::IOFormat, COMDAT

; 60   :   {

$LN13:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 58   :   : matPrefix(_matPrefix), matSuffix(_matSuffix), rowPrefix(_rowPrefix), rowSuffix(_rowSuffix), rowSeparator(_rowSeparator),

  00017	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0001f	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
  00024	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR _matPrefix$[rsp]
  0002c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv69[rsp]
  00031	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00036	90		 npad	 1
  00037	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0003f	48 83 c0 20	 add	 rax, 32			; 00000020H
  00043	48 89 44 24 30	 mov	 QWORD PTR tv77[rsp], rax
  00048	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR _matSuffix$[rsp]
  00050	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv77[rsp]
  00055	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0005a	90		 npad	 1
  0005b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00063	48 83 c0 40	 add	 rax, 64			; 00000040H
  00067	48 89 44 24 38	 mov	 QWORD PTR tv85[rsp], rax
  0006c	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR _rowPrefix$[rsp]
  00074	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv85[rsp]
  00079	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0007e	90		 npad	 1
  0007f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00087	48 83 c0 60	 add	 rax, 96			; 00000060H
  0008b	48 89 44 24 40	 mov	 QWORD PTR tv93[rsp], rax
  00090	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR _rowSuffix$[rsp]
  00098	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv93[rsp]
  0009d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000a2	90		 npad	 1
  000a3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000ab	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  000b1	48 89 44 24 48	 mov	 QWORD PTR tv133[rsp], rax
  000b6	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR _rowSeparator$[rsp]
  000be	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv133[rsp]
  000c3	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000c8	90		 npad	 1

; 59   :     rowSpacer(""), coeffSeparator(_coeffSeparator), fill(_fill), precision(_precision), flags(_flags)

  000c9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000d1	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  000d7	48 89 44 24 50	 mov	 QWORD PTR tv141[rsp], rax
  000dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
  000e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv141[rsp]
  000e8	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000ed	90		 npad	 1
  000ee	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000f6	48 05 c0 00 00
	00		 add	 rax, 192		; 000000c0H
  000fc	48 89 44 24 58	 mov	 QWORD PTR tv149[rsp], rax
  00101	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR _coeffSeparator$[rsp]
  00109	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv149[rsp]
  0010e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00113	90		 npad	 1
  00114	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0011c	0f b6 8c 24 c8
	00 00 00	 movzx	 ecx, BYTE PTR _fill$[rsp]
  00124	88 88 e0 00 00
	00		 mov	 BYTE PTR [rax+224], cl
  0012a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00132	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR _precision$[rsp]
  00139	89 88 e4 00 00
	00		 mov	 DWORD PTR [rax+228], ecx
  0013f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00147	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _flags$[rsp]
  0014e	89 88 e8 00 00
	00		 mov	 DWORD PTR [rax+232], ecx

; 61   :     // TODO check if rowPrefix, rowSuffix or rowSeparator contains a newline
; 62   :     // don't add rowSpacer if columns are not to be aligned
; 63   :     if((flags & DontAlignCols))

  00154	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0015c	8b 80 e8 00 00
	00		 mov	 eax, DWORD PTR [rax+232]
  00162	83 e0 01	 and	 eax, 1
  00165	85 c0		 test	 eax, eax
  00167	74 02		 je	 SHORT $LN4@IOFormat

; 64   :       return;

  00169	eb 70		 jmp	 SHORT $LN1@IOFormat
$LN4@IOFormat:

; 65   :     int i = int(matSuffix.length())-1;

  0016b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00173	48 83 c0 20	 add	 rax, 32			; 00000020H
  00177	48 8b c8	 mov	 rcx, rax
  0017a	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  0017f	ff c8		 dec	 eax
  00181	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN2@IOFormat:

; 66   :     while (i>=0 && matSuffix[i]!='\n')

  00185	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  0018a	7c 4f		 jl	 SHORT $LN1@IOFormat
  0018c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00194	48 83 c0 20	 add	 rax, 32			; 00000020H
  00198	48 89 44 24 60	 mov	 QWORD PTR tv170[rsp], rax
  0019d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001a2	48 8b d0	 mov	 rdx, rax
  001a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv170[rsp]
  001aa	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  001af	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001b2	83 f8 0a	 cmp	 eax, 10
  001b5	74 24		 je	 SHORT $LN1@IOFormat

; 67   :     {
; 68   :       rowSpacer += ' ';

  001b7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001bf	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  001c5	b2 20		 mov	 dl, 32			; 00000020H
  001c7	48 8b c8	 mov	 rcx, rax
  001ca	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 69   :       i--;

  001cf	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001d3	ff c8		 dec	 eax
  001d5	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 70   :     }

  001d9	eb aa		 jmp	 SHORT $LN2@IOFormat
$LN1@IOFormat:

; 71   :   }

  001db	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001e3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001e7	c3		 ret	 0
??0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z ENDP ; Eigen::IOFormat::IOFormat
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
tv69 = 40
tv77 = 48
tv85 = 56
tv93 = 64
tv133 = 72
tv141 = 80
tv149 = 88
tv170 = 96
this$ = 128
_precision$ = 136
_flags$ = 144
_coeffSeparator$ = 152
_rowSeparator$ = 160
_rowPrefix$ = 168
_rowSuffix$ = 176
_matPrefix$ = 184
_matSuffix$ = 192
_fill$ = 200
?dtor$0@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA PROC ; `Eigen::IOFormat::IOFormat'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$0@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA ENDP ; `Eigen::IOFormat::IOFormat'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
tv69 = 40
tv77 = 48
tv85 = 56
tv93 = 64
tv133 = 72
tv141 = 80
tv149 = 88
tv170 = 96
this$ = 128
_precision$ = 136
_flags$ = 144
_coeffSeparator$ = 152
_rowSeparator$ = 160
_rowPrefix$ = 168
_rowSuffix$ = 176
_matPrefix$ = 184
_matSuffix$ = 192
_fill$ = 200
?dtor$1@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA PROC ; `Eigen::IOFormat::IOFormat'::`1'::dtor$1
  0001b	40 55		 push	 rbp
  0001d	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00021	48 8b ea	 mov	 rbp, rdx
  00024	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0002b	48 83 c1 20	 add	 rcx, 32			; 00000020H
  0002f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
?dtor$1@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA ENDP ; `Eigen::IOFormat::IOFormat'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
tv69 = 40
tv77 = 48
tv85 = 56
tv93 = 64
tv133 = 72
tv141 = 80
tv149 = 88
tv170 = 96
this$ = 128
_precision$ = 136
_flags$ = 144
_coeffSeparator$ = 152
_rowSeparator$ = 160
_rowPrefix$ = 168
_rowSuffix$ = 176
_matPrefix$ = 184
_matSuffix$ = 192
_fill$ = 200
?dtor$2@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA PROC ; `Eigen::IOFormat::IOFormat'::`1'::dtor$2
  0003a	40 55		 push	 rbp
  0003c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00040	48 8b ea	 mov	 rbp, rdx
  00043	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004a	48 83 c1 40	 add	 rcx, 64			; 00000040H
  0004e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5d		 pop	 rbp
  00058	c3		 ret	 0
?dtor$2@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA ENDP ; `Eigen::IOFormat::IOFormat'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
tv69 = 40
tv77 = 48
tv85 = 56
tv93 = 64
tv133 = 72
tv141 = 80
tv149 = 88
tv170 = 96
this$ = 128
_precision$ = 136
_flags$ = 144
_coeffSeparator$ = 152
_rowSeparator$ = 160
_rowPrefix$ = 168
_rowSuffix$ = 176
_matPrefix$ = 184
_matSuffix$ = 192
_fill$ = 200
?dtor$3@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA PROC ; `Eigen::IOFormat::IOFormat'::`1'::dtor$3
  00059	40 55		 push	 rbp
  0005b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0005f	48 8b ea	 mov	 rbp, rdx
  00062	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00069	48 83 c1 60	 add	 rcx, 96			; 00000060H
  0006d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00072	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00076	5d		 pop	 rbp
  00077	c3		 ret	 0
?dtor$3@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA ENDP ; `Eigen::IOFormat::IOFormat'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
tv69 = 40
tv77 = 48
tv85 = 56
tv93 = 64
tv133 = 72
tv141 = 80
tv149 = 88
tv170 = 96
this$ = 128
_precision$ = 136
_flags$ = 144
_coeffSeparator$ = 152
_rowSeparator$ = 160
_rowPrefix$ = 168
_rowSuffix$ = 176
_matPrefix$ = 184
_matSuffix$ = 192
_fill$ = 200
?dtor$4@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA PROC ; `Eigen::IOFormat::IOFormat'::`1'::dtor$4
  00078	40 55		 push	 rbp
  0007a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0007e	48 8b ea	 mov	 rbp, rdx
  00081	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00088	48 81 c1 80 00
	00 00		 add	 rcx, 128		; 00000080H
  0008f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00094	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00098	5d		 pop	 rbp
  00099	c3		 ret	 0
?dtor$4@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA ENDP ; `Eigen::IOFormat::IOFormat'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
tv69 = 40
tv77 = 48
tv85 = 56
tv93 = 64
tv133 = 72
tv141 = 80
tv149 = 88
tv170 = 96
this$ = 128
_precision$ = 136
_flags$ = 144
_coeffSeparator$ = 152
_rowSeparator$ = 160
_rowPrefix$ = 168
_rowSuffix$ = 176
_matPrefix$ = 184
_matSuffix$ = 192
_fill$ = 200
?dtor$5@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA PROC ; `Eigen::IOFormat::IOFormat'::`1'::dtor$5
  0009a	40 55		 push	 rbp
  0009c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000a0	48 8b ea	 mov	 rbp, rdx
  000a3	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000aa	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  000b1	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000b6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ba	5d		 pop	 rbp
  000bb	c3		 ret	 0
?dtor$5@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA ENDP ; `Eigen::IOFormat::IOFormat'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
tv69 = 40
tv77 = 48
tv85 = 56
tv93 = 64
tv133 = 72
tv141 = 80
tv149 = 88
tv170 = 96
this$ = 128
_precision$ = 136
_flags$ = 144
_coeffSeparator$ = 152
_rowSeparator$ = 160
_rowPrefix$ = 168
_rowSuffix$ = 176
_matPrefix$ = 184
_matSuffix$ = 192
_fill$ = 200
?dtor$6@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA PROC ; `Eigen::IOFormat::IOFormat'::`1'::dtor$6
  000bc	40 55		 push	 rbp
  000be	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000c2	48 8b ea	 mov	 rbp, rdx
  000c5	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000cc	48 81 c1 c0 00
	00 00		 add	 rcx, 192		; 000000c0H
  000d3	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000d8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000dc	5d		 pop	 rbp
  000dd	c3		 ret	 0
?dtor$6@?0???0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z@4HA ENDP ; `Eigen::IOFormat::IOFormat'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\src\mnist.hpp
;	COMDAT ?get_data@Data_Set@Mnist@@UEAA?AV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@_K@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
index$ = 64
?get_data@Data_Set@Mnist@@UEAA?AV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@_K@Z PROC ; Mnist::Data_Set::get_data, COMDAT

; 11   : 		inline Eigen::Matrix<double, 28, 28>	get_data(uint64_t index)	override { return data[index]; }

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00013	48 69 44 24 40
	80 18 00 00	 imul	 rax, QWORD PTR index$[rsp], 6272 ; 00001880H
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00021	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00025	48 8b d0	 mov	 rdx, rax
  00028	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  0002d	e8 00 00 00 00	 call	 ??0?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEAA@AEBV01@@Z ; Eigen::Matrix<double,28,28,0,28,28>::Matrix<double,28,28,0,28,28>
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
?get_data@Data_Set@Mnist@@UEAA?AV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@_K@Z ENDP ; Mnist::Data_Set::get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\src\mnist.hpp
;	COMDAT ?get_label@Data_Set@Mnist@@UEAAC_K@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
?get_label@Data_Set@Mnist@@UEAAC_K@Z PROC		; Mnist::Data_Set::get_label, COMDAT

; 12   : 		inline int8_t							get_label(uint64_t index)	override { return labels[index]; }

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00013	48 8b 4c 24 10	 mov	 rcx, QWORD PTR index$[rsp]
  00018	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0001c	c3		 ret	 0
?get_label@Data_Set@Mnist@@UEAAC_K@Z ENDP		; Mnist::Data_Set::get_label
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\src\main.cpp
;	COMDAT main
_TEXT	SEGMENT
i$8 = 0
j$9 = 4
index$10 = 8
data_count$ = 12
tv218 = 16
$T7 = 20
$T1 = 24
tv166 = 40
tv195 = 48
tv207 = 56
tv220 = 64
$T3 = 80
$T6 = 96
$T2 = 120
$T4 = 160
$T5 = 6432
res$11 = 12704
dat$ = 12720
net$ = 12752
__$ArrayPad$ = 12784
argc$ = 12896
argv$ = 12904
main	PROC						; COMDAT

; 12   : int main(int argc, char** argv) {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	55		 push	 rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	b8 40 32 00 00	 mov	 eax, 12864		; 00003240H
  00011	e8 00 00 00 00	 call	 __chkstk
  00016	48 2b e0	 sub	 rsp, rax
  00019	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  0001e	48 83 e5 e0	 and	 rbp, -32		; ffffffffffffffe0H
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 85 f0 31
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 13   : 	Math::init_random();  // set seed using random device (random device is wayyy to slow to work continuosly)

  00033	e8 00 00 00 00	 call	 ?init_random@Math@@YAXXZ ; Math::init_random

; 14   : 
; 15   : 	// 784 => 16 => 16 => 10
; 16   : 	Neural::Network net(784, { 16, 16 }, 10);

  00038	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0003d	48 8d 8d d0 31
	00 00		 lea	 rcx, QWORD PTR net$[rbp]
  00044	e8 00 00 00 00	 call	 ?__autoclassinit2@Network@Neural@@QEAAX_K@Z
  00049	c7 45 18 10 00
	00 00		 mov	 DWORD PTR $T1[rbp], 16
  00050	c7 45 1c 10 00
	00 00		 mov	 DWORD PTR $T1[rbp+4], 16
  00057	48 8d 45 20	 lea	 rax, QWORD PTR $T1[rbp+8]
  0005b	4c 8b c0	 mov	 r8, rax
  0005e	48 8d 55 18	 lea	 rdx, QWORD PTR $T1[rbp]
  00062	48 8d 4d 78	 lea	 rcx, QWORD PTR $T2[rbp]
  00066	e8 00 00 00 00	 call	 ??0?$initializer_list@I@std@@QEAA@PEBI0@Z ; std::initializer_list<unsigned int>::initializer_list<unsigned int>
  0006b	48 8d 4d 50	 lea	 rcx, QWORD PTR $T3[rbp]
  0006f	48 8b f9	 mov	 rdi, rcx
  00072	48 8b f0	 mov	 rsi, rax
  00075	b9 10 00 00 00	 mov	 ecx, 16
  0007a	f3 a4		 rep movsb
  0007c	41 b9 0a 00 00
	00		 mov	 r9d, 10
  00082	4c 8d 45 50	 lea	 r8, QWORD PTR $T3[rbp]
  00086	ba 10 03 00 00	 mov	 edx, 784		; 00000310H
  0008b	48 8d 8d d0 31
	00 00		 lea	 rcx, QWORD PTR net$[rbp]
  00092	e8 00 00 00 00	 call	 ??0Network@Neural@@QEAA@IV?$initializer_list@I@std@@I@Z ; Neural::Network::Network
  00097	90		 npad	 1

; 17   : 	net.init_network();  // init with random wieghts and biasses for now

  00098	48 8d 8d d0 31
	00 00		 lea	 rcx, QWORD PTR net$[rbp]
  0009f	e8 00 00 00 00	 call	 ?init_network@Network@Neural@@QEAAXXZ ; Neural::Network::init_network

; 18   : 
; 19   : 	uint16_t data_count = 200;

  000a4	b8 c8 00 00 00	 mov	 eax, 200		; 000000c8H
  000a9	66 89 45 0c	 mov	 WORD PTR data_count$[rbp], ax

; 20   : 	Mnist::Data_Set dat("dat/test_labels.idx1-ubyte", "dat/test_images.idx3-ubyte", data_count);

  000ad	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000b2	48 8d 8d b0 31
	00 00		 lea	 rcx, QWORD PTR dat$[rbp]
  000b9	e8 00 00 00 00	 call	 ?__autoclassinit2@Data_Set@Mnist@@QEAAX_K@Z
  000be	0f b7 45 0c	 movzx	 eax, WORD PTR data_count$[rbp]
  000c2	44 8b c8	 mov	 r9d, eax
  000c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294967164
  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294967163
  000d3	48 8d 8d b0 31
	00 00		 lea	 rcx, QWORD PTR dat$[rbp]
  000da	e8 00 00 00 00	 call	 ??0Data_Set@Mnist@@QEAA@PEBD0_K@Z ; Mnist::Data_Set::Data_Set
  000df	90		 npad	 1

; 21   : 	for (uint8_t i = 0; i < data_count; i++) {

  000e0	c6 45 00 00	 mov	 BYTE PTR i$8[rbp], 0
  000e4	eb 09		 jmp	 SHORT $LN4@main
$LN2@main:
  000e6	0f b6 45 00	 movzx	 eax, BYTE PTR i$8[rbp]
  000ea	fe c0		 inc	 al
  000ec	88 45 00	 mov	 BYTE PTR i$8[rbp], al
$LN4@main:
  000ef	0f b6 45 00	 movzx	 eax, BYTE PTR i$8[rbp]
  000f3	0f b7 4d 0c	 movzx	 ecx, WORD PTR data_count$[rbp]
  000f7	3b c1		 cmp	 eax, ecx
  000f9	0f 8d b6 01 00
	00		 jge	 $LN3@main

; 22   : 		Mnist::print_mnist_data(dat.get_data(i));

  000ff	0f b6 45 00	 movzx	 eax, BYTE PTR i$8[rbp]
  00103	44 8b c0	 mov	 r8d, eax
  00106	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR $T4[rbp]
  0010d	48 8d 8d b0 31
	00 00		 lea	 rcx, QWORD PTR dat$[rbp]
  00114	e8 00 00 00 00	 call	 ?get_data@Data_Set@Mnist@@UEAA?AV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@_K@Z ; Mnist::Data_Set::get_data
  00119	48 8b c8	 mov	 rcx, rax
  0011c	e8 00 00 00 00	 call	 ?print_mnist_data@Mnist@@YAXAEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Z ; Mnist::print_mnist_data

; 23   : 		auto res = net.calculate(dat.get_data(i));

  00121	ba 10 00 00 00	 mov	 edx, 16
  00126	48 8d 8d a0 31
	00 00		 lea	 rcx, QWORD PTR res$11[rbp]
  0012d	e8 00 00 00 00	 call	 ?__autoclassinit2@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEAAX_K@Z
  00132	0f b6 45 00	 movzx	 eax, BYTE PTR i$8[rbp]
  00136	44 8b c0	 mov	 r8d, eax
  00139	48 8d 95 20 19
	00 00		 lea	 rdx, QWORD PTR $T5[rbp]
  00140	48 8d 8d b0 31
	00 00		 lea	 rcx, QWORD PTR dat$[rbp]
  00147	e8 00 00 00 00	 call	 ?get_data@Data_Set@Mnist@@UEAA?AV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@_K@Z ; Mnist::Data_Set::get_data
  0014c	48 8b d0	 mov	 rdx, rax
  0014f	48 8d 4d 60	 lea	 rcx, QWORD PTR $T6[rbp]
  00153	e8 00 00 00 00	 call	 ??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBU?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z ; Eigen::Matrix<double,-1,-1,0,-1,-1>::Matrix<double,-1,-1,0,-1,-1><Eigen::Matrix<double,28,28,0,28,28> >
  00158	90		 npad	 1
  00159	4c 8d 45 60	 lea	 r8, QWORD PTR $T6[rbp]
  0015d	48 8d 95 a0 31
	00 00		 lea	 rdx, QWORD PTR res$11[rbp]
  00164	48 8d 8d d0 31
	00 00		 lea	 rcx, QWORD PTR net$[rbp]
  0016b	e8 00 00 00 00	 call	 ?calculate@Network@Neural@@QEAA?AV?$Matrix@N$00$0?0$00$00$0?0@Eigen@@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@4@@Z ; Neural::Network::calculate
  00170	90		 npad	 1
  00171	48 8d 4d 60	 lea	 rcx, QWORD PTR $T6[rbp]
  00175	e8 00 00 00 00	 call	 ??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ

; 24   : 		uint16_t index = 0;  // find max

  0017a	33 c0		 xor	 eax, eax
  0017c	66 89 45 08	 mov	 WORD PTR index$10[rbp], ax

; 25   : 		std::cout << res << "\n";

  00180	48 8d 95 a0 31
	00 00		 lea	 rdx, QWORD PTR res$11[rbp]
  00187	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0018e	e8 00 00 00 00	 call	 ??$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z ; Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >
  00193	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294967162
  0019a	48 8b c8	 mov	 rcx, rax
  0019d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 26   : 		for (uint16_t j = 0; j < 10; j++) { if (res[j] > res[index]) { res[index] = res[j];  index = j; } }

  001a2	33 c0		 xor	 eax, eax
  001a4	66 89 45 04	 mov	 WORD PTR j$9[rbp], ax
  001a8	eb 0b		 jmp	 SHORT $LN7@main
$LN5@main:
  001aa	0f b7 45 04	 movzx	 eax, WORD PTR j$9[rbp]
  001ae	66 ff c0	 inc	 ax
  001b1	66 89 45 04	 mov	 WORD PTR j$9[rbp], ax
$LN7@main:
  001b5	0f b7 45 04	 movzx	 eax, WORD PTR j$9[rbp]
  001b9	83 f8 0a	 cmp	 eax, 10
  001bc	7d 79		 jge	 SHORT $LN6@main
  001be	0f b7 45 04	 movzx	 eax, WORD PTR j$9[rbp]
  001c2	8b d0		 mov	 edx, eax
  001c4	48 8d 8d a0 31
	00 00		 lea	 rcx, QWORD PTR res$11[rbp]
  001cb	e8 00 00 00 00	 call	 ??A?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,1,-1,1,1,-1>,1>::operator[]
  001d0	48 89 45 28	 mov	 QWORD PTR tv166[rbp], rax
  001d4	0f b7 4d 08	 movzx	 ecx, WORD PTR index$10[rbp]
  001d8	8b d1		 mov	 edx, ecx
  001da	48 8d 8d a0 31
	00 00		 lea	 rcx, QWORD PTR res$11[rbp]
  001e1	e8 00 00 00 00	 call	 ??A?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,1,-1,1,1,-1>,1>::operator[]
  001e6	48 8b 4d 28	 mov	 rcx, QWORD PTR tv166[rbp]
  001ea	c5 fb 10 01	 vmovsd	 xmm0, QWORD PTR [rcx]
  001ee	c5 f9 2f 00	 vcomisd xmm0, QWORD PTR [rax]
  001f2	76 3e		 jbe	 SHORT $LN8@main
  001f4	0f b7 45 04	 movzx	 eax, WORD PTR j$9[rbp]
  001f8	8b d0		 mov	 edx, eax
  001fa	48 8d 8d a0 31
	00 00		 lea	 rcx, QWORD PTR res$11[rbp]
  00201	e8 00 00 00 00	 call	 ??A?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,1,-1,1,1,-1>,1>::operator[]
  00206	c5 fb 10 00	 vmovsd	 xmm0, QWORD PTR [rax]
  0020a	c5 fb 11 45 30	 vmovsd	 QWORD PTR tv195[rbp], xmm0
  0020f	0f b7 45 08	 movzx	 eax, WORD PTR index$10[rbp]
  00213	8b d0		 mov	 edx, eax
  00215	48 8d 8d a0 31
	00 00		 lea	 rcx, QWORD PTR res$11[rbp]
  0021c	e8 00 00 00 00	 call	 ??A?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,1,-1,1,1,-1>,1>::operator[]
  00221	c5 fb 10 45 30	 vmovsd	 xmm0, QWORD PTR tv195[rbp]
  00226	c5 fb 11 00	 vmovsd	 QWORD PTR [rax], xmm0
  0022a	0f b7 45 04	 movzx	 eax, WORD PTR j$9[rbp]
  0022e	66 89 45 08	 mov	 WORD PTR index$10[rbp], ax
$LN8@main:
  00232	e9 73 ff ff ff	 jmp	 $LN5@main
$LN6@main:

; 27   : 		std::cout << "calc: " << index << "\t\tans: " << (int)dat.get_label(i) << "\n";

  00237	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294967159
  0023e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00245	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0024a	48 89 45 38	 mov	 QWORD PTR tv207[rbp], rax
  0024e	0f b7 55 08	 movzx	 edx, WORD PTR index$10[rbp]
  00252	48 8b 4d 38	 mov	 rcx, QWORD PTR tv207[rbp]
  00256	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  0025c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294967160
  00263	48 8b c8	 mov	 rcx, rax
  00266	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0026b	48 89 45 40	 mov	 QWORD PTR tv220[rbp], rax
  0026f	0f b6 45 00	 movzx	 eax, BYTE PTR i$8[rbp]
  00273	8b d0		 mov	 edx, eax
  00275	48 8d 8d b0 31
	00 00		 lea	 rcx, QWORD PTR dat$[rbp]
  0027c	e8 00 00 00 00	 call	 ?get_label@Data_Set@Mnist@@UEAAC_K@Z ; Mnist::Data_Set::get_label
  00281	0f be c0	 movsx	 eax, al
  00284	89 45 10	 mov	 DWORD PTR tv218[rbp], eax
  00287	8b 55 10	 mov	 edx, DWORD PTR tv218[rbp]
  0028a	48 8b 4d 40	 mov	 rcx, QWORD PTR tv220[rbp]
  0028e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  00294	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294967161
  0029b	48 8b c8	 mov	 rcx, rax
  0029e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002a3	90		 npad	 1

; 28   : 	}

  002a4	48 8d 8d a0 31
	00 00		 lea	 rcx, QWORD PTR res$11[rbp]
  002ab	e8 00 00 00 00	 call	 ??1?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEAA@XZ
  002b0	e9 31 fe ff ff	 jmp	 $LN2@main
$LN3@main:

; 29   : 
; 30   : 	// programm cant exit propperly due to eigen matrecies that are still allocated
; 31   : 	return 0;

  002b5	c7 45 14 00 00
	00 00		 mov	 DWORD PTR $T7[rbp], 0
  002bc	48 8d 8d b0 31
	00 00		 lea	 rcx, QWORD PTR dat$[rbp]
  002c3	e8 00 00 00 00	 call	 ??1Data_Set@Mnist@@QEAA@XZ
  002c8	90		 npad	 1
  002c9	48 8d 8d d0 31
	00 00		 lea	 rcx, QWORD PTR net$[rbp]
  002d0	e8 00 00 00 00	 call	 ??1Network@Neural@@QEAA@XZ ; Neural::Network::~Network
  002d5	8b 45 14	 mov	 eax, DWORD PTR $T7[rbp]

; 32   : }

  002d8	48 8b 8d f0 31
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  002df	48 33 cc	 xor	 rcx, rsp
  002e2	e8 00 00 00 00	 call	 __security_check_cookie
  002e7	48 81 c4 40 32
	00 00		 add	 rsp, 12864		; 00003240H
  002ee	5f		 pop	 rdi
  002ef	5e		 pop	 rsi
  002f0	5d		 pop	 rbp
  002f1	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$8 = 0
j$9 = 4
index$10 = 8
data_count$ = 12
tv218 = 16
$T7 = 20
$T1 = 24
tv166 = 40
tv195 = 48
tv207 = 56
tv220 = 64
$T3 = 80
$T6 = 96
$T2 = 120
$T4 = 160
$T5 = 6432
res$11 = 12704
dat$ = 12720
net$ = 12752
__$ArrayPad$ = 12784
argc$ = 12896
argv$ = 12904
main$dtor$0 PROC
  00000	40 55		 push	 rbp
  00002	41 55		 push	 r13
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00008	4c 8b ea	 mov	 r13, rdx
  0000b	48 8d 6a 40	 lea	 rbp, QWORD PTR [rdx+64]
  0000f	48 83 e5 e0	 and	 rbp, -32		; ffffffffffffffe0H
  00013	48 8d 8d d0 31
	00 00		 lea	 rcx, QWORD PTR net$[rbp]
  0001a	e8 00 00 00 00	 call	 ??1Network@Neural@@QEAA@XZ ; Neural::Network::~Network
  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	41 5d		 pop	 r13
  00025	5d		 pop	 rbp
  00026	c3		 ret	 0
main$dtor$0 ENDP
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$8 = 0
j$9 = 4
index$10 = 8
data_count$ = 12
tv218 = 16
$T7 = 20
$T1 = 24
tv166 = 40
tv195 = 48
tv207 = 56
tv220 = 64
$T3 = 80
$T6 = 96
$T2 = 120
$T4 = 160
$T5 = 6432
res$11 = 12704
dat$ = 12720
net$ = 12752
__$ArrayPad$ = 12784
argc$ = 12896
argv$ = 12904
main$dtor$1 PROC
  00027	40 55		 push	 rbp
  00029	41 55		 push	 r13
  0002b	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0002f	4c 8b ea	 mov	 r13, rdx
  00032	48 8d 6a 40	 lea	 rbp, QWORD PTR [rdx+64]
  00036	48 83 e5 e0	 and	 rbp, -32		; ffffffffffffffe0H
  0003a	48 8d 8d b0 31
	00 00		 lea	 rcx, QWORD PTR dat$[rbp]
  00041	e8 00 00 00 00	 call	 ??1Data_Set@Mnist@@QEAA@XZ
  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	41 5d		 pop	 r13
  0004c	5d		 pop	 rbp
  0004d	c3		 ret	 0
main$dtor$1 ENDP
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$8 = 0
j$9 = 4
index$10 = 8
data_count$ = 12
tv218 = 16
$T7 = 20
$T1 = 24
tv166 = 40
tv195 = 48
tv207 = 56
tv220 = 64
$T3 = 80
$T6 = 96
$T2 = 120
$T4 = 160
$T5 = 6432
res$11 = 12704
dat$ = 12720
net$ = 12752
__$ArrayPad$ = 12784
argc$ = 12896
argv$ = 12904
main$dtor$2 PROC
  0004e	40 55		 push	 rbp
  00050	41 55		 push	 r13
  00052	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00056	4c 8b ea	 mov	 r13, rdx
  00059	48 8d 6a 40	 lea	 rbp, QWORD PTR [rdx+64]
  0005d	48 83 e5 e0	 and	 rbp, -32		; ffffffffffffffe0H
  00061	48 8d 4d 60	 lea	 rcx, QWORD PTR $T6[rbp]
  00065	e8 00 00 00 00	 call	 ??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ
  0006a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006e	41 5d		 pop	 r13
  00070	5d		 pop	 rbp
  00071	c3		 ret	 0
main$dtor$2 ENDP
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$8 = 0
j$9 = 4
index$10 = 8
data_count$ = 12
tv218 = 16
$T7 = 20
$T1 = 24
tv166 = 40
tv195 = 48
tv207 = 56
tv220 = 64
$T3 = 80
$T6 = 96
$T2 = 120
$T4 = 160
$T5 = 6432
res$11 = 12704
dat$ = 12720
net$ = 12752
__$ArrayPad$ = 12784
argc$ = 12896
argv$ = 12904
main$dtor$3 PROC
  00072	40 55		 push	 rbp
  00074	41 55		 push	 r13
  00076	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0007a	4c 8b ea	 mov	 r13, rdx
  0007d	48 8d 6a 40	 lea	 rbp, QWORD PTR [rdx+64]
  00081	48 83 e5 e0	 and	 rbp, -32		; ffffffffffffffe0H
  00085	48 8d 8d a0 31
	00 00		 lea	 rcx, QWORD PTR res$11[rbp]
  0008c	e8 00 00 00 00	 call	 ??1?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEAA@XZ
  00091	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00095	41 5d		 pop	 r13
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
main$dtor$3 ENDP
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@Network@Neural@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@Network@Neural@@QEAAX_K@Z PROC	; Neural::Network::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@Network@Neural@@QEAAX_K@Z ENDP	; Neural::Network::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1Data_Set@Mnist@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1Data_Set@Mnist@@QEAA@XZ PROC				; Mnist::Data_Set::~Data_Set, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??1?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@QEAA@XZ ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::~Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >
  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1Data_Set@Mnist@@QEAA@XZ ENDP				; Mnist::Data_Set::~Data_Set
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@Data_Set@Mnist@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@Data_Set@Mnist@@QEAAX_K@Z PROC	; Mnist::Data_Set::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@Data_Set@Mnist@@QEAAX_K@Z ENDP	; Mnist::Data_Set::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ PROC	; Eigen::Matrix<double,-1,-1,0,-1,-1>::~Matrix<double,-1,-1,0,-1,-1>, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??1?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA@XZ
  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ ENDP	; Eigen::Matrix<double,-1,-1,0,-1,-1>::~Matrix<double,-1,-1,0,-1,-1>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA@XZ PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::~PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ??1?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ ; Eigen::DenseStorage<double,-1,-1,-1,0>::~DenseStorage<double,-1,-1,-1,0>
  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
??1?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA@XZ ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::~PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEAA@XZ PROC	; Eigen::Matrix<double,1,-1,1,1,-1>::~Matrix<double,1,-1,1,1,-1>, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??1?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEAA@XZ
  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEAA@XZ ENDP	; Eigen::Matrix<double,1,-1,1,1,-1>::~Matrix<double,1,-1,1,1,-1>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEAA@XZ PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::~PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ??1?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEAA@XZ ; Eigen::DenseStorage<double,-1,1,-1,1>::~DenseStorage<double,-1,1,-1,1>
  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
??1?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEAA@XZ ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::~PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEAAX_K@Z PROC ; Eigen::Matrix<double,1,-1,1,1,-1>::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEAAX_K@Z ENDP ; Eigen::Matrix<double,1,-1,1,1,-1>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseStorage.h
;	COMDAT ??1?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEAA@XZ PROC	; Eigen::DenseStorage<double,-1,1,-1,1>::~DenseStorage<double,-1,1,-1,1>, COMDAT

; 545  :     EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Rows*m_cols); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00017	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0001a	e8 00 00 00 00	 call	 ??$conditional_aligned_delete_auto@N$00@internal@Eigen@@YAXPEAN_K@Z ; Eigen::internal::conditional_aligned_delete_auto<double,1>
  0001f	90		 npad	 1
  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
??1?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEAA@XZ ENDP	; Eigen::DenseStorage<double,-1,1,-1,1>::~DenseStorage<double,-1,1,-1,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseCoeffsBase.h
;	COMDAT ??A?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z
_TEXT	SEGMENT
this$ = 48
index$ = 56
??A?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,1,-1,1,1,-1>,1>::operator[], COMDAT

; 407  :     {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 408  :       EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
; 409  :                           THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD)
; 410  :       eigen_assert(index >= 0 && index < size());

  0000e	48 83 7c 24 38
	00		 cmp	 QWORD PTR index$[rsp], 0
  00014	7c 11		 jl	 SHORT $LN3@operator
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001b	e8 00 00 00 00	 call	 ?size@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::size
  00020	48 39 44 24 38	 cmp	 QWORD PTR index$[rsp], rax
  00025	7c 1c		 jl	 SHORT $LN4@operator
$LN3@operator:
  00027	41 b8 9a 01 00
	00		 mov	 r8d, 410		; 0000019aH
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1MO@MNMFCLKA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00041	33 c0		 xor	 eax, eax
$LN4@operator:

; 411  :       return coeffRef(index);

  00043	48 8b 54 24 38	 mov	 rdx, QWORD PTR index$[rsp]
  00048	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0004d	e8 00 00 00 00	 call	 ?coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,1,-1,1,1,-1>,1>::coeffRef

; 412  :     }

  00052	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00056	c3		 ret	 0
??A?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,1,-1,1,1,-1>,1>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseStorage.h
;	COMDAT ??1?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ PROC	; Eigen::DenseStorage<double,-1,-1,-1,0>::~DenseStorage<double,-1,-1,-1,0>, COMDAT

; 465  :     EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00013	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00017	48 0f af 41 10	 imul	 rax, QWORD PTR [rcx+16]
  0001c	48 8b d0	 mov	 rdx, rax
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00024	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00027	e8 00 00 00 00	 call	 ??$conditional_aligned_delete_auto@N$00@internal@Eigen@@YAXPEAN_K@Z ; Eigen::internal::conditional_aligned_delete_auto<double,1>
  0002c	90		 npad	 1
  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
??1?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ ENDP	; Eigen::DenseStorage<double,-1,-1,-1,0>::~DenseStorage<double,-1,-1,-1,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\initializer_list
;	COMDAT ??0?$initializer_list@I@std@@QEAA@PEBI0@Z
_TEXT	SEGMENT
this$ = 8
_First_arg$ = 16
_Last_arg$ = 24
??0?$initializer_list@I@std@@QEAA@PEBI0@Z PROC		; std::initializer_list<unsigned int>::initializer_list<unsigned int>, COMDAT

; 35   :         : _First(_First_arg), _Last(_Last_arg) {}

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00014	48 8b 4c 24 10	 mov	 rcx, QWORD PTR _First_arg$[rsp]
  00019	48 89 08	 mov	 QWORD PTR [rax], rcx
  0001c	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 8b 4c 24 18	 mov	 rcx, QWORD PTR _Last_arg$[rsp]
  00026	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0002a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0002f	c3		 ret	 0
??0?$initializer_list@I@std@@QEAA@PEBI0@Z ENDP		; std::initializer_list<unsigned int>::initializer_list<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\Matrix.h
;	COMDAT ??0?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??0?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEAA@AEBV01@@Z PROC ; Eigen::Matrix<double,28,28,0,28,28>::Matrix<double,28,28,0,28,28>, COMDAT

; 415  :     { }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 414  :     EIGEN_STRONG_INLINE Matrix(const Matrix& other) : Base(other)

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR other$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ??0?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@AEBV01@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >

; 415  :     { }

  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
??0?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEAA@AEBV01@@Z ENDP ; Eigen::Matrix<double,28,28,0,28,28>::Matrix<double,28,28,0,28,28>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\src\neural_network.hpp
;	COMDAT ?get_label@?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@UEAAC_K@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
?get_label@?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@UEAAC_K@Z PROC ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::get_label, COMDAT

; 25   : 		inline virtual label_type	get_label(uint64_t index)	{ return labels[index]; }

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00013	48 8b 4c 24 10	 mov	 rcx, QWORD PTR index$[rsp]
  00018	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0001c	c3		 ret	 0
?get_label@?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@UEAAC_K@Z ENDP ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::get_label
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\src\neural_network.hpp
;	COMDAT ?get_data@?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@UEAA?AV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@_K@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
index$ = 64
?get_data@?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@UEAA?AV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@_K@Z PROC ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::get_data, COMDAT

; 24   : 		inline virtual data_type	get_data(uint64_t index)	{ return data[index]; }

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00013	48 69 44 24 40
	80 18 00 00	 imul	 rax, QWORD PTR index$[rsp], 6272 ; 00001880H
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00021	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00025	48 8b d0	 mov	 rdx, rax
  00028	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  0002d	e8 00 00 00 00	 call	 ??0?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEAA@AEBV01@@Z ; Eigen::Matrix<double,28,28,0,28,28>::Matrix<double,28,28,0,28,28>
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
?get_data@?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@UEAA?AV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@_K@Z ENDP ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\src\neural_network.hpp
;	COMDAT ??1?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
??1?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@QEAA@XZ PROC ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::~Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >, COMDAT

; 19   : 		~Data() {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@6B@
  00015	48 89 08	 mov	 QWORD PTR [rax], rcx

; 20   : 			if (labels != nullptr)	{ delete[] labels; }

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00022	74 18		 je	 SHORT $LN2@Data
  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00029	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002d	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00032	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00037	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
$LN2@Data:

; 21   : 			if (data != nullptr)	{ delete[] data; }

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00041	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00046	74 1d		 je	 SHORT $LN3@Data
  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0004d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00051	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  00056	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0005b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T2[rsp]
  00060	e8 00 00 00 00	 call	 ??_V@YAXPEAXW4align_val_t@std@@@Z ; operator delete[]
$LN3@Data:

; 22   : 		}

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
??1?$Data@CV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Neural@@QEAA@XZ ENDP ; Neural::Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >::~Data<signed char,Eigen::Matrix<double,28,28,0,28,28> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\sstream
;	COMDAT ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
_Pptr_old$ = 32
_Seeklow$ = 40
_Off$ = 48
tv81 = 56
_Gptr_old$ = 64
_Newptr$ = 72
_Seekdist$ = 80
this$ = 112
__$ReturnUdt$ = 120
_Pos$ = 128
_Mode$ = 136
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos, COMDAT

; 391  :     pos_type seekpos(pos_type _Pos, ios_base::openmode _Mode = ios_base::in | ios_base::out) override {

$LN12:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 392  :         // change position to _Pos, according to _Mode
; 393  :         const auto _Off      = static_cast<streamoff>(_Pos);

  00018	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Pos$[rsp]
  00020	e8 00 00 00 00	 call	 ??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ; std::fpos<_Mbstatet>::operator __int64
  00025	48 89 44 24 30	 mov	 QWORD PTR _Off$[rsp], rax

; 394  :         const auto _Gptr_old = _Mysb::gptr();

  0002a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00035	48 89 44 24 40	 mov	 QWORD PTR _Gptr_old$[rsp], rax

; 395  :         const auto _Pptr_old = (_Mystate & _Constant) ? nullptr : _Mysb::pptr();

  0003a	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0003f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00042	83 e0 02	 and	 eax, 2
  00045	85 c0		 test	 eax, eax
  00047	74 0b		 je	 SHORT $LN10@seekpos
  00049	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv81[rsp], 0
  00052	eb 10		 jmp	 SHORT $LN11@seekpos
$LN10@seekpos:
  00054	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0005f	48 89 44 24 38	 mov	 QWORD PTR tv81[rsp], rax
$LN11@seekpos:
  00064	48 8b 44 24 38	 mov	 rax, QWORD PTR tv81[rsp]
  00069	48 89 44 24 20	 mov	 QWORD PTR _Pptr_old$[rsp], rax

; 396  :         if (_Pptr_old && _Seekhigh < _Pptr_old) { // update high-water pointer

  0006e	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Pptr_old$[rsp], 0
  00074	74 1e		 je	 SHORT $LN2@seekpos
  00076	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0007b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Pptr_old$[rsp]
  00080	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00084	73 0e		 jae	 SHORT $LN2@seekpos

; 397  :             _Seekhigh = _Pptr_old;

  00086	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0008b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Pptr_old$[rsp]
  00090	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN2@seekpos:

; 398  :         }
; 399  : 
; 400  :         const auto _Seeklow  = _Mysb::eback();

  00094	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0009f	48 89 44 24 28	 mov	 QWORD PTR _Seeklow$[rsp], rax

; 401  :         const auto _Seekdist = _Seekhigh - _Seeklow;

  000a4	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  000a9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Seeklow$[rsp]
  000ae	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b2	48 2b c1	 sub	 rax, rcx
  000b5	48 89 44 24 50	 mov	 QWORD PTR _Seekdist$[rsp], rax

; 402  :         if (static_cast<unsigned long long>(_Off) > static_cast<unsigned long long>(_Seekdist)) {

  000ba	48 8b 44 24 50	 mov	 rax, QWORD PTR _Seekdist$[rsp]
  000bf	48 39 44 24 30	 cmp	 QWORD PTR _Off$[rsp], rax
  000c4	76 1b		 jbe	 SHORT $LN3@seekpos

; 403  :             return pos_type(off_type(-1));

  000c6	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  000cd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  000d2	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  000d7	48 8b 44 24 78	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  000dc	e9 e5 00 00 00	 jmp	 $LN1@seekpos
$LN3@seekpos:

; 404  :         }
; 405  : 
; 406  :         if (_Off != 0 && (((_Mode & ios_base::in) && !_Gptr_old) || ((_Mode & ios_base::out) && !_Pptr_old))) {

  000e1	48 83 7c 24 30
	00		 cmp	 QWORD PTR _Off$[rsp], 0
  000e7	74 47		 je	 SHORT $LN4@seekpos
  000e9	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  000f0	83 e0 01	 and	 eax, 1
  000f3	85 c0		 test	 eax, eax
  000f5	74 08		 je	 SHORT $LN6@seekpos
  000f7	48 83 7c 24 40
	00		 cmp	 QWORD PTR _Gptr_old$[rsp], 0
  000fd	74 16		 je	 SHORT $LN5@seekpos
$LN6@seekpos:
  000ff	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  00106	83 e0 02	 and	 eax, 2
  00109	85 c0		 test	 eax, eax
  0010b	74 23		 je	 SHORT $LN4@seekpos
  0010d	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Pptr_old$[rsp], 0
  00113	75 1b		 jne	 SHORT $LN4@seekpos
$LN5@seekpos:

; 407  :             return pos_type(off_type(-1));

  00115	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  0011c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00121	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  00126	48 8b 44 24 78	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  0012b	e9 96 00 00 00	 jmp	 $LN1@seekpos
$LN4@seekpos:

; 408  :         }
; 409  : 
; 410  :         const auto _Newptr = _Seeklow + _Off; // may perform nullptr + 0

  00130	48 8b 44 24 30	 mov	 rax, QWORD PTR _Off$[rsp]
  00135	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Seeklow$[rsp]
  0013a	48 03 c8	 add	 rcx, rax
  0013d	48 8b c1	 mov	 rax, rcx
  00140	48 89 44 24 48	 mov	 QWORD PTR _Newptr$[rsp], rax

; 411  :         if ((_Mode & ios_base::in) && _Gptr_old) {

  00145	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  0014c	83 e0 01	 and	 eax, 1
  0014f	85 c0		 test	 eax, eax
  00151	74 26		 je	 SHORT $LN7@seekpos
  00153	48 83 7c 24 40
	00		 cmp	 QWORD PTR _Gptr_old$[rsp], 0
  00159	74 1e		 je	 SHORT $LN7@seekpos

; 412  :             _Mysb::setg(_Seeklow, _Newptr, _Seekhigh);

  0015b	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  00160	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  00164	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Newptr$[rsp]
  00169	48 8b 54 24 28	 mov	 rdx, QWORD PTR _Seeklow$[rsp]
  0016e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00173	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
$LN7@seekpos:

; 413  :         }
; 414  : 
; 415  :         if ((_Mode & ios_base::out) && _Pptr_old) {

  00179	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  00180	83 e0 02	 and	 eax, 2
  00183	85 c0		 test	 eax, eax
  00185	74 2b		 je	 SHORT $LN8@seekpos
  00187	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Pptr_old$[rsp], 0
  0018d	74 23		 je	 SHORT $LN8@seekpos

; 416  :             _Mysb::setp(_Seeklow, _Newptr, _Mysb::epptr());

  0018f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0019a	4c 8b c8	 mov	 r9, rax
  0019d	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Newptr$[rsp]
  001a2	48 8b 54 24 28	 mov	 rdx, QWORD PTR _Seeklow$[rsp]
  001a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  001ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
$LN8@seekpos:

; 417  :         }
; 418  : 
; 419  :         return pos_type(_Off);

  001b2	48 8b 54 24 30	 mov	 rdx, QWORD PTR _Off$[rsp]
  001b7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  001bc	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  001c1	48 8b 44 24 78	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@seekpos:

; 420  :     }

  001c6	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001ca	c3		 ret	 0
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\sstream
;	COMDAT ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
_Seeklow$ = 32
tv92 = 40
_Pptr_old$ = 48
_Newoff$ = 56
_Gptr_old$ = 64
tv79 = 72
_Seekdist$ = 80
_Newptr$ = 88
_Both$1 = 96
this$ = 128
__$ReturnUdt$ = 136
_Off$ = 144
_Way$ = 152
_Mode$ = 160
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff, COMDAT

; 330  :         off_type _Off, ios_base::seekdir _Way, ios_base::openmode _Mode = ios_base::in | ios_base::out) override {

$LN25:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 331  :         // change position by _Off, according to _Way, _Mode
; 332  :         const auto _Gptr_old = _Mysb::gptr();

  00018	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00026	48 89 44 24 40	 mov	 QWORD PTR _Gptr_old$[rsp], rax

; 333  :         const auto _Pptr_old = (_Mystate & _Constant) ? nullptr : _Mysb::pptr();

  0002b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00033	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00036	83 e0 02	 and	 eax, 2
  00039	85 c0		 test	 eax, eax
  0003b	74 0b		 je	 SHORT $LN23@seekoff
  0003d	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv79[rsp], 0
  00046	eb 13		 jmp	 SHORT $LN24@seekoff
$LN23@seekoff:
  00048	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00056	48 89 44 24 48	 mov	 QWORD PTR tv79[rsp], rax
$LN24@seekoff:
  0005b	48 8b 44 24 48	 mov	 rax, QWORD PTR tv79[rsp]
  00060	48 89 44 24 30	 mov	 QWORD PTR _Pptr_old$[rsp], rax

; 334  :         if (_Pptr_old && _Seekhigh < _Pptr_old) { // update high-water pointer

  00065	48 83 7c 24 30
	00		 cmp	 QWORD PTR _Pptr_old$[rsp], 0
  0006b	74 24		 je	 SHORT $LN4@seekoff
  0006d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00075	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Pptr_old$[rsp]
  0007a	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  0007e	73 11		 jae	 SHORT $LN4@seekoff

; 335  :             _Seekhigh = _Pptr_old;

  00080	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00088	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Pptr_old$[rsp]
  0008d	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN4@seekoff:

; 336  :         }
; 337  : 
; 338  :         const auto _Seeklow  = _Mysb::eback();

  00091	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0009f	48 89 44 24 20	 mov	 QWORD PTR _Seeklow$[rsp], rax

; 339  :         const auto _Seekdist = _Seekhigh - _Seeklow;

  000a4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000ac	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Seeklow$[rsp]
  000b1	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b5	48 2b c1	 sub	 rax, rcx
  000b8	48 89 44 24 50	 mov	 QWORD PTR _Seekdist$[rsp], rax

; 340  :         off_type _Newoff;
; 341  :         switch (_Way) {

  000bd	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR _Way$[rsp]
  000c4	89 44 24 28	 mov	 DWORD PTR tv92[rsp], eax
  000c8	83 7c 24 28 00	 cmp	 DWORD PTR tv92[rsp], 0
  000cd	74 13		 je	 SHORT $LN5@seekoff
  000cf	83 7c 24 28 01	 cmp	 DWORD PTR tv92[rsp], 1
  000d4	74 29		 je	 SHORT $LN7@seekoff
  000d6	83 7c 24 28 02	 cmp	 DWORD PTR tv92[rsp], 2
  000db	74 13		 je	 SHORT $LN6@seekoff
  000dd	e9 a0 00 00 00	 jmp	 $LN15@seekoff
$LN5@seekoff:

; 342  :         case ios_base::beg:
; 343  :             _Newoff = 0;

  000e2	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _Newoff$[rsp], 0

; 344  :             break;

  000eb	e9 b3 00 00 00	 jmp	 $LN2@seekoff
$LN6@seekoff:

; 345  :         case ios_base::end:
; 346  :             _Newoff = _Seekdist;

  000f0	48 8b 44 24 50	 mov	 rax, QWORD PTR _Seekdist$[rsp]
  000f5	48 89 44 24 38	 mov	 QWORD PTR _Newoff$[rsp], rax

; 347  :             break;

  000fa	e9 a4 00 00 00	 jmp	 $LN2@seekoff
$LN7@seekoff:

; 348  :         case ios_base::cur:
; 349  :             {
; 350  :                 constexpr auto _Both = ios_base::in | ios_base::out;

  000ff	c7 44 24 60 03
	00 00 00	 mov	 DWORD PTR _Both$1[rsp], 3

; 351  :                 if ((_Mode & _Both)
; 352  :                     != _Both) { // prohibited by N4727 [stringbuf.virtuals] Table 107 "seekoff positioning"

  00107	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  0010e	83 e0 03	 and	 eax, 3
  00111	83 f8 03	 cmp	 eax, 3
  00114	74 6c		 je	 SHORT $LN8@seekoff

; 353  :                     if (_Mode & ios_base::in) {

  00116	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  0011d	83 e0 01	 and	 eax, 1
  00120	85 c0		 test	 eax, eax
  00122	74 29		 je	 SHORT $LN9@seekoff

; 354  :                         if (_Gptr_old || !_Seeklow) {

  00124	48 83 7c 24 40
	00		 cmp	 QWORD PTR _Gptr_old$[rsp], 0
  0012a	75 08		 jne	 SHORT $LN12@seekoff
  0012c	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Seeklow$[rsp], 0
  00132	75 17		 jne	 SHORT $LN11@seekoff
$LN12@seekoff:

; 355  :                             _Newoff = _Gptr_old - _Seeklow;

  00134	48 8b 44 24 20	 mov	 rax, QWORD PTR _Seeklow$[rsp]
  00139	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Gptr_old$[rsp]
  0013e	48 2b c8	 sub	 rcx, rax
  00141	48 8b c1	 mov	 rax, rcx
  00144	48 89 44 24 38	 mov	 QWORD PTR _Newoff$[rsp], rax

; 356  :                             break;

  00149	eb 58		 jmp	 SHORT $LN2@seekoff
$LN11@seekoff:

; 357  :                         }

  0014b	eb 35		 jmp	 SHORT $LN10@seekoff
$LN9@seekoff:

; 358  :                     } else if ((_Mode & ios_base::out) && (_Pptr_old || !_Seeklow)) {

  0014d	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  00154	83 e0 02	 and	 eax, 2
  00157	85 c0		 test	 eax, eax
  00159	74 27		 je	 SHORT $LN13@seekoff
  0015b	48 83 7c 24 30
	00		 cmp	 QWORD PTR _Pptr_old$[rsp], 0
  00161	75 08		 jne	 SHORT $LN14@seekoff
  00163	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Seeklow$[rsp], 0
  00169	75 17		 jne	 SHORT $LN13@seekoff
$LN14@seekoff:

; 359  :                         _Newoff = _Pptr_old - _Seeklow;

  0016b	48 8b 44 24 20	 mov	 rax, QWORD PTR _Seeklow$[rsp]
  00170	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Pptr_old$[rsp]
  00175	48 2b c8	 sub	 rcx, rax
  00178	48 8b c1	 mov	 rax, rcx
  0017b	48 89 44 24 38	 mov	 QWORD PTR _Newoff$[rsp], rax

; 360  :                         break;

  00180	eb 21		 jmp	 SHORT $LN2@seekoff
$LN13@seekoff:
$LN10@seekoff:
$LN8@seekoff:
$LN15@seekoff:

; 361  :                     }
; 362  :                 }
; 363  :             }
; 364  : 
; 365  :             // fallthrough
; 366  :         default:
; 367  :             return pos_type(off_type(-1));

  00182	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00189	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00191	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  00196	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  0019e	e9 5c 01 00 00	 jmp	 $LN1@seekoff
$LN2@seekoff:

; 368  :         }
; 369  : 
; 370  :         if (static_cast<unsigned long long>(_Off) + _Newoff > static_cast<unsigned long long>(_Seekdist)) {

  001a3	48 8b 44 24 38	 mov	 rax, QWORD PTR _Newoff$[rsp]
  001a8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _Off$[rsp]
  001b0	48 03 c8	 add	 rcx, rax
  001b3	48 8b c1	 mov	 rax, rcx
  001b6	48 3b 44 24 50	 cmp	 rax, QWORD PTR _Seekdist$[rsp]
  001bb	76 21		 jbe	 SHORT $LN16@seekoff

; 371  :             return pos_type(off_type(-1));

  001bd	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  001c4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  001cc	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  001d1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  001d9	e9 21 01 00 00	 jmp	 $LN1@seekoff
$LN16@seekoff:

; 372  :         }
; 373  : 
; 374  :         _Off += _Newoff;

  001de	48 8b 44 24 38	 mov	 rax, QWORD PTR _Newoff$[rsp]
  001e3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _Off$[rsp]
  001eb	48 03 c8	 add	 rcx, rax
  001ee	48 8b c1	 mov	 rax, rcx
  001f1	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR _Off$[rsp], rax

; 375  :         if (_Off != 0 && (((_Mode & ios_base::in) && !_Gptr_old) || ((_Mode & ios_base::out) && !_Pptr_old))) {

  001f9	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR _Off$[rsp], 0
  00202	74 4d		 je	 SHORT $LN17@seekoff
  00204	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  0020b	83 e0 01	 and	 eax, 1
  0020e	85 c0		 test	 eax, eax
  00210	74 08		 je	 SHORT $LN19@seekoff
  00212	48 83 7c 24 40
	00		 cmp	 QWORD PTR _Gptr_old$[rsp], 0
  00218	74 16		 je	 SHORT $LN18@seekoff
$LN19@seekoff:
  0021a	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  00221	83 e0 02	 and	 eax, 2
  00224	85 c0		 test	 eax, eax
  00226	74 29		 je	 SHORT $LN17@seekoff
  00228	48 83 7c 24 30
	00		 cmp	 QWORD PTR _Pptr_old$[rsp], 0
  0022e	75 21		 jne	 SHORT $LN17@seekoff
$LN18@seekoff:

; 376  :             return pos_type(off_type(-1));

  00230	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00237	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  0023f	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  00244	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  0024c	e9 ae 00 00 00	 jmp	 $LN1@seekoff
$LN17@seekoff:

; 377  :         }
; 378  : 
; 379  :         const auto _Newptr = _Seeklow + _Off; // may perform nullptr + 0

  00251	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR _Off$[rsp]
  00259	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Seeklow$[rsp]
  0025e	48 03 c8	 add	 rcx, rax
  00261	48 8b c1	 mov	 rax, rcx
  00264	48 89 44 24 58	 mov	 QWORD PTR _Newptr$[rsp], rax

; 380  :         if ((_Mode & ios_base::in) && _Gptr_old) {

  00269	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  00270	83 e0 01	 and	 eax, 1
  00273	85 c0		 test	 eax, eax
  00275	74 2c		 je	 SHORT $LN20@seekoff
  00277	48 83 7c 24 40
	00		 cmp	 QWORD PTR _Gptr_old$[rsp], 0
  0027d	74 24		 je	 SHORT $LN20@seekoff

; 381  :             _Mysb::setg(_Seeklow, _Newptr, _Seekhigh);

  0027f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00287	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  0028b	4c 8b 44 24 58	 mov	 r8, QWORD PTR _Newptr$[rsp]
  00290	48 8b 54 24 20	 mov	 rdx, QWORD PTR _Seeklow$[rsp]
  00295	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
$LN20@seekoff:

; 382  :         }
; 383  : 
; 384  :         if ((_Mode & ios_base::out) && _Pptr_old) {

  002a3	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _Mode$[rsp]
  002aa	83 e0 02	 and	 eax, 2
  002ad	85 c0		 test	 eax, eax
  002af	74 31		 je	 SHORT $LN21@seekoff
  002b1	48 83 7c 24 30
	00		 cmp	 QWORD PTR _Pptr_old$[rsp], 0
  002b7	74 29		 je	 SHORT $LN21@seekoff

; 385  :             _Mysb::setp(_Seeklow, _Newptr, _Mysb::epptr());

  002b9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  002c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  002c7	4c 8b c8	 mov	 r9, rax
  002ca	4c 8b 44 24 58	 mov	 r8, QWORD PTR _Newptr$[rsp]
  002cf	48 8b 54 24 20	 mov	 rdx, QWORD PTR _Seeklow$[rsp]
  002d4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  002dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
$LN21@seekoff:

; 386  :         }
; 387  : 
; 388  :         return pos_type(_Off);

  002e2	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR _Off$[rsp]
  002ea	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  002f2	e8 00 00 00 00	 call	 ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
  002f7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@seekoff:

; 389  :     }

  002ff	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00303	c3		 ret	 0
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\sstream
;	COMDAT ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ
_TEXT	SEGMENT
_Gptr$ = 32
_Local_highwater$ = 40
tv154 = 48
tv152 = 56
_Pptr$ = 64
__$ArrayPad$ = 72
this$ = 96
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow, COMDAT

; 303  :     int_type underflow() override { // get an element from stream, but don't point past it

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 304  :         const auto _Gptr = _Mysb::gptr();

  00018	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00023	48 89 44 24 20	 mov	 QWORD PTR _Gptr$[rsp], rax

; 305  :         if (!_Gptr) { // no character buffer, fail

  00028	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Gptr$[rsp], 0
  0002e	75 0a		 jne	 SHORT $LN2@underflow

; 306  :             return _Traits::eof();

  00030	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00035	e9 de 00 00 00	 jmp	 $LN1@underflow
$LN2@underflow:

; 307  :         }
; 308  : 
; 309  :         if (_Gptr < _Mysb::egptr()) {

  0003a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00045	48 39 44 24 20	 cmp	 QWORD PTR _Gptr$[rsp], rax
  0004a	73 0f		 jae	 SHORT $LN3@underflow

; 310  :             return _Traits::to_int_type(*_Gptr);

  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Gptr$[rsp]
  00051	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  00056	e9 bd 00 00 00	 jmp	 $LN1@underflow
$LN3@underflow:

; 311  :         }
; 312  : 
; 313  :         // try to add initialized characters from the put area into the get area
; 314  :         const auto _Pptr = _Mysb::pptr();

  0005b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00066	48 89 44 24 40	 mov	 QWORD PTR _Pptr$[rsp], rax

; 315  :         if (!_Pptr || (_Mystate & _Noread)) { // no put area or read disallowed

  0006b	48 83 7c 24 40
	00		 cmp	 QWORD PTR _Pptr$[rsp], 0
  00071	74 0f		 je	 SHORT $LN5@underflow
  00073	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00078	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0007b	83 e0 04	 and	 eax, 4
  0007e	85 c0		 test	 eax, eax
  00080	74 0a		 je	 SHORT $LN4@underflow
$LN5@underflow:

; 316  :             return _Traits::eof();

  00082	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00087	e9 8c 00 00 00	 jmp	 $LN1@underflow
$LN4@underflow:

; 317  :         }
; 318  : 
; 319  :         const auto _Local_highwater = (_STD max)(_Seekhigh, _Pptr);

  0008c	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00091	48 83 c0 68	 add	 rax, 104		; 00000068H
  00095	48 8d 54 24 40	 lea	 rdx, QWORD PTR _Pptr$[rsp]
  0009a	48 8b c8	 mov	 rcx, rax
  0009d	e8 00 00 00 00	 call	 ??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z ; std::max<char *>
  000a2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a5	48 89 44 24 28	 mov	 QWORD PTR _Local_highwater$[rsp], rax

; 320  :         if (_Local_highwater <= _Gptr) { // nothing in the put area to take

  000aa	48 8b 44 24 20	 mov	 rax, QWORD PTR _Gptr$[rsp]
  000af	48 39 44 24 28	 cmp	 QWORD PTR _Local_highwater$[rsp], rax
  000b4	77 07		 ja	 SHORT $LN6@underflow

; 321  :             return _Traits::eof();

  000b6	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  000bb	eb 5b		 jmp	 SHORT $LN1@underflow
$LN6@underflow:

; 322  :         }
; 323  : 
; 324  :         _Seekhigh = _Local_highwater;

  000bd	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000c2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Local_highwater$[rsp]
  000c7	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 325  :         _Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Local_highwater);

  000cb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  000d6	48 89 44 24 30	 mov	 QWORD PTR tv154[rsp], rax
  000db	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  000e6	48 89 44 24 38	 mov	 QWORD PTR tv152[rsp], rax
  000eb	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _Local_highwater$[rsp]
  000f0	4c 8b 44 24 30	 mov	 r8, QWORD PTR tv154[rsp]
  000f5	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv152[rsp]
  000fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z

; 326  :         return _Traits::to_int_type(*_Mysb::gptr());

  00105	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00110	48 8b c8	 mov	 rcx, rax
  00113	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
$LN1@underflow:

; 327  :     }

  00118	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0011d	48 33 cc	 xor	 rcx, rsp
  00120	e8 00 00 00 00	 call	 __security_check_cookie
  00125	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00129	c3		 ret	 0
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\sstream
;	COMDAT ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
_TEXT	SEGMENT
$T2 = 32
tv150 = 33
$T1 = 36
$T3 = 40
_Gptr$ = 48
this$ = 80
_Meta$ = 88
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail, COMDAT

; 286  :     int_type pbackfail(int_type _Meta = _Traits::eof()) override { // put an element back to stream

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 287  :         const auto _Gptr = _Mysb::gptr();

  0000d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00018	48 89 44 24 30	 mov	 QWORD PTR _Gptr$[rsp], rax

; 288  :         if (!_Gptr || _Gptr <= _Mysb::eback()
; 289  :             || (!_Traits::eq_int_type(_Traits::eof(), _Meta) && !_Traits::eq(_Traits::to_char_type(_Meta), _Gptr[-1])

  0001d	48 83 7c 24 30
	00		 cmp	 QWORD PTR _Gptr$[rsp], 0
  00023	74 76		 je	 SHORT $LN3@pbackfail
  00025	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00030	48 39 44 24 30	 cmp	 QWORD PTR _Gptr$[rsp], rax
  00035	76 64		 jbe	 SHORT $LN3@pbackfail
  00037	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0003c	89 44 24 24	 mov	 DWORD PTR $T1[rsp], eax
  00040	48 8d 54 24 58	 lea	 rdx, QWORD PTR _Meta$[rsp]
  00045	48 8d 4c 24 24	 lea	 rcx, QWORD PTR $T1[rsp]
  0004a	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  0004f	0f b6 c0	 movzx	 eax, al
  00052	85 c0		 test	 eax, eax
  00054	75 4c		 jne	 SHORT $LN2@pbackfail
  00056	48 8d 4c 24 58	 lea	 rcx, QWORD PTR _Meta$[rsp]
  0005b	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  00060	88 44 24 20	 mov	 BYTE PTR $T2[rsp], al
  00064	b8 01 00 00 00	 mov	 eax, 1
  00069	48 6b c0 ff	 imul	 rax, rax, -1
  0006d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Gptr$[rsp]
  00072	48 03 c8	 add	 rcx, rax
  00075	48 8b c1	 mov	 rax, rcx
  00078	48 8b d0	 mov	 rdx, rax
  0007b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T2[rsp]
  00080	e8 00 00 00 00	 call	 ?eq@?$_Narrow_char_traits@DH@std@@SA_NAEBD0@Z ; std::_Narrow_char_traits<char,int>::eq
  00085	0f b6 c0	 movzx	 eax, al
  00088	85 c0		 test	 eax, eax
  0008a	75 16		 jne	 SHORT $LN2@pbackfail
  0008c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00091	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00094	83 e0 02	 and	 eax, 2
  00097	85 c0		 test	 eax, eax
  00099	74 07		 je	 SHORT $LN2@pbackfail
$LN3@pbackfail:

; 290  :                 && (_Mystate & _Constant))) { // can't put back, fail
; 291  :             return _Traits::eof();

  0009b	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  000a0	eb 59		 jmp	 SHORT $LN1@pbackfail
$LN2@pbackfail:

; 292  :         }
; 293  : 
; 294  :         // back up one position and store put-back character
; 295  :         _Mysb::gbump(-1);

  000a2	ba ff ff ff ff	 mov	 edx, -1
  000a7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z

; 296  :         if (!_Traits::eq_int_type(_Traits::eof(), _Meta)) {

  000b2	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  000b7	89 44 24 28	 mov	 DWORD PTR $T3[rsp], eax
  000bb	48 8d 54 24 58	 lea	 rdx, QWORD PTR _Meta$[rsp]
  000c0	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T3[rsp]
  000c5	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  000ca	0f b6 c0	 movzx	 eax, al
  000cd	85 c0		 test	 eax, eax
  000cf	75 20		 jne	 SHORT $LN4@pbackfail

; 297  :             *_Mysb::gptr() = _Traits::to_char_type(_Meta);

  000d1	48 8d 4c 24 58	 lea	 rcx, QWORD PTR _Meta$[rsp]
  000d6	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  000db	88 44 24 21	 mov	 BYTE PTR tv150[rsp], al
  000df	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  000ea	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR tv150[rsp]
  000ef	88 08		 mov	 BYTE PTR [rax], cl
$LN4@pbackfail:

; 298  :         }
; 299  : 
; 300  :         return _Traits::not_eof(_Meta);

  000f1	48 8d 4c 24 58	 lea	 rcx, QWORD PTR _Meta$[rsp]
  000f6	e8 00 00 00 00	 call	 ?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z ; std::_Narrow_char_traits<char,int>::not_eof
$LN1@pbackfail:

; 301  :     }

  000fb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ff	c3		 ret	 0
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\sstream
;	COMDAT ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
_TEXT	SEGMENT
tv131 = 32
tv228 = 33
_Newptr$ = 40
_Oldsize$ = 48
_Pptr$ = 56
_Newsize$ = 64
_Oldptr$ = 72
$T1 = 80
_Epptr$ = 88
_New_pnext$ = 96
tv155 = 104
tv204 = 112
tv202 = 120
tv215 = 128
this$ = 160
_Meta$ = 168
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow, COMDAT

; 229  :     int_type overflow(int_type _Meta = _Traits::eof()) override { // put an element to stream

$LN16:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 230  :         if (_Mystate & _Constant) {

  00010	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00018	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0001b	83 e0 02	 and	 eax, 2
  0001e	85 c0		 test	 eax, eax
  00020	74 0a		 je	 SHORT $LN2@overflow

; 231  :             return _Traits::eof(); // array nonmutable, fail

  00022	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00027	e9 da 02 00 00	 jmp	 $LN1@overflow
$LN2@overflow:

; 232  :         }
; 233  : 
; 234  :         if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

  0002c	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00031	89 44 24 50	 mov	 DWORD PTR $T1[rsp], eax
  00035	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR _Meta$[rsp]
  0003d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T1[rsp]
  00042	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00047	0f b6 c0	 movzx	 eax, al
  0004a	85 c0		 test	 eax, eax
  0004c	74 12		 je	 SHORT $LN3@overflow

; 235  :             return _Traits::not_eof(_Meta); // EOF, return success code

  0004e	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR _Meta$[rsp]
  00056	e8 00 00 00 00	 call	 ?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z ; std::_Narrow_char_traits<char,int>::not_eof
  0005b	e9 a6 02 00 00	 jmp	 $LN1@overflow
$LN3@overflow:

; 236  :         }
; 237  : 
; 238  :         const auto _Pptr  = _Mysb::pptr();

  00060	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0006e	48 89 44 24 38	 mov	 QWORD PTR _Pptr$[rsp], rax

; 239  :         const auto _Epptr = _Mysb::epptr();

  00073	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00081	48 89 44 24 58	 mov	 QWORD PTR _Epptr$[rsp], rax

; 240  :         if (_Pptr && _Pptr < _Epptr) { // room in buffer, store it

  00086	48 83 7c 24 38
	00		 cmp	 QWORD PTR _Pptr$[rsp], 0
  0008c	74 52		 je	 SHORT $LN4@overflow
  0008e	48 8b 44 24 58	 mov	 rax, QWORD PTR _Epptr$[rsp]
  00093	48 39 44 24 38	 cmp	 QWORD PTR _Pptr$[rsp], rax
  00098	73 46		 jae	 SHORT $LN4@overflow

; 241  :             *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  0009a	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR _Meta$[rsp]
  000a2	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  000a7	88 44 24 20	 mov	 BYTE PTR tv131[rsp], al
  000ab	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
  000b9	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR tv131[rsp]
  000be	88 08		 mov	 BYTE PTR [rax], cl

; 242  :             _Seekhigh        = _Pptr + 1;

  000c0	48 8b 44 24 38	 mov	 rax, QWORD PTR _Pptr$[rsp]
  000c5	48 ff c0	 inc	 rax
  000c8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000d0	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 243  :             return _Meta;

  000d4	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR _Meta$[rsp]
  000db	e9 26 02 00 00	 jmp	 $LN1@overflow
$LN4@overflow:

; 244  :         }
; 245  : 
; 246  :         // grow buffer and store element
; 247  :         size_t _Oldsize    = 0;

  000e0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR _Oldsize$[rsp], 0

; 248  :         const auto _Oldptr = _Mysb::eback();

  000e9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  000f7	48 89 44 24 48	 mov	 QWORD PTR _Oldptr$[rsp], rax

; 249  :         if (_Pptr) {

  000fc	48 83 7c 24 38
	00		 cmp	 QWORD PTR _Pptr$[rsp], 0
  00102	74 15		 je	 SHORT $LN5@overflow

; 250  :             _Oldsize = static_cast<size_t>(_Epptr - _Oldptr);

  00104	48 8b 44 24 48	 mov	 rax, QWORD PTR _Oldptr$[rsp]
  00109	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Epptr$[rsp]
  0010e	48 2b c8	 sub	 rcx, rax
  00111	48 8b c1	 mov	 rax, rcx
  00114	48 89 44 24 30	 mov	 QWORD PTR _Oldsize$[rsp], rax
$LN5@overflow:

; 251  :         }
; 252  : 
; 253  :         size_t _Newsize;
; 254  :         if (_Oldsize < _MINSIZE) {

  00119	48 83 7c 24 30
	20		 cmp	 QWORD PTR _Oldsize$[rsp], 32 ; 00000020H
  0011f	73 0b		 jae	 SHORT $LN6@overflow

; 255  :             _Newsize = _MINSIZE;

  00121	48 c7 44 24 40
	20 00 00 00	 mov	 QWORD PTR _Newsize$[rsp], 32 ; 00000020H
  0012a	eb 3a		 jmp	 SHORT $LN7@overflow
$LN6@overflow:

; 256  :         } else if (_Oldsize < INT_MAX / 2) { // grow by 50 percent

  0012c	48 81 7c 24 30
	ff ff ff 3f	 cmp	 QWORD PTR _Oldsize$[rsp], 1073741823 ; 3fffffffH
  00135	73 0f		 jae	 SHORT $LN8@overflow

; 257  :             _Newsize = _Oldsize << 1;

  00137	48 8b 44 24 30	 mov	 rax, QWORD PTR _Oldsize$[rsp]
  0013c	48 d1 e0	 shl	 rax, 1
  0013f	48 89 44 24 40	 mov	 QWORD PTR _Newsize$[rsp], rax
  00144	eb 20		 jmp	 SHORT $LN9@overflow
$LN8@overflow:

; 258  :         } else if (_Oldsize < INT_MAX) {

  00146	48 81 7c 24 30
	ff ff ff 7f	 cmp	 QWORD PTR _Oldsize$[rsp], 2147483647 ; 7fffffffH
  0014f	73 0b		 jae	 SHORT $LN10@overflow

; 259  :             _Newsize = INT_MAX;

  00151	48 c7 44 24 40
	ff ff ff 7f	 mov	 QWORD PTR _Newsize$[rsp], 2147483647 ; 7fffffffH

; 260  :         } else { // buffer can't grow, fail

  0015a	eb 0a		 jmp	 SHORT $LN11@overflow
$LN10@overflow:

; 261  :             return _Traits::eof();

  0015c	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00161	e9 a0 01 00 00	 jmp	 $LN1@overflow
$LN11@overflow:
$LN9@overflow:
$LN7@overflow:

; 262  :         }
; 263  : 
; 264  :         const auto _Newptr = _Unfancy(_Al.allocate(_Newsize));

  00166	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0016e	48 83 c0 74	 add	 rax, 116		; 00000074H
  00172	48 89 44 24 68	 mov	 QWORD PTR tv155[rsp], rax
  00177	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Newsize$[rsp]
  0017c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv155[rsp]
  00181	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
  00186	48 8b c8	 mov	 rcx, rax
  00189	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  0018e	48 89 44 24 28	 mov	 QWORD PTR _Newptr$[rsp], rax

; 265  :         _Traits::copy(_Newptr, _Oldptr, _Oldsize);

  00193	4c 8b 44 24 30	 mov	 r8, QWORD PTR _Oldsize$[rsp]
  00198	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Oldptr$[rsp]
  0019d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Newptr$[rsp]
  001a2	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 266  : 
; 267  :         const auto _New_pnext = _Newptr + _Oldsize;

  001a7	48 8b 44 24 30	 mov	 rax, QWORD PTR _Oldsize$[rsp]
  001ac	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Newptr$[rsp]
  001b1	48 03 c8	 add	 rcx, rax
  001b4	48 8b c1	 mov	 rax, rcx
  001b7	48 89 44 24 60	 mov	 QWORD PTR _New_pnext$[rsp], rax

; 268  :         _Seekhigh             = _New_pnext + 1; // to include _Meta

  001bc	48 8b 44 24 60	 mov	 rax, QWORD PTR _New_pnext$[rsp]
  001c1	48 ff c0	 inc	 rax
  001c4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001cc	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 269  : 
; 270  :         _Mysb::setp(_Newptr, _New_pnext, _Newptr + _Newsize);

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR _Newsize$[rsp]
  001d5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Newptr$[rsp]
  001da	48 03 c8	 add	 rcx, rax
  001dd	48 8b c1	 mov	 rax, rcx
  001e0	4c 8b c8	 mov	 r9, rax
  001e3	4c 8b 44 24 60	 mov	 r8, QWORD PTR _New_pnext$[rsp]
  001e8	48 8b 54 24 28	 mov	 rdx, QWORD PTR _Newptr$[rsp]
  001ed	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z

; 271  :         if (_Mystate & _Noread) { // maintain eback() == allocated pointer invariant

  001fb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00203	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00206	83 e0 04	 and	 eax, 4
  00209	85 c0		 test	 eax, eax
  0020b	74 1d		 je	 SHORT $LN12@overflow

; 272  :             _Mysb::setg(_Newptr, nullptr, _Newptr);

  0020d	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _Newptr$[rsp]
  00212	45 33 c0	 xor	 r8d, r8d
  00215	48 8b 54 24 28	 mov	 rdx, QWORD PTR _Newptr$[rsp]
  0021a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00222	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z

; 273  :         } else { // if readable, set the get area to initialized region

  00228	eb 51		 jmp	 SHORT $LN13@overflow
$LN12@overflow:

; 274  :             _Mysb::setg(_Newptr, _Newptr + (_Mysb::gptr() - _Oldptr), _Seekhigh);

  0022a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00232	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00236	48 89 44 24 70	 mov	 QWORD PTR tv204[rsp], rax
  0023b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00243	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00249	48 2b 44 24 48	 sub	 rax, QWORD PTR _Oldptr$[rsp]
  0024e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Newptr$[rsp]
  00253	48 03 c8	 add	 rcx, rax
  00256	48 8b c1	 mov	 rax, rcx
  00259	48 89 44 24 78	 mov	 QWORD PTR tv202[rsp], rax
  0025e	4c 8b 4c 24 70	 mov	 r9, QWORD PTR tv204[rsp]
  00263	4c 8b 44 24 78	 mov	 r8, QWORD PTR tv202[rsp]
  00268	48 8b 54 24 28	 mov	 rdx, QWORD PTR _Newptr$[rsp]
  0026d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00275	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
$LN13@overflow:

; 275  :         }
; 276  : 
; 277  :         if (_Mystate & _Allocated) {

  0027b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00283	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00286	83 e0 01	 and	 eax, 1
  00289	85 c0		 test	 eax, eax
  0028b	74 33		 je	 SHORT $LN14@overflow

; 278  :             _Al.deallocate(_Ptr_traits::pointer_to(*_Oldptr), _Oldsize);

  0028d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00295	48 83 c0 74	 add	 rax, 116		; 00000074H
  00299	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
  002a1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Oldptr$[rsp]
  002a6	e8 00 00 00 00	 call	 ?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z ; std::pointer_traits<char *>::pointer_to
  002ab	4c 8b 44 24 30	 mov	 r8, QWORD PTR _Oldsize$[rsp]
  002b0	48 8b d0	 mov	 rdx, rax
  002b3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv215[rsp]
  002bb	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN14@overflow:

; 279  :         }
; 280  : 
; 281  :         _Mystate |= _Allocated;

  002c0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  002c8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002cb	83 c8 01	 or	 eax, 1
  002ce	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  002d6	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 282  :         *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  002d9	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR _Meta$[rsp]
  002e1	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  002e6	88 44 24 21	 mov	 BYTE PTR tv228[rsp], al
  002ea	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  002f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
  002f8	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR tv228[rsp]
  002fd	88 08		 mov	 BYTE PTR [rax], cl

; 283  :         return _Meta;

  002ff	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR _Meta$[rsp]
$LN1@overflow:

; 284  :     }

  00306	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0030d	c3		 ret	 0
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\sstream
;	COMDAT ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 109  :     ~basic_stringbuf() noexcept override {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00015	48 89 08	 mov	 QWORD PTR [rax], rcx

; 110  :         _Tidy();

  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 111  :     }

  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\sstream
;	COMDAT ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 846  :     ~basic_stringstream() noexcept override {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b 80 68 ff
	ff ff		 mov	 rax, QWORD PTR [rax-152]
  00015	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00025	48 89 94 01 68
	ff ff ff	 mov	 QWORD PTR [rcx+rax-152], rdx
  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00032	48 8b 80 68 ff
	ff ff		 mov	 rax, QWORD PTR [rax-152]
  00039	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0003d	48 2d 98 00 00
	00		 sub	 rax, 152		; 00000098H
  00043	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00048	48 8b 89 68 ff
	ff ff		 mov	 rcx, QWORD PTR [rcx-152]
  0004f	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  00053	48 8b 54 24 30	 mov	 rdx, QWORD PTR this$[rsp]
  00058	89 84 0a 64 ff
	ff ff		 mov	 DWORD PTR [rdx+rcx-156], eax
  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00064	48 2d 80 00 00
	00		 sub	 rax, 128		; 00000080H
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00072	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00077	48 83 e8 78	 sub	 rax, 120		; 00000078H
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00084	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00088	c3		 ret	 0
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\IntegralConstant.h
;	COMDAT ??R?$FixedInt@$00@internal@Eigen@@QEBA?AV012@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
??R?$FixedInt@$00@internal@Eigen@@QEBA?AV012@XZ PROC	; Eigen::internal::FixedInt<1>::operator(), COMDAT

; 82   :   FixedInt operator() () const { return *this; }

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  0000f	c3		 ret	 0
??R?$FixedInt@$00@internal@Eigen@@QEBA?AV012@XZ ENDP	; Eigen::internal::FixedInt<1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\SymbolicIndex.h
;	COMDAT ??0?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@QEAA@XZ PROC ; Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag>::SymbolExpr<Eigen::internal::symbolic_last_tag>, COMDAT

; 219  :   SymbolExpr() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
??0?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@QEAA@XZ ENDP ; Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag>::SymbolExpr<Eigen::internal::symbolic_last_tag>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT

; 4052 :     _NODISCARD _CONSTEXPR20 reference operator[](const size_type _Off) noexcept /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4053 : #if _CONTAINER_DEBUG_LEVEL > 0
; 4054 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 4055 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 4056 :         return _Mypair._Myval2._Myptr()[_Off];

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001b	48 03 44 24 38	 add	 rax, QWORD PTR _Off$[rsp]

; 4057 :     }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2260 :     _CONSTEXPR20 value_type* _Myptr() noexcept {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2261 :         value_type* _Result = _Bx._Buf;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR _Result$[rsp], rax

; 2262 :         if (_Large_string_engaged()) {

  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 12		 je	 SHORT $LN2@Myptr

; 2263 :             _Result = _Unfancy(_Bx._Ptr);

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00029	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002c	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00031	48 89 44 24 20	 mov	 QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 2264 :         }
; 2265 : 
; 2266 :         return _Result;

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR _Result$[rsp]

; 2267 :     }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT

; 2278 :     _CONSTEXPR20 bool _Large_string_engaged() const noexcept {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2279 : #if _HAS_CXX20
; 2280 :         if (_STD is_constant_evaluated()) {

  00009	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0000e	0f b6 c0	 movzx	 eax, al
  00011	85 c0		 test	 eax, eax
  00013	74 04		 je	 SHORT $LN2@Large_stri

; 2281 :             return true;

  00015	b0 01		 mov	 al, 1
  00017	eb 23		 jmp	 SHORT $LN1@Large_stri
$LN2@Large_stri:

; 2282 :         }
; 2283 : #endif // _HAS_CXX20
; 2284 :         return _BUF_SIZE <= _Myres;

  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001e	48 83 78 18 10	 cmp	 QWORD PTR [rax+24], 16
  00023	72 0a		 jb	 SHORT $LN4@Large_stri
  00025	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv69[rsp], 1
  0002d	eb 08		 jmp	 SHORT $LN5@Large_stri
$LN4@Large_stri:
  0002f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN5@Large_stri:
  00037	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv69[rsp]
$LN1@Large_stri:

; 2285 :     }

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT

; 4153 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 4154 :         return _Mypair._Myval2._Mysize;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]

; 4155 :     }

  0000e	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT

; 4149 :     _NODISCARD _CONSTEXPR20 size_type length() const noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 4150 :         return _Mypair._Myval2._Mysize;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]

; 4151 :     }

  0000e	c3		 ret	 0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z
_TEXT	SEGMENT
this$ = 48
_Ch$ = 56
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 3328 :     _CONSTEXPR20 basic_string& operator+=(_Elem _Ch) {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3329 :         push_back(_Ch);

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR _Ch$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00017	e8 00 00 00 00	 call	 ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back

; 3330 :         return *this;

  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]

; 3331 :     }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3206 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3207 :         _Tidy_deallocate();

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 3208 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3209 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 3210 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 3211 :         _Mypair._Myval2._Myproxy = nullptr;
; 3212 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 3213 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3214 :     }

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T2 = 32
$T1 = 33
tv75 = 40
tv77 = 48
tv89 = 56
this$ = 80
_Right$ = 88
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2837 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 89 44 24 30	 mov	 QWORD PTR tv77[rsp], rax
  00018	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Right$[rsp]
  0001d	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 ??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
  0002a	48 89 44 24 28	 mov	 QWORD PTR tv75[rsp], rax
  0002f	0f b6 44 24 21	 movzx	 eax, BYTE PTR $T1[rsp]
  00034	88 44 24 20	 mov	 BYTE PTR $T2[rsp], al
  00038	4c 8b 44 24 28	 mov	 r8, QWORD PTR tv75[rsp]
  0003d	0f b6 54 24 20	 movzx	 edx, BYTE PTR $T2[rsp]
  00042	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv77[rsp]
  00047	e8 00 00 00 00	 call	 ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >

; 2838 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  0004c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00051	48 89 44 24 38	 mov	 QWORD PTR tv89[rsp], rax
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
  0005d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv89[rsp]
  00062	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 2839 :         _Take_contents(_Right);

  00067	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Right$[rsp]
  0006c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00071	e8 00 00 00 00	 call	 ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 2840 :     }

  00076	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0007b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007f	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2621 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
  00018	0f b6 54 24 20	 movzx	 edx, BYTE PTR $T1[rsp]
  0001d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv69[rsp]
  00022	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
  00027	90		 npad	 1

; 2622 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00028	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  0002d	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
  00032	48 8b c8	 mov	 rcx, rax
  00035	e8 00 00 00 00	 call	 ??$_Convert_size@_K@std@@YA_K_K@Z ; std::_Convert_size<unsigned __int64>
  0003a	4c 8b c0	 mov	 r8, rax
  0003d	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00047	e8 00 00 00 00	 call	 ??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
  0004c	90		 npad	 1

; 2623 :     }

  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T3 = 32
$T1 = 33
$T2 = 34
tv76 = 40
tv78 = 48
tv94 = 56
tv92 = 64
this$ = 96
_Right$ = 104
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2586 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 89 44 24 30	 mov	 QWORD PTR tv78[rsp], rax
  00018	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Right$[rsp]
  0001d	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00022	48 8b d0	 mov	 rdx, rax
  00025	48 8d 4c 24 21	 lea	 rcx, QWORD PTR $T1[rsp]
  0002a	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
  0002f	48 89 44 24 28	 mov	 QWORD PTR tv76[rsp], rax
  00034	0f b6 44 24 22	 movzx	 eax, BYTE PTR $T2[rsp]
  00039	88 44 24 20	 mov	 BYTE PTR $T3[rsp], al
  0003d	4c 8b 44 24 28	 mov	 r8, QWORD PTR tv76[rsp]
  00042	0f b6 54 24 20	 movzx	 edx, BYTE PTR $T3[rsp]
  00047	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv78[rsp]
  0004c	e8 00 00 00 00	 call	 ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
  00051	90		 npad	 1

; 2587 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00052	48 8b 44 24 68	 mov	 rax, QWORD PTR _Right$[rsp]
  00057	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005b	48 89 44 24 38	 mov	 QWORD PTR tv94[rsp], rax
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR _Right$[rsp]
  00065	48 8b c8	 mov	 rcx, rax
  00068	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0006d	48 89 44 24 40	 mov	 QWORD PTR tv92[rsp], rax
  00072	4c 8b 44 24 38	 mov	 r8, QWORD PTR tv94[rsp]
  00077	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv92[rsp]
  0007c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00081	e8 00 00 00 00	 call	 ??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
  00086	90		 npad	 1

; 2588 :     }

  00087	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0008c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00090	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T1 = 33
$T2 = 34
tv76 = 40
tv78 = 48
tv94 = 56
tv92 = 64
this$ = 96
_Right$ = 104
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 78 00 00 00	 mov	 edx, 120		; 00000078H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00012	48 2d 98 00 00
	00		 sub	 rax, 152		; 00000098H
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
  00020	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  00024	83 e0 01	 and	 eax, 1
  00027	85 c0		 test	 eax, eax
  00029	74 18		 je	 SHORT $LN2@scalar
  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00030	48 2d 98 00 00
	00		 sub	 rax, 152		; 00000098H
  00036	ba f8 00 00 00	 mov	 edx, 248		; 000000f8H
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00048	48 2d 98 00 00
	00		 sub	 rax, 152		; 00000098H
  0004e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00052	c3		 ret	 0
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor', COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 05 98 00 00
	00		 add	 rax, 152		; 00000098H
  00014	48 8b c8	 mov	 rcx, rax
  00017	e8 00 00 00 00	 call	 ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 05 98 00 00
	00		 add	 rax, 152		; 00000098H
  00027	48 8b c8	 mov	 rcx, rax
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 123  :         explicit __CLR_OR_THIS_CALL operator bool() const {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 124  :             return _Ok;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]

; 125  :         }

  0000e	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv71 = 32
_Zero_uncaught_exceptions$ = 33
this$ = 64
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 108  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 109  : #if !_HAS_EXCEPTIONS
; 110  :             const bool _Zero_uncaught_exceptions = true;
; 111  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 112  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909
; 113  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 114  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;

  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ
  0000f	85 c0		 test	 eax, eax
  00011	75 07		 jne	 SHORT $LN4@sentry
  00013	c6 44 24 20 01	 mov	 BYTE PTR tv71[rsp], 1
  00018	eb 05		 jmp	 SHORT $LN5@sentry
$LN4@sentry:
  0001a	c6 44 24 20 00	 mov	 BYTE PTR tv71[rsp], 0
$LN5@sentry:
  0001f	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv71[rsp]
  00024	88 44 24 21	 mov	 BYTE PTR _Zero_uncaught_exceptions$[rsp], al

; 115  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 116  : 
; 117  :             if (_Zero_uncaught_exceptions) {

  00028	0f b6 44 24 21	 movzx	 eax, BYTE PTR _Zero_uncaught_exceptions$[rsp]
  0002d	85 c0		 test	 eax, eax
  0002f	74 0e		 je	 SHORT $LN2@sentry

; 118  :                 this->_Myostr._Osfx();

  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
$LN2@sentry:

; 119  :             }
; 120  :         }

  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00044	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00049	90		 npad	 1
  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Tied$ = 32
this$ = 64
_Ostr$ = 72
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 91   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Ostr$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  0001d	90		 npad	 1

; 92   :             if (!_Ostr.good()) {

  0001e	48 8b 44 24 48	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00023	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00026	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0002a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  0002f	48 03 c8	 add	 rcx, rax
  00032	48 8b c1	 mov	 rax, rcx
  00035	48 8b c8	 mov	 rcx, rax
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
  0003e	0f b6 c0	 movzx	 eax, al
  00041	85 c0		 test	 eax, eax
  00043	75 0b		 jne	 SHORT $LN2@sentry

; 93   :                 _Ok = false;

  00045	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0004a	c6 40 08 00	 mov	 BYTE PTR [rax+8], 0

; 94   :                 return;

  0004e	eb 77		 jmp	 SHORT $LN1@sentry
$LN2@sentry:

; 95   :             }
; 96   : 
; 97   :             const auto _Tied = _Ostr.tie();

  00050	48 8b 44 24 48	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00055	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00058	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0005c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00061	48 03 c8	 add	 rcx, rax
  00064	48 8b c1	 mov	 rax, rcx
  00067	48 8b c8	 mov	 rcx, rax
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  00070	48 89 44 24 20	 mov	 QWORD PTR _Tied$[rsp], rax

; 98   :             if (!_Tied || _Tied == &_Ostr) {

  00075	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Tied$[rsp], 0
  0007b	74 0c		 je	 SHORT $LN4@sentry
  0007d	48 8b 44 24 48	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00082	48 39 44 24 20	 cmp	 QWORD PTR _Tied$[rsp], rax
  00087	75 0b		 jne	 SHORT $LN3@sentry
$LN4@sentry:

; 99   :                 _Ok = true;

  00089	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0008e	c6 40 08 01	 mov	 BYTE PTR [rax+8], 1

; 100  :                 return;

  00092	eb 33		 jmp	 SHORT $LN1@sentry
$LN3@sentry:

; 101  :             }
; 102  : 
; 103  :             _Tied->flush();

  00094	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Tied$[rsp]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

  0009f	48 8b 44 24 48	 mov	 rax, QWORD PTR _Ostr$[rsp]
  000a4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a7	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000ab	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  000b0	48 03 c8	 add	 rcx, rax
  000b3	48 8b c1	 mov	 rax, rcx
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
  000bf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000c4	88 41 08	 mov	 BYTE PTR [rcx+8], al
$LN1@sentry:

; 105  :         }

  000c7	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000cc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d0	c3		 ret	 0
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Tied$ = 32
this$ = 64
_Ostr$ = 72
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z
_TEXT	SEGMENT
_Val$ = 48
?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z PROC ; std::pointer_traits<char *>::pointer_to, COMDAT

; 274  :     _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 275  :         return _STD addressof(_Val);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Val$[rsp]
  0000e	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPEADAEAD@Z ; std::addressof<char>

; 276  :     }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z ENDP ; std::pointer_traits<char *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT

; 65   :     operator streamoff() const {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 66   :         // TRANSITION, ABI: We currently always set _Fpos to 0 but older .objs containing old
; 67   :         // basic_filebuf would set _Fpos.
; 68   :         return _Myoff + _Fpos;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00012	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]

; 69   :     }

  00016	c3		 ret	 0
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z
_TEXT	SEGMENT
this$ = 16
_Off$ = 24
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 53   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR _Off$[rsp]
  00015	48 89 08	 mov	 QWORD PTR [rax], rcx
  00018	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00025	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0002a	48 83 c0 10	 add	 rax, 16
  0002e	48 8b f8	 mov	 rdi, rax
  00031	33 c0		 xor	 eax, eax
  00033	b9 08 00 00 00	 mov	 ecx, 8
  00038	f3 aa		 rep stosb
  0003a	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseCoeffsBase.h
;	COMDAT ?coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z
_TEXT	SEGMENT
tv86 = 32
tv85 = 40
tv83 = 48
$T1 = 56
$T2 = 64
this$ = 96
index$ = 104
?coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,1,-1,1,1,-1>,1>::coeffRef, COMDAT

; 390  :     {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 391  :       EIGEN_STATIC_ASSERT(internal::evaluator<Derived>::Flags & LinearAccessBit,
; 392  :                           THIS_COEFFICIENT_ACCESSOR_TAKING_ONE_ACCESS_IS_ONLY_FOR_EXPRESSIONS_ALLOWING_LINEAR_ACCESS)
; 393  :       eigen_internal_assert(index >= 0 && index < size());
; 394  :       return internal::evaluator<Derived>(derived()).coeffRef(index);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00013	e8 00 00 00 00	 call	 ?derived@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$00$0?0$00$00$0?0@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::derived
  00018	48 8b d0	 mov	 rdx, rax
  0001b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T1[rsp]
  00020	e8 00 00 00 00	 call	 ??0?$evaluator@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$00$0?0$00$00$0?0@2@@Z ; Eigen::internal::evaluator<Eigen::Matrix<double,1,-1,1,1,-1> >::evaluator<Eigen::Matrix<double,1,-1,1,1,-1> >
  00025	48 89 44 24 20	 mov	 QWORD PTR tv86[rsp], rax
  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR tv86[rsp]
  0002f	48 89 44 24 28	 mov	 QWORD PTR tv85[rsp], rax
  00034	48 8b 44 24 28	 mov	 rax, QWORD PTR tv85[rsp]
  00039	48 89 44 24 30	 mov	 QWORD PTR tv83[rsp], rax
  0003e	48 8b 54 24 68	 mov	 rdx, QWORD PTR index$[rsp]
  00043	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv83[rsp]
  00048	e8 00 00 00 00	 call	 ?coeffRef@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAAAEAN_J@Z ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >::coeffRef
  0004d	48 89 44 24 40	 mov	 QWORD PTR $T2[rsp], rax
  00052	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T1[rsp]
  00057	e8 00 00 00 00	 call	 ??1?$evaluator@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ
  0005c	48 8b 44 24 40	 mov	 rax, QWORD PTR $T2[rsp]

; 395  :     }

  00061	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00065	c3		 ret	 0
?coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,1,-1,1,1,-1>,1>::coeffRef
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv86 = 32
tv85 = 40
tv83 = 48
$T1 = 56
$T2 = 64
this$ = 96
index$ = 104
?dtor$0@?0??coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z@4HA PROC ; `Eigen::DenseCoeffsBase<Eigen::Matrix<double,1,-1,1,1,-1>,1>::coeffRef'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 38	 lea	 rcx, QWORD PTR $T1[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$evaluator@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0??coeffRef@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z@4HA ENDP ; `Eigen::DenseCoeffsBase<Eigen::Matrix<double,1,-1,1,1,-1>,1>::coeffRef'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\EigenBase.h
;	COMDAT ?size@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
tv65 = 32
this$ = 64
?size@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::size, COMDAT

; 67   :   inline Index size() const EIGEN_NOEXCEPT { return rows() * cols(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?rows@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::rows
  00013	48 89 44 24 20	 mov	 QWORD PTR tv65[rsp], rax
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ?cols@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::cols
  00022	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv65[rsp]
  00027	48 0f af c8	 imul	 rcx, rax
  0002b	48 8b c1	 mov	 rax, rcx
  0002e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00032	c3		 ret	 0
?size@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ??0?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 64
other$ = 72
??0?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@AEBV01@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >, COMDAT

; 512  :       : Base(), m_storage(other.m_storage) { }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00015	e8 00 00 00 00	 call	 ??0?$MatrixBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@XZ ; Eigen::MatrixBase<Eigen::Matrix<double,28,28,0,28,28> >::MatrixBase<Eigen::Matrix<double,28,28,0,28,28> >
  0001a	48 8b 44 24 48	 mov	 rax, QWORD PTR other$[rsp]
  0001f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00024	48 8b 7c 24 40	 mov	 rdi, QWORD PTR this$[rsp]
  00029	48 8b 74 24 48	 mov	 rsi, QWORD PTR other$[rsp]
  0002e	b9 80 18 00 00	 mov	 ecx, 6272		; 00001880H
  00033	f3 a4		 rep movsb
  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	5f		 pop	 rdi
  0003f	5e		 pop	 rsi
  00040	c3		 ret	 0
??0?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@AEBV01@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\sstream
;	COMDAT ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ
_TEXT	SEGMENT
tv88 = 32
tv141 = 40
tv139 = 48
tv143 = 56
this$ = 80
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT

; 482  :     void _Tidy() noexcept { // discard any allocated buffer and clear pointers

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 483  :         if (_Mystate & _Allocated) {

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0000e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00011	83 e0 01	 and	 eax, 1
  00014	85 c0		 test	 eax, eax
  00016	0f 84 87 00 00
	00		 je	 $LN2@Tidy

; 484  :             _Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),

  0001c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 83 c0 74	 add	 rax, 116		; 00000074H
  00025	48 89 44 24 38	 mov	 QWORD PTR tv143[rsp], rax
  0002a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00035	48 85 c0	 test	 rax, rax
  00038	74 12		 je	 SHORT $LN4@Tidy
  0003a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00045	48 89 44 24 20	 mov	 QWORD PTR tv88[rsp], rax
  0004a	eb 10		 jmp	 SHORT $LN5@Tidy
$LN4@Tidy:
  0004c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00057	48 89 44 24 20	 mov	 QWORD PTR tv88[rsp], rax
$LN5@Tidy:
  0005c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00067	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv88[rsp]
  0006c	48 2b c8	 sub	 rcx, rax
  0006f	48 8b c1	 mov	 rax, rcx
  00072	48 89 44 24 28	 mov	 QWORD PTR tv141[rsp], rax
  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00082	48 8b c8	 mov	 rcx, rax
  00085	e8 00 00 00 00	 call	 ?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z ; std::pointer_traits<char *>::pointer_to
  0008a	48 89 44 24 30	 mov	 QWORD PTR tv139[rsp], rax
  0008f	4c 8b 44 24 28	 mov	 r8, QWORD PTR tv141[rsp]
  00094	48 8b 54 24 30	 mov	 rdx, QWORD PTR tv139[rsp]
  00099	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv143[rsp]
  0009e	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN2@Tidy:

; 485  :                 static_cast<typename allocator_traits<allocator_type>::size_type>(
; 486  :                     (_Mysb::pptr() ? _Mysb::epptr() : _Mysb::egptr()) - _Mysb::eback()));
; 487  :         }
; 488  : 
; 489  :         _Mysb::setg(nullptr, nullptr, nullptr);

  000a3	45 33 c9	 xor	 r9d, r9d
  000a6	45 33 c0	 xor	 r8d, r8d
  000a9	33 d2		 xor	 edx, edx
  000ab	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z

; 490  :         _Mysb::setp(nullptr, nullptr);

  000b6	45 33 c0	 xor	 r8d, r8d
  000b9	33 d2		 xor	 edx, edx
  000bb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD0@Z

; 491  :         _Seekhigh = nullptr;

  000c6	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000cb	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 492  :         _Mystate &= ~_Allocated;

  000d3	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000d8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000db	83 e0 fe	 and	 eax, -2
  000de	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000e3	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 493  :     }

  000e6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ea	c3		 ret	 0
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4935 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4936 :         return _Mypair._Get_first();

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4937 :     }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4931 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4932 :         return _Mypair._Get_first();

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4933 :     }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
_Ptr$2 = 48
_Al$3 = 56
this$ = 80
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 4892 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4893 :         auto& _My_data = _Mypair._Myval2;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 44 24 28	 mov	 QWORD PTR _My_data$[rsp], rax

; 4894 :         _My_data._Orphan_all();

  00013	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _My_data$[rsp]
  00018	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 4895 :         _ASAN_STRING_REMOVE(*this);
; 4896 :         if (_My_data._Large_string_engaged()) {

  0001d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _My_data$[rsp]
  00022	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00027	0f b6 c0	 movzx	 eax, al
  0002a	85 c0		 test	 eax, eax
  0002c	74 60		 je	 SHORT $LN2@Tidy_deall

; 4897 :             const pointer _Ptr = _My_data._Bx._Ptr;

  0002e	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00033	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00036	48 89 44 24 30	 mov	 QWORD PTR _Ptr$2[rsp], rax

; 4898 :             auto& _Al          = _Getal();

  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00040	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00045	48 89 44 24 38	 mov	 QWORD PTR _Al$3[rsp], rax

; 4899 :             _Destroy_in_place(_My_data._Bx._Ptr);

  0004a	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ; std::_Destroy_in_place<char *>

; 4900 : #if _HAS_CXX20
; 4901 :             if (_STD is_constant_evaluated()) { // begin the lifetime of the array elements before copying into them

  00057	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0005c	0f b6 c0	 movzx	 eax, al
  0005f	85 c0		 test	 eax, eax
  00061	74 0d		 je	 SHORT $LN3@Tidy_deall

; 4902 :                 _Construct_in_place(_My_data._Bx);

  00063	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00068	48 8b c8	 mov	 rcx, rax
  0006b	e8 00 00 00 00	 call	 ??$_Construct_in_place@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$V@std@@YAXAEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@@Z ; std::_Construct_in_place<std::_String_val<std::_Simple_types<char> >::_Bxty>
$LN3@Tidy_deall:

; 4903 :             }
; 4904 : #endif // _HAS_CXX20
; 4905 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00070	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00075	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00079	48 ff c0	 inc	 rax
  0007c	4c 8b c0	 mov	 r8, rax
  0007f	48 8b 54 24 30	 mov	 rdx, QWORD PTR _Ptr$2[rsp]
  00084	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Al$3[rsp]
  00089	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN2@Tidy_deall:

; 4906 :         }
; 4907 : 
; 4908 :         _My_data._Mysize = 0;

  0008e	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00093	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 4909 : #if _HAS_CXX20
; 4910 :         if (_STD is_constant_evaluated()) {

  0009b	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  000a0	0f b6 c0	 movzx	 eax, al
  000a3	85 c0		 test	 eax, eax
  000a5	74 0f		 je	 SHORT $LN4@Tidy_deall

; 4911 :             _My_data._Myres = 0;

  000a7	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  000ac	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 4912 :         } else

  000b4	eb 34		 jmp	 SHORT $LN5@Tidy_deall
$LN4@Tidy_deall:

; 4913 : #endif // _HAS_CXX20
; 4914 :         {
; 4915 :             _My_data._Myres = _BUF_SIZE - 1;

  000b6	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  000bb	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15

; 4916 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4917 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000c3	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0
  000c8	b8 01 00 00 00	 mov	 eax, 1
  000cd	48 6b c0 00	 imul	 rax, rax, 0
  000d1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _My_data$[rsp]
  000d6	48 03 c8	 add	 rcx, rax
  000d9	48 8b c1	 mov	 rax, rcx
  000dc	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  000e1	48 8b c8	 mov	 rcx, rax
  000e4	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
  000e9	90		 npad	 1
$LN5@Tidy_deall:

; 4918 :         }
; 4919 :     }

  000ea	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ee	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
_New_ptr$2 = 48
_Al$3 = 56
_Raw_new$4 = 64
this$ = 96
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT

; 4868 :     _CONSTEXPR20 void _Tidy_init() noexcept { // initialize basic_string data members

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4869 :         auto& _My_data   = _Mypair._Myval2;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 44 24 28	 mov	 QWORD PTR _My_data$[rsp], rax

; 4870 :         _My_data._Mysize = 0;

  00013	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00018	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 4871 : 
; 4872 : #if _HAS_CXX20
; 4873 :         if (_STD is_constant_evaluated()) {

  00020	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	74 60		 je	 SHORT $LN2@Tidy_init

; 4874 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context

  0002c	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00031	48 c7 40 18 10
	00 00 00	 mov	 QWORD PTR [rax+24], 16

; 4875 :             auto& _Al              = _Getal();

  00039	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0003e	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00043	48 89 44 24 38	 mov	 QWORD PTR _Al$3[rsp], rax

; 4876 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws

  00048	ba 11 00 00 00	 mov	 edx, 17
  0004d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Al$3[rsp]
  00052	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
  00057	48 89 44 24 30	 mov	 QWORD PTR _New_ptr$2[rsp], rax

; 4877 :             _My_data._Bx._Ptr      = _New_ptr;

  0005c	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00061	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _New_ptr$2[rsp]
  00066	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4878 : 
; 4879 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00069	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _New_ptr$2[rsp]
  0006e	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00073	48 89 44 24 40	 mov	 QWORD PTR _Raw_new$4[rsp], rax

; 4880 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());

  00078	45 33 c0	 xor	 r8d, r8d
  0007b	ba 11 00 00 00	 mov	 edx, 17
  00080	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Raw_new$4[rsp]
  00085	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4881 :         } else

  0008a	eb 34		 jmp	 SHORT $LN3@Tidy_init
$LN2@Tidy_init:

; 4882 : #endif // _HAS_CXX20
; 4883 :         {
; 4884 :             _My_data._Myres = _BUF_SIZE - 1;

  0008c	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00091	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15

; 4885 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4886 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00099	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0
  0009e	b8 01 00 00 00	 mov	 eax, 1
  000a3	48 6b c0 00	 imul	 rax, rax, 0
  000a7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _My_data$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  000b7	48 8b c8	 mov	 rcx, rax
  000ba	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
  000bf	90		 npad	 1
$LN3@Tidy_init:

; 4887 :         }
; 4888 : 
; 4889 :         _ASAN_STRING_CREATE(*this);
; 4890 :     }

  000c0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000c4	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_Old_size$ = 40
_Ptr$3 = 48
this$ = 80
_Ch$ = 88
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT

; 4074 :     _CONSTEXPR20 void push_back(const _Elem _Ch) { // insert element at end

$LN4:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4075 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0000d	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00012	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00016	48 89 44 24 28	 mov	 QWORD PTR _Old_size$[rsp], rax

; 4076 :         if (_Old_size < _Mypair._Myval2._Myres) {

  0001b	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00020	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00024	48 39 44 24 28	 cmp	 QWORD PTR _Old_size$[rsp], rax
  00029	73 63		 jae	 SHORT $LN2@push_back

; 4077 :             _ASAN_STRING_MODIFY(1);
; 4078 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  0002b	48 8b 44 24 28	 mov	 rax, QWORD PTR _Old_size$[rsp]
  00030	48 ff c0	 inc	 rax
  00033	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00038	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 4079 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();

  0003c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00041	48 8b c8	 mov	 rcx, rax
  00044	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00049	48 89 44 24 30	 mov	 QWORD PTR _Ptr$3[rsp], rax

; 4080 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  0004e	48 8b 44 24 28	 mov	 rax, QWORD PTR _Old_size$[rsp]
  00053	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Ptr$3[rsp]
  00058	48 03 c8	 add	 rcx, rax
  0005b	48 8b c1	 mov	 rax, rcx
  0005e	48 8d 54 24 58	 lea	 rdx, QWORD PTR _Ch$[rsp]
  00063	48 8b c8	 mov	 rcx, rax
  00066	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4081 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  0006b	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0
  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR _Ptr$3[rsp]
  00075	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Old_size$[rsp]
  0007a	48 8d 44 08 01	 lea	 rax, QWORD PTR [rax+rcx+1]
  0007f	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00084	48 8b c8	 mov	 rcx, rax
  00087	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4082 :             return;

  0008c	eb 1b		 jmp	 SHORT $LN1@push_back
$LN2@push_back:

; 4083 :         }
; 4084 : 
; 4085 :         _Reallocate_grow_by(

  0008e	44 0f b6 4c 24
	58		 movzx	 r9d, BYTE PTR _Ch$[rsp]
  00094	44 0f b6 44 24
	21		 movzx	 r8d, BYTE PTR $T2[rsp]
  0009a	ba 01 00 00 00	 mov	 edx, 1
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000a4	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN1@push_back:

; 4086 :             1,
; 4087 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
; 4088 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 4089 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);
; 4090 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 4091 :             },
; 4092 :             _Ch);
; 4093 :     }

  000a9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ad	c3		 ret	 0
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_ptr$ = 72
_Old_ptr$ = 80
_Old_size$ = 88
_Ch$ = 96
??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator(), COMDAT

; 4087 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4088 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

  00018	4c 8b 44 24 58	 mov	 r8, QWORD PTR _Old_size$[rsp]
  0001d	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Old_ptr$[rsp]
  00022	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  00027	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 4089 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  0002c	48 8b 44 24 58	 mov	 rax, QWORD PTR _Old_size$[rsp]
  00031	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  00036	48 03 c8	 add	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	48 8d 54 24 60	 lea	 rdx, QWORD PTR _Ch$[rsp]
  00041	48 8b c8	 mov	 rcx, rax
  00044	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4090 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00049	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0
  0004e	48 8b 44 24 48	 mov	 rax, QWORD PTR _New_ptr$[rsp]
  00053	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Old_size$[rsp]
  00058	48 8d 44 08 01	 lea	 rax, QWORD PTR [rax+rcx+1]
  0005d	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00062	48 8b c8	 mov	 rcx, rax
  00065	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4091 :             },

  0006a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006e	c3		 ret	 0
??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
_Right_data$ = 32
_My_data$ = 40
tv135 = 48
this$ = 80
_Right$ = 88
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT

; 3097 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3098 :         // assign by stealing _Right's buffer
; 3099 :         // pre: this != &_Right
; 3100 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 3101 :         // pre: *this owns no memory, iterators orphaned
; 3102 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 3103 :         auto& _My_data    = _Mypair._Myval2;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR _My_data$[rsp], rax

; 3104 :         auto& _Right_data = _Right._Mypair._Myval2;

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _Right$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR _Right_data$[rsp], rax

; 3105 : 
; 3106 :         if constexpr (_Can_memcpy_val) {
; 3107 : #if _HAS_CXX20
; 3108 :             if (!_STD is_constant_evaluated())

  00022	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00027	0f b6 c0	 movzx	 eax, al
  0002a	85 c0		 test	 eax, eax
  0002c	75 1e		 jne	 SHORT $LN2@Take_conte

; 3109 : #endif // _HAS_CXX20
; 3110 :             {
; 3111 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3112 :                 if (_Right_data._Large_string_engaged()) {
; 3113 :                     // take ownership of _Right's iterators along with its buffer
; 3114 :                     _Swap_proxy_and_iterators(_Right);
; 3115 :                 } else {
; 3116 :                     _Right_data._Orphan_all();
; 3117 :                 }
; 3118 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3119 : 
; 3120 : #ifdef _INSERT_STRING_ANNOTATION
; 3121 :                 if (!_Right_data._Large_string_engaged()) {
; 3122 :                     _ASAN_STRING_REMOVE(_Right);
; 3123 :                 }
; 3124 : #endif // _INSERT_STRING_ANNOTATION
; 3125 : 
; 3126 :                 _Memcpy_val_from(_Right);

  0002e	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Right$[rsp]
  00033	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00038	e8 00 00 00 00	 call	 ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from

; 3127 : 
; 3128 : #ifdef _INSERT_STRING_ANNOTATION
; 3129 :                 if (!_Right_data._Large_string_engaged()) {
; 3130 :                     _ASAN_STRING_REMOVE(_Right);
; 3131 :                     _ASAN_STRING_CREATE(*this);
; 3132 :                 }
; 3133 : #endif // _INSERT_STRING_ANNOTATION
; 3134 : 
; 3135 :                 _Right._Tidy_init();

  0003d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Right$[rsp]
  00042	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 3136 :                 return;

  00047	e9 c0 00 00 00	 jmp	 $LN1@Take_conte
$LN2@Take_conte:

; 3137 :             }
; 3138 :         }
; 3139 : 
; 3140 :         if (_Right_data._Large_string_engaged()) { // steal buffer

  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Right_data$[rsp]
  00051	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00056	0f b6 c0	 movzx	 eax, al
  00059	85 c0		 test	 eax, eax
  0005b	74 2f		 je	 SHORT $LN3@Take_conte

; 3141 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

  0005d	48 8b 44 24 20	 mov	 rax, QWORD PTR _Right_data$[rsp]
  00062	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _My_data$[rsp]
  00067	48 8b d0	 mov	 rdx, rax
  0006a	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>

; 3142 :             _Right_data._Bx._Ptr = nullptr;

  0006f	48 8b 44 24 20	 mov	 rax, QWORD PTR _Right_data$[rsp]
  00074	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 3143 :             _Swap_proxy_and_iterators(_Right);

  0007b	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Right$[rsp]
  00080	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00085	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 3144 :         } else { // copy small string buffer

  0008a	eb 51		 jmp	 SHORT $LN4@Take_conte
$LN3@Take_conte:

; 3145 : #if _HAS_CXX20
; 3146 :             if (_STD is_constant_evaluated()) { // begin the lifetime of the array elements before copying into them

  0008c	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00091	0f b6 c0	 movzx	 eax, al
  00094	85 c0		 test	 eax, eax
  00096	74 0d		 je	 SHORT $LN5@Take_conte

; 3147 :                 _Construct_in_place(_Mypair._Myval2._Bx);

  00098	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0009d	48 8b c8	 mov	 rcx, rax
  000a0	e8 00 00 00 00	 call	 ??$_Construct_in_place@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$V@std@@YAXAEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@@Z ; std::_Construct_in_place<std::_String_val<std::_Simple_types<char> >::_Bxty>
$LN5@Take_conte:

; 3148 :             }
; 3149 : #endif // _HAS_CXX20
; 3150 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

  000a5	48 8b 44 24 20	 mov	 rax, QWORD PTR _Right_data$[rsp]
  000aa	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ae	48 ff c0	 inc	 rax
  000b1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Right_data$[rsp]
  000b6	48 8b 54 24 28	 mov	 rdx, QWORD PTR _My_data$[rsp]
  000bb	48 89 54 24 30	 mov	 QWORD PTR tv135[rsp], rdx
  000c0	4c 8b c0	 mov	 r8, rax
  000c3	48 8b d1	 mov	 rdx, rcx
  000c6	48 8b 44 24 30	 mov	 rax, QWORD PTR tv135[rsp]
  000cb	48 8b c8	 mov	 rcx, rax
  000ce	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3151 :             _Right_data._Orphan_all();

  000d3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Right_data$[rsp]
  000d8	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
$LN4@Take_conte:

; 3152 :         }
; 3153 : 
; 3154 :         _My_data._Mysize = _Right_data._Mysize;

  000dd	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  000e2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Right_data$[rsp]
  000e7	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000eb	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 3155 :         _My_data._Myres  = _Right_data._Myres;

  000ef	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  000f4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Right_data$[rsp]
  000f9	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000fd	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 3156 :         _Right._Tidy_init();

  00101	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Right$[rsp]
  00106	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
  0010b	90		 npad	 1
$LN1@Take_conte:

; 3157 :     }

  0010c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00110	c3		 ret	 0
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 2313 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2269 :     _CONSTEXPR20 const value_type* _Myptr() const noexcept {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2270 :         const value_type* _Result = _Bx._Buf;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR _Result$[rsp], rax

; 2271 :         if (_Large_string_engaged()) {

  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 12		 je	 SHORT $LN2@Myptr

; 2272 :             _Result = _Unfancy(_Bx._Ptr);

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00029	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002c	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00031	48 89 44 24 20	 mov	 QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 2273 :         }
; 2274 : 
; 2275 :         return _Result;

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR _Result$[rsp]

; 2276 :     }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 699  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 700  :         return _Al;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 701  :     }

  0000f	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 835  :     _NODISCARD _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 836  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 837  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Count$[rsp]
  00013	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$00@std@@YA_K_K@Z ; std::_Get_size_of_n<1>
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 838  :     }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 41   :     (max) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 42   :     // return larger of _Left and _Right
; 43   :     return _Left < _Right ? _Right : _Left;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR _Left$[rsp]
  00013	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Right$[rsp]
  00018	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001e	73 0b		 jae	 SHORT $LN3@max
  00020	48 8b 44 24 28	 mov	 rax, QWORD PTR _Right$[rsp]
  00025	48 89 04 24	 mov	 QWORD PTR tv65[rsp], rax
  00029	eb 09		 jmp	 SHORT $LN4@max
$LN3@max:
  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR _Left$[rsp]
  00030	48 89 04 24	 mov	 QWORD PTR tv65[rsp], rax
$LN4@max:
  00034	48 8b 04 24	 mov	 rax, QWORD PTR tv65[rsp]
  00038	48 89 44 24 08	 mov	 QWORD PTR $T1[rsp], rax
  0003d	48 8b 44 24 08	 mov	 rax, QWORD PTR $T1[rsp]

; 44   : }

  00042	48 83 c4 18	 add	 rsp, 24
  00046	c3		 ret	 0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 829  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 830  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 831  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 832  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00013	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Count$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  0001d	e8 00 00 00 00	 call	 ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 833  :     }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 472  :         return static_cast<int_type>(EOF);

  00000	b8 ff ff ff ff	 mov	 eax, -1

; 473  :     }

  00005	c3		 ret	 0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z
_TEXT	SEGMENT
tv68 = 32
tv69 = 36
_Meta$ = 64
?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z PROC	; std::_Narrow_char_traits<char,int>::not_eof, COMDAT

; 467  :     _NODISCARD static constexpr int_type not_eof(const int_type& _Meta) noexcept {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 468  :         return _Meta != eof() ? _Meta : !eof();

  00009	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Meta$[rsp]
  00013	39 01		 cmp	 DWORD PTR [rcx], eax
  00015	74 0d		 je	 SHORT $LN5@not_eof
  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR _Meta$[rsp]
  0001c	8b 00		 mov	 eax, DWORD PTR [rax]
  0001e	89 44 24 24	 mov	 DWORD PTR tv69[rsp], eax
  00022	eb 23		 jmp	 SHORT $LN6@not_eof
$LN5@not_eof:
  00024	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00029	85 c0		 test	 eax, eax
  0002b	75 0a		 jne	 SHORT $LN3@not_eof
  0002d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  00035	eb 08		 jmp	 SHORT $LN4@not_eof
$LN3@not_eof:
  00037	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN4@not_eof:
  0003f	8b 44 24 20	 mov	 eax, DWORD PTR tv68[rsp]
  00043	89 44 24 24	 mov	 DWORD PTR tv69[rsp], eax
$LN6@not_eof:
  00047	8b 44 24 24	 mov	 eax, DWORD PTR tv69[rsp]

; 469  :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
?not_eof@?$_Narrow_char_traits@DH@std@@SAHAEBH@Z ENDP	; std::_Narrow_char_traits<char,int>::not_eof
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z
_TEXT	SEGMENT
tv65 = 0
_Left$ = 32
_Right$ = 40
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 463  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 464  :         return _Left == _Right;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR _Left$[rsp]
  00013	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Right$[rsp]
  00018	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0001a	39 08		 cmp	 DWORD PTR [rax], ecx
  0001c	75 09		 jne	 SHORT $LN3@eq_int_typ
  0001e	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv65[rsp], 1
  00025	eb 07		 jmp	 SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
  00027	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv65[rsp], 0
$LN4@eq_int_typ:
  0002e	0f b6 04 24	 movzx	 eax, BYTE PTR tv65[rsp]

; 465  :     }

  00032	48 83 c4 18	 add	 rsp, 24
  00036	c3		 ret	 0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z
_TEXT	SEGMENT
_Ch$ = 8
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::to_int_type, COMDAT

; 459  :     _NODISCARD static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 460  :         return static_cast<unsigned char>(_Ch);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Ch$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 461  :     }

  0000d	c3		 ret	 0
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::to_int_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z
_TEXT	SEGMENT
_Meta$ = 8
?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z PROC ; std::_Narrow_char_traits<char,int>::to_char_type, COMDAT

; 455  :     _NODISCARD static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 456  :         return static_cast<_Elem>(_Meta);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Meta$[rsp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 457  :     }

  0000d	c3		 ret	 0
?to_char_type@?$_Narrow_char_traits@DH@std@@SADAEBH@Z ENDP ; std::_Narrow_char_traits<char,int>::to_char_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?eq@?$_Narrow_char_traits@DH@std@@SA_NAEBD0@Z
_TEXT	SEGMENT
tv67 = 0
_Left$ = 32
_Right$ = 40
?eq@?$_Narrow_char_traits@DH@std@@SA_NAEBD0@Z PROC	; std::_Narrow_char_traits<char,int>::eq, COMDAT

; 447  :     _NODISCARD static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 448  :         return _Left == _Right;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR _Left$[rsp]
  00013	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00016	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Right$[rsp]
  0001b	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  0001e	3b c1		 cmp	 eax, ecx
  00020	75 09		 jne	 SHORT $LN3@eq
  00022	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv67[rsp], 1
  00029	eb 07		 jmp	 SHORT $LN4@eq
$LN3@eq:
  0002b	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv67[rsp], 0
$LN4@eq:
  00032	0f b6 04 24	 movzx	 eax, BYTE PTR tv67[rsp]

; 449  :     }

  00036	48 83 c4 18	 add	 rsp, 24
  0003a	c3		 ret	 0
?eq@?$_Narrow_char_traits@DH@std@@SA_NAEBD0@Z ENDP	; std::_Narrow_char_traits<char,int>::eq
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
tv68 = 0
tv67 = 8
_First$ = 32
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 385  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 386  :         // find length of null-terminated string
; 387  : #if _HAS_CXX17
; 388  : #ifdef __cpp_char8_t
; 389  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 390  : #if _HAS_U8_INTRINSICS
; 391  :             return __builtin_u8strlen(_First);
; 392  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 393  :             return _Primary_char_traits::length(_First);
; 394  : #endif // _HAS_U8_INTRINSICS
; 395  :         } else
; 396  : #endif // __cpp_char8_t
; 397  :         {
; 398  :             return __builtin_strlen(_First);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR _First$[rsp]
  0000e	48 89 44 24 08	 mov	 QWORD PTR tv67[rsp], rax
  00013	48 c7 04 24 ff
	ff ff ff	 mov	 QWORD PTR tv68[rsp], -1
$LL3@length:
  0001b	48 ff 04 24	 inc	 QWORD PTR tv68[rsp]
  0001f	48 8b 44 24 08	 mov	 rax, QWORD PTR tv67[rsp]
  00024	48 8b 0c 24	 mov	 rcx, QWORD PTR tv68[rsp]
  00028	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  0002c	75 ed		 jne	 SHORT $LL3@length
  0002e	48 8b 04 24	 mov	 rax, QWORD PTR tv68[rsp]

; 399  :         }
; 400  : #else // _HAS_CXX17
; 401  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 402  : #endif // _HAS_CXX17
; 403  :     }

  00032	48 83 c4 18	 add	 rsp, 24
  00036	c3		 ret	 0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_Idx$1 = 32
_First1$ = 80
_First2$ = 88
_Count$ = 96
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 48   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 49   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 50   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 51   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 52   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 53   : #if _HAS_CXX20
; 54   :         if (_STD is_constant_evaluated()) {

  00015	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	85 c0		 test	 eax, eax
  0001f	74 52		 je	 SHORT $LN5@copy

; 55   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap; see LWG-3085
; 56   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {

  00021	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR _Idx$1[rsp], 0
  0002a	eb 0d		 jmp	 SHORT $LN4@copy
$LN2@copy:
  0002c	48 8b 44 24 20	 mov	 rax, QWORD PTR _Idx$1[rsp]
  00031	48 ff c0	 inc	 rax
  00034	48 89 44 24 20	 mov	 QWORD PTR _Idx$1[rsp], rax
$LN4@copy:
  00039	48 8b 44 24 60	 mov	 rax, QWORD PTR _Count$[rsp]
  0003e	48 39 44 24 20	 cmp	 QWORD PTR _Idx$1[rsp], rax
  00043	74 27		 je	 SHORT $LN3@copy

; 57   :                 _First1[_Idx] = _First2[_Idx];

  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR _Idx$1[rsp]
  0004a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _First1$[rsp]
  0004f	48 03 c8	 add	 rcx, rax
  00052	48 8b c1	 mov	 rax, rcx
  00055	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Idx$1[rsp]
  0005a	48 8b 54 24 58	 mov	 rdx, QWORD PTR _First2$[rsp]
  0005f	48 03 d1	 add	 rdx, rcx
  00062	48 8b ca	 mov	 rcx, rdx
  00065	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00068	88 08		 mov	 BYTE PTR [rax], cl

; 58   :             }

  0006a	eb c0		 jmp	 SHORT $LN2@copy
$LN3@copy:

; 59   : 
; 60   :             return _First1;

  0006c	48 8b 44 24 50	 mov	 rax, QWORD PTR _First1$[rsp]
  00071	eb 16		 jmp	 SHORT $LN1@copy
$LN5@copy:

; 61   :         }
; 62   : #endif // _HAS_CXX20
; 63   : 
; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00073	48 8b 7c 24 50	 mov	 rdi, QWORD PTR _First1$[rsp]
  00078	48 8b 74 24 58	 mov	 rsi, QWORD PTR _First2$[rsp]
  0007d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Count$[rsp]
  00082	f3 a4		 rep movsb

; 65   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 66   : 
; 67   :         return _First1;

  00084	48 8b 44 24 50	 mov	 rax, QWORD PTR _First1$[rsp]
$LN1@copy:

; 68   :     }

  00089	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008d	5f		 pop	 rdi
  0008e	5e		 pop	 rsi
  0008f	c3		 ret	 0
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$evaluator@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$evaluator@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ PROC ; Eigen::internal::evaluator<Eigen::Matrix<double,1,-1,1,1,-1> >::~evaluator<Eigen::Matrix<double,1,-1,1,1,-1> >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ
  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1?$evaluator@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ENDP ; Eigen::internal::evaluator<Eigen::Matrix<double,1,-1,1,1,-1> >::~evaluator<Eigen::Matrix<double,1,-1,1,1,-1> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ PROC ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >::~evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??1?$evaluator_base@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >::~evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >
  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ ENDP ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >::~evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\MatrixBase.h
;	COMDAT ??0?$MatrixBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$MatrixBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@XZ PROC ; Eigen::MatrixBase<Eigen::Matrix<double,28,28,0,28,28> >::MatrixBase<Eigen::Matrix<double,28,28,0,28,28> >, COMDAT

; 485  :     EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(MatrixBase)

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??0?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@XZ ; Eigen::DenseBase<Eigen::Matrix<double,28,28,0,28,28> >::DenseBase<Eigen::Matrix<double,28,28,0,28,28> >
  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
??0?$MatrixBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@XZ ENDP ; Eigen::MatrixBase<Eigen::Matrix<double,28,28,0,28,28> >::MatrixBase<Eigen::Matrix<double,28,28,0,28,28> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ??0?$evaluator@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$00$0?0$00$00$0?0@2@@Z
_TEXT	SEGMENT
this$ = 48
m$ = 56
??0?$evaluator@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$00$0?0$00$00$0?0@2@@Z PROC ; Eigen::internal::evaluator<Eigen::Matrix<double,1,-1,1,1,-1> >::evaluator<Eigen::Matrix<double,1,-1,1,1,-1> >, COMDAT

; 284  :   { }

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 283  :     : evaluator<PlainObjectBase<XprType> >(m)

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR m$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >

; 284  :   { }

  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
??0?$evaluator@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$00$0?0$00$00$0?0@2@@Z ENDP ; Eigen::internal::evaluator<Eigen::Matrix<double,1,-1,1,1,-1> >::evaluator<Eigen::Matrix<double,1,-1,1,1,-1> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ?coeffRef@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAAAEAN_J@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
?coeffRef@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAAAEAN_J@Z PROC ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >::coeffRef, COMDAT

; 227  :   {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 228  :     return const_cast<Scalar*>(m_d.data)[index];

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 8b 4c 24 10	 mov	 rcx, QWORD PTR index$[rsp]
  00017	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]

; 229  :   }

  0001b	c3		 ret	 0
?coeffRef@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAAAEAN_J@Z ENDP ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >::coeffRef
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ??1?$evaluator_base@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$evaluator_base@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ PROC ; Eigen::internal::evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >::~evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >, COMDAT

; 122  :   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ~evaluator_base() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	c3		 ret	 0
??1?$evaluator_base@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ENDP ; Eigen::internal::evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >::~evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Rdbuf$ = 32
tv72 = 40
this$ = 64
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 77   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 78   :             const auto _Rdbuf = _Myostr.rdbuf();

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 44 24 28	 mov	 QWORD PTR tv72[rsp], rax
  00016	48 8b 44 24 28	 mov	 rax, QWORD PTR tv72[rsp]
  0001b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001e	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00022	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv72[rsp]
  00027	48 03 c8	 add	 rcx, rax
  0002a	48 8b c1	 mov	 rax, rcx
  0002d	48 8b c8	 mov	 rcx, rax
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00036	48 89 44 24 20	 mov	 QWORD PTR _Rdbuf$[rsp], rax

; 79   :             if (_Rdbuf) {

  0003b	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Rdbuf$[rsp], 0
  00041	74 11		 je	 SHORT $LN2@Sentry_bas

; 80   :                 _Rdbuf->_Unlock();

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR _Rdbuf$[rsp]
  00048	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Rdbuf$[rsp]
  00050	ff 50 10	 call	 QWORD PTR [rax+16]
  00053	90		 npad	 1
$LN2@Sentry_bas:

; 81   :             }
; 82   :         }

  00054	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00058	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Rdbuf$ = 32
tv73 = 40
this$ = 64
_Ostr$ = 72
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 70   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00018	48 89 08	 mov	 QWORD PTR [rax], rcx

; 71   :             const auto _Rdbuf = _Myostr.rdbuf();

  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00020	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00023	48 89 44 24 28	 mov	 QWORD PTR tv73[rsp], rax
  00028	48 8b 44 24 28	 mov	 rax, QWORD PTR tv73[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00034	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv73[rsp]
  00039	48 03 c8	 add	 rcx, rax
  0003c	48 8b c1	 mov	 rax, rcx
  0003f	48 8b c8	 mov	 rcx, rax
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00048	48 89 44 24 20	 mov	 QWORD PTR _Rdbuf$[rsp], rax

; 72   :             if (_Rdbuf) {

  0004d	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Rdbuf$[rsp], 0
  00053	74 10		 je	 SHORT $LN2@Sentry_bas

; 73   :                 _Rdbuf->_Lock();

  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR _Rdbuf$[rsp]
  0005a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Rdbuf$[rsp]
  00062	ff 50 08	 call	 QWORD PTR [rax+8]
$LN2@Sentry_bas:

; 74   :             }
; 75   :         }

  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0006a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006e	c3		 ret	 0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\EigenBase.h
;	COMDAT ?cols@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?cols@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::cols, COMDAT

; 63   :   inline Index cols() const EIGEN_NOEXCEPT { return derived().cols(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?derived@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$00$0?0$00$00$0?0@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::derived
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ?cols@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::cols
  0001b	90		 npad	 1
  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
?cols@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::cols
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\EigenBase.h
;	COMDAT ?rows@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?rows@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::rows, COMDAT

; 60   :   inline Index rows() const EIGEN_NOEXCEPT { return derived().rows(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?derived@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$00$0?0$00$00$0?0@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::derived
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ?rows@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::rows
  0001b	90		 npad	 1
  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
?rows@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::rows
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\EigenBase.h
;	COMDAT ?derived@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$00$0?0$00$00$0?0@2@XZ
_TEXT	SEGMENT
this$ = 8
?derived@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$00$0?0$00$00$0?0@2@XZ PROC ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::derived, COMDAT

; 46   :   Derived& derived() { return *static_cast<Derived*>(this); }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
?derived@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$00$0?0$00$00$0?0@2@XZ ENDP ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::derived
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseBase.h
;	COMDAT ??0?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@XZ PROC ; Eigen::DenseBase<Eigen::Matrix<double,28,28,0,28,28> >::DenseBase<Eigen::Matrix<double,28,28,0,28,28> >, COMDAT

; 681  :     EIGEN_DEVICE_FUNC DenseBase()

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 682  :     {
; 683  :       /* Just checks for self-consistency of the flags.
; 684  :        * Only do it when debugging Eigen, as this borders on paranoia and could slow compilation down
; 685  :        */
; 686  : #ifdef EIGEN_INTERNAL_DEBUGGING
; 687  :       EIGEN_STATIC_ASSERT((EIGEN_IMPLIES(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1, int(IsRowMajor))
; 688  :                         && EIGEN_IMPLIES(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1, int(!IsRowMajor))),
; 689  :                           INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION)
; 690  : #endif
; 691  :     }

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
??0?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@IEAA@XZ ENDP ; Eigen::DenseBase<Eigen::Matrix<double,28,28,0,28,28> >::DenseBase<Eigen::Matrix<double,28,28,0,28,28> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1386 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1387 :         return *this;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]

; 1388 :     }

  0000a	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1382 :     constexpr _Ty1& _Get_first() noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1383 :         return *this;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]

; 1384 :     }

  0000a	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
tv79 = 32
this$ = 64
_Right$ = 72
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT

; 4927 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4928 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR _Right$[rsp]
  0001d	48 8b d0	 mov	 rdx, rax
  00020	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv79[rsp]
  00025	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators

; 4929 :     }

  0002a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002e	c3		 ret	 0
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
_TEXT	SEGMENT
_My_data_mem$ = 32
_Right_data_mem$ = 40
this$ = 80
_Right$ = 88
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from, COMDAT

; 3088 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3089 :         _STL_INTERNAL_CHECK(_Can_memcpy_val);
; 3090 :         const auto _My_data_mem =

  00010	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00015	48 8b c8	 mov	 rcx, rax
  00018	e8 00 00 00 00	 call	 ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
  0001d	48 89 44 24 20	 mov	 QWORD PTR _My_data_mem$[rsp], rax

; 3091 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 3092 :         const auto _Right_data_mem =

  00022	48 8b 44 24 58	 mov	 rax, QWORD PTR _Right$[rsp]
  00027	48 8b c8	 mov	 rcx, rax
  0002a	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
  0002f	48 89 44 24 28	 mov	 QWORD PTR _Right_data_mem$[rsp], rax

; 3093 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 3094 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00034	48 8b 7c 24 20	 mov	 rdi, QWORD PTR _My_data_mem$[rsp]
  00039	48 8b 74 24 28	 mov	 rsi, QWORD PTR _Right_data_mem$[rsp]
  0003e	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00043	f3 a4		 rep movsb

; 3095 :     }

  00045	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00049	5f		 pop	 rdi
  0004a	5e		 pop	 rsi
  0004b	c3		 ret	 0
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 438  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {

  0000e	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00013	0f b6 c0	 movzx	 eax, al
  00016	85 c0		 test	 eax, eax
  00018	74 11		 je	 SHORT $LN2@assign

; 441  :             return _Primary_char_traits::assign(_Left, _Right);

  0001a	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Right$[rsp]
  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Left$[rsp]
  00024	e8 00 00 00 00	 call	 ?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Char_traits<char,int>::assign
  00029	eb 0f		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 442  :         }
; 443  : #endif // _HAS_CXX20
; 444  :         _Left = _Right;

  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR _Left$[rsp]
  00030	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Right$[rsp]
  00035	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00038	88 08		 mov	 BYTE PTR [rax], cl
$LN1@assign:

; 445  :     }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Ch$ = 64
?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 427  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

$LN4:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 428  :         // assign _Count * _Ch to [_First, ...)
; 429  : #if _HAS_CXX20
; 430  :         if (_STD is_constant_evaluated()) {

  00014	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00019	0f b6 c0	 movzx	 eax, al
  0001c	85 c0		 test	 eax, eax
  0001e	74 17		 je	 SHORT $LN2@assign

; 431  :             return _Primary_char_traits::assign(_First, _Count, _Ch);

  00020	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR _Ch$[rsp]
  00026	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Count$[rsp]
  0002b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _First$[rsp]
  00030	e8 00 00 00 00	 call	 ?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Char_traits<char,int>::assign
  00035	eb 18		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 432  :         }
; 433  : #endif // _HAS_CXX20
; 434  : 
; 435  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00037	0f be 44 24 40	 movsx	 eax, BYTE PTR _Ch$[rsp]
  0003c	48 98		 cdqe
  0003e	48 8b 7c 24 30	 mov	 rdi, QWORD PTR _First$[rsp]
  00043	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Count$[rsp]
  00048	f3 aa		 rep stosb
  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR _First$[rsp]
$LN1@assign:

; 436  :     }

  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5f		 pop	 rdi
  00054	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_Loop_forward$1 = 32
_Idx$2 = 40
_Idx$3 = 48
_Src$4 = 56
_First1$ = 80
_First2$ = 88
_Count$ = 96
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN16:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #if _HAS_CXX20
; 85   :         if (_STD is_constant_evaluated()) {

  00013	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	0f 84 f1 00 00
	00		 je	 $LN11@move

; 86   :             // dest: [_First1, _First1 + _Count)
; 87   :             // src: [_First2, _First2 + _Count)
; 88   :             // We need to handle overlapping ranges.
; 89   :             // If _First1 is in the src range, we need a backward loop.
; 90   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 91   : 
; 92   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 93   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 94   :             bool _Loop_forward = true;

  00023	c6 44 24 20 01	 mov	 BYTE PTR _Loop_forward$1[rsp], 1

; 95   : 
; 96   :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {

  00028	48 8b 44 24 58	 mov	 rax, QWORD PTR _First2$[rsp]
  0002d	48 89 44 24 38	 mov	 QWORD PTR _Src$4[rsp], rax
  00032	eb 0d		 jmp	 SHORT $LN4@move
$LN2@move:
  00034	48 8b 44 24 38	 mov	 rax, QWORD PTR _Src$4[rsp]
  00039	48 ff c0	 inc	 rax
  0003c	48 89 44 24 38	 mov	 QWORD PTR _Src$4[rsp], rax
$LN4@move:
  00041	48 8b 44 24 60	 mov	 rax, QWORD PTR _Count$[rsp]
  00046	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _First2$[rsp]
  0004b	48 03 c8	 add	 rcx, rax
  0004e	48 8b c1	 mov	 rax, rcx
  00051	48 39 44 24 38	 cmp	 QWORD PTR _Src$4[rsp], rax
  00056	74 15		 je	 SHORT $LN3@move

; 97   :                 if (_First1 == _Src) {

  00058	48 8b 44 24 38	 mov	 rax, QWORD PTR _Src$4[rsp]
  0005d	48 39 44 24 50	 cmp	 QWORD PTR _First1$[rsp], rax
  00062	75 07		 jne	 SHORT $LN12@move

; 98   :                     _Loop_forward = false;

  00064	c6 44 24 20 00	 mov	 BYTE PTR _Loop_forward$1[rsp], 0

; 99   :                     break;

  00069	eb 02		 jmp	 SHORT $LN3@move
$LN12@move:

; 100  :                 }
; 101  :             }

  0006b	eb c7		 jmp	 SHORT $LN2@move
$LN3@move:

; 102  : 
; 103  :             if (_Loop_forward) {

  0006d	0f b6 44 24 20	 movzx	 eax, BYTE PTR _Loop_forward$1[rsp]
  00072	85 c0		 test	 eax, eax
  00074	74 4d		 je	 SHORT $LN13@move

; 104  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {

  00076	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _Idx$2[rsp], 0
  0007f	eb 0d		 jmp	 SHORT $LN7@move
$LN5@move:
  00081	48 8b 44 24 28	 mov	 rax, QWORD PTR _Idx$2[rsp]
  00086	48 ff c0	 inc	 rax
  00089	48 89 44 24 28	 mov	 QWORD PTR _Idx$2[rsp], rax
$LN7@move:
  0008e	48 8b 44 24 60	 mov	 rax, QWORD PTR _Count$[rsp]
  00093	48 39 44 24 28	 cmp	 QWORD PTR _Idx$2[rsp], rax
  00098	74 27		 je	 SHORT $LN6@move

; 105  :                     _First1[_Idx] = _First2[_Idx];

  0009a	48 8b 44 24 28	 mov	 rax, QWORD PTR _Idx$2[rsp]
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _First1$[rsp]
  000a4	48 03 c8	 add	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Idx$2[rsp]
  000af	48 8b 54 24 58	 mov	 rdx, QWORD PTR _First2$[rsp]
  000b4	48 03 d1	 add	 rdx, rcx
  000b7	48 8b ca	 mov	 rcx, rdx
  000ba	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000bd	88 08		 mov	 BYTE PTR [rax], cl

; 106  :                 }

  000bf	eb c0		 jmp	 SHORT $LN5@move
$LN6@move:

; 107  :             } else {

  000c1	eb 4a		 jmp	 SHORT $LN14@move
$LN13@move:

; 108  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {

  000c3	48 8b 44 24 60	 mov	 rax, QWORD PTR _Count$[rsp]
  000c8	48 89 44 24 30	 mov	 QWORD PTR _Idx$3[rsp], rax
  000cd	eb 0d		 jmp	 SHORT $LN10@move
$LN8@move:
  000cf	48 8b 44 24 30	 mov	 rax, QWORD PTR _Idx$3[rsp]
  000d4	48 ff c8	 dec	 rax
  000d7	48 89 44 24 30	 mov	 QWORD PTR _Idx$3[rsp], rax
$LN10@move:
  000dc	48 83 7c 24 30
	00		 cmp	 QWORD PTR _Idx$3[rsp], 0
  000e2	74 29		 je	 SHORT $LN14@move

; 109  :                     _First1[_Idx - 1] = _First2[_Idx - 1];

  000e4	48 8b 44 24 30	 mov	 rax, QWORD PTR _Idx$3[rsp]
  000e9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _First1$[rsp]
  000ee	48 03 c8	 add	 rcx, rax
  000f1	48 8b c1	 mov	 rax, rcx
  000f4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Idx$3[rsp]
  000f9	48 8b 54 24 58	 mov	 rdx, QWORD PTR _First2$[rsp]
  000fe	48 03 d1	 add	 rdx, rcx
  00101	48 8b ca	 mov	 rcx, rdx
  00104	0f b6 49 ff	 movzx	 ecx, BYTE PTR [rcx-1]
  00108	88 48 ff	 mov	 BYTE PTR [rax-1], cl

; 110  :                 }

  0010b	eb c2		 jmp	 SHORT $LN8@move
$LN14@move:

; 111  :             }
; 112  : 
; 113  :             return _First1;

  0010d	48 8b 44 24 50	 mov	 rax, QWORD PTR _First1$[rsp]
  00112	eb 19		 jmp	 SHORT $LN1@move
$LN11@move:

; 114  :         }
; 115  : #endif // _HAS_CXX20
; 116  : 
; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00114	4c 8b 44 24 60	 mov	 r8, QWORD PTR _Count$[rsp]
  00119	48 8b 54 24 58	 mov	 rdx, QWORD PTR _First2$[rsp]
  0011e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _First1$[rsp]
  00123	e8 00 00 00 00	 call	 memmove

; 118  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 119  : 
; 120  :         return _First1;

  00128	48 8b 44 24 50	 mov	 rax, QWORD PTR _First1$[rsp]
$LN1@move:

; 121  :     }

  0012d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00131	c3		 ret	 0
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z
_TEXT	SEGMENT
tv85 = 32
tv91 = 40
this$ = 64
m$ = 72
??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z PROC ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >, COMDAT

; 197  :   {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00013	e8 00 00 00 00	 call	 ??0?$evaluator_base@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >::evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >
  00018	90		 npad	 1

; 196  :     : m_d(m.data(),IsVectorAtCompileTime ? 0 : m.outerStride())

  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001e	48 89 44 24 28	 mov	 QWORD PTR tv91[rsp], rax
  00023	33 c0		 xor	 eax, eax
  00025	83 f8 01	 cmp	 eax, 1
  00028	74 0b		 je	 SHORT $LN3@evaluator
  0002a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv85[rsp], 0
  00033	eb 0f		 jmp	 SHORT $LN4@evaluator
$LN3@evaluator:
  00035	48 8b 4c 24 48	 mov	 rcx, QWORD PTR m$[rsp]
  0003a	e8 00 00 00 00	 call	 ?outerStride@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$02@Eigen@@QEBA_JXZ ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,1,-1,1,1,-1>,3>::outerStride
  0003f	48 89 44 24 20	 mov	 QWORD PTR tv85[rsp], rax
$LN4@evaluator:
  00044	48 8b 4c 24 48	 mov	 rcx, QWORD PTR m$[rsp]
  00049	e8 00 00 00 00	 call	 ?data@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAPEBNXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::data
  0004e	4c 8b 44 24 20	 mov	 r8, QWORD PTR tv85[rsp]
  00053	48 8b d0	 mov	 rdx, rax
  00056	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv91[rsp]
  0005b	e8 00 00 00 00	 call	 ??0?$plainobjectbase_evaluator_data@N$0A@@internal@Eigen@@QEAA@PEBN_J@Z ; Eigen::internal::plainobjectbase_evaluator_data<double,0>::plainobjectbase_evaluator_data<double,0>
  00060	90		 npad	 1

; 198  :     EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
; 199  :   }

  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	c3		 ret	 0
??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z ENDP ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv85 = 32
tv91 = 40
this$ = 64
m$ = 72
?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z@4HA PROC ; `Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$evaluator_base@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >::~evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@2@@Z@4HA ENDP ; `Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ?cols@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?cols@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::cols, COMDAT

; 145  :     Index cols() const EIGEN_NOEXCEPT { return m_storage.cols(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?cols@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEBA_JXZ ; Eigen::DenseStorage<double,-1,1,-1,1>::cols
  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?cols@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::cols
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ?rows@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?rows@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::rows, COMDAT

; 143  :     Index rows() const EIGEN_NOEXCEPT { return m_storage.rows(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	e8 00 00 00 00	 call	 ?rows@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@SA_JXZ ; Eigen::DenseStorage<double,-1,1,-1,1>::rows
  0000e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00012	c3		 ret	 0
?rows@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::rows
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\EigenBase.h
;	COMDAT ?derived@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$00$0?0$00$00$0?0@2@XZ
_TEXT	SEGMENT
this$ = 8
?derived@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$00$0?0$00$00$0?0@2@XZ PROC ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::derived, COMDAT

; 49   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
?derived@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$00$0?0$00$00$0?0@2@XZ ENDP ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::derived
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z PROC	; std::_Char_traits<char,int>::assign, COMDAT

; 180  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 181  : #if _HAS_CXX20
; 182  :         if (_STD is_constant_evaluated()) {

  0000e	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00013	0f b6 c0	 movzx	 eax, al
  00016	85 c0		 test	 eax, eax
  00018	74 19		 je	 SHORT $LN2@assign

; 183  :             _STD construct_at(_STD addressof(_Left), _Right);

  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Left$[rsp]
  0001f	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPEADAEAD@Z ; std::addressof<char>
  00024	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Right$[rsp]
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??$construct_at@DAEBDX@std@@YAPEADQEADAEBD@Z ; std::construct_at<char,char const &,void>

; 184  :         } else

  00031	eb 0f		 jmp	 SHORT $LN3@assign
$LN2@assign:

; 185  : #endif // _HAS_CXX20
; 186  :         {
; 187  :             _Left = _Right;

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR _Left$[rsp]
  00038	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Right$[rsp]
  0003d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00040	88 08		 mov	 BYTE PTR [rax], cl
$LN3@assign:

; 188  :         }
; 189  :     }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z ENDP	; std::_Char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z
_TEXT	SEGMENT
_Next$1 = 32
_Next$2 = 40
_First$ = 64
_Count$ = 72
_Ch$ = 80
?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z PROC	; std::_Char_traits<char,int>::assign, COMDAT

; 162  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

$LN11:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 163  :         // assign _Count * _Ch to [_First, ...)
; 164  : #if _HAS_CXX20
; 165  :         if (_STD is_constant_evaluated()) {

  00013	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	74 41		 je	 SHORT $LN8@assign

; 166  :             for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {

  0001f	48 8b 44 24 40	 mov	 rax, QWORD PTR _First$[rsp]
  00024	48 89 44 24 20	 mov	 QWORD PTR _Next$1[rsp], rax
  00029	eb 1a		 jmp	 SHORT $LN4@assign
$LN2@assign:
  0002b	48 8b 44 24 48	 mov	 rax, QWORD PTR _Count$[rsp]
  00030	48 ff c8	 dec	 rax
  00033	48 89 44 24 48	 mov	 QWORD PTR _Count$[rsp], rax
  00038	48 8b 44 24 20	 mov	 rax, QWORD PTR _Next$1[rsp]
  0003d	48 ff c0	 inc	 rax
  00040	48 89 44 24 20	 mov	 QWORD PTR _Next$1[rsp], rax
$LN4@assign:
  00045	48 83 7c 24 48
	00		 cmp	 QWORD PTR _Count$[rsp], 0
  0004b	76 11		 jbe	 SHORT $LN3@assign

; 167  :                 _STD construct_at(_Next, _Ch);

  0004d	48 8d 54 24 50	 lea	 rdx, QWORD PTR _Ch$[rsp]
  00052	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Next$1[rsp]
  00057	e8 00 00 00 00	 call	 ??$construct_at@DAEBDX@std@@YAPEADQEADAEBD@Z ; std::construct_at<char,char const &,void>

; 168  :             }

  0005c	eb cd		 jmp	 SHORT $LN2@assign
$LN3@assign:

; 169  :         } else

  0005e	eb 3c		 jmp	 SHORT $LN9@assign
$LN8@assign:

; 170  : #endif // _HAS_CXX20
; 171  :         {
; 172  :             for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {

  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR _First$[rsp]
  00065	48 89 44 24 28	 mov	 QWORD PTR _Next$2[rsp], rax
  0006a	eb 1a		 jmp	 SHORT $LN7@assign
$LN5@assign:
  0006c	48 8b 44 24 48	 mov	 rax, QWORD PTR _Count$[rsp]
  00071	48 ff c8	 dec	 rax
  00074	48 89 44 24 48	 mov	 QWORD PTR _Count$[rsp], rax
  00079	48 8b 44 24 28	 mov	 rax, QWORD PTR _Next$2[rsp]
  0007e	48 ff c0	 inc	 rax
  00081	48 89 44 24 28	 mov	 QWORD PTR _Next$2[rsp], rax
$LN7@assign:
  00086	48 83 7c 24 48
	00		 cmp	 QWORD PTR _Count$[rsp], 0
  0008c	76 0e		 jbe	 SHORT $LN9@assign

; 173  :                 *_Next = _Ch;

  0008e	48 8b 44 24 28	 mov	 rax, QWORD PTR _Next$2[rsp]
  00093	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR _Ch$[rsp]
  00098	88 08		 mov	 BYTE PTR [rax], cl

; 174  :             }

  0009a	eb d0		 jmp	 SHORT $LN5@assign
$LN9@assign:

; 175  :         }
; 176  : 
; 177  :         return _First;

  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR _First$[rsp]

; 178  :     }

  000a1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a5	c3		 ret	 0
?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z ENDP	; std::_Char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ??0?$plainobjectbase_evaluator_data@N$0A@@internal@Eigen@@QEAA@PEBN_J@Z
_TEXT	SEGMENT
this$ = 48
ptr$ = 56
outerStride$ = 64
??0?$plainobjectbase_evaluator_data@N$0A@@internal@Eigen@@QEAA@PEBN_J@Z PROC ; Eigen::internal::plainobjectbase_evaluator_data<double,0>::plainobjectbase_evaluator_data<double,0>, COMDAT

; 140  :   {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 139  :   plainobjectbase_evaluator_data(const Scalar* ptr, Index outerStride) : data(ptr)

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ptr$[rsp]
  0001d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 141  : #ifndef EIGEN_INTERNAL_DEBUGGING
; 142  :     EIGEN_UNUSED_VARIABLE(outerStride);

  00020	48 8d 4c 24 40	 lea	 rcx, QWORD PTR outerStride$[rsp]
  00025	e8 00 00 00 00	 call	 ??$ignore_unused_variable@_J@internal@Eigen@@YAXAEB_J@Z ; Eigen::internal::ignore_unused_variable<__int64>

; 143  : #endif
; 144  :     eigen_internal_assert(outerStride==OuterStride);
; 145  :   }

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
??0?$plainobjectbase_evaluator_data@N$0A@@internal@Eigen@@QEAA@PEBN_J@Z ENDP ; Eigen::internal::plainobjectbase_evaluator_data<double,0>::plainobjectbase_evaluator_data<double,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ??0?$evaluator_base@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$evaluator_base@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ PROC ; Eigen::internal::evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >::evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >, COMDAT

; 121  :   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE evaluator_base() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
??0?$evaluator_base@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ENDP ; Eigen::internal::evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >::evaluator_base<Eigen::Matrix<double,1,-1,1,1,-1> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ?data@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAPEBNXZ
_TEXT	SEGMENT
this$ = 48
?data@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAPEBNXZ PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::data, COMDAT

; 248  :     { return m_storage.data(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?data@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEBAPEBNXZ ; Eigen::DenseStorage<double,-1,1,-1,1>::data
  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?data@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAPEBNXZ ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseStorage.h
;	COMDAT ?cols@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?cols@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEBA_JXZ PROC ; Eigen::DenseStorage<double,-1,1,-1,1>::cols, COMDAT

; 551  :     EIGEN_DEVICE_FUNC Index cols(void) const EIGEN_NOEXCEPT {return m_cols;}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0000e	c3		 ret	 0
?cols@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseStorage<double,-1,1,-1,1>::cols
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseStorage.h
;	COMDAT ?rows@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@SA_JXZ
_TEXT	SEGMENT
?rows@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@SA_JXZ PROC	; Eigen::DenseStorage<double,-1,1,-1,1>::rows, COMDAT

; 550  :     EIGEN_DEVICE_FUNC static EIGEN_CONSTEXPR Index rows(void) EIGEN_NOEXCEPT {return _Rows;}

  00000	b8 01 00 00 00	 mov	 eax, 1
  00005	c3		 ret	 0
?rows@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@SA_JXZ ENDP	; Eigen::DenseStorage<double,-1,1,-1,1>::rows
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseCoeffsBase.h
;	COMDAT ?outerStride@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$02@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?outerStride@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$02@Eigen@@QEBA_JXZ PROC ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,1,-1,1,1,-1>,3>::outerStride, COMDAT

; 586  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 587  :       return derived().outerStride();

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?derived@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$00$0?0$00$00$0?0@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::derived
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ?outerStride@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEBA_JXZ ; Eigen::Matrix<double,1,-1,1,1,-1>::outerStride
  0001b	90		 npad	 1

; 588  :     }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
?outerStride@?$DenseCoeffsBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@$02@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,1,-1,1,1,-1>,3>::outerStride
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\Matrix.h
;	COMDAT ?outerStride@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?outerStride@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEBA_JXZ PROC ; Eigen::Matrix<double,1,-1,1,1,-1>::outerStride, COMDAT

; 429  :     inline Index outerStride() const EIGEN_NOEXCEPT { return this->innerSize(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?innerSize@?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::DenseBase<Eigen::Matrix<double,1,-1,1,1,-1> >::innerSize
  00013	90		 npad	 1
  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
?outerStride@?$Matrix@N$00$0?0$00$00$0?0@Eigen@@QEBA_JXZ ENDP ; Eigen::Matrix<double,1,-1,1,1,-1>::outerStride
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseStorage.h
;	COMDAT ?data@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEBAPEBNXZ
_TEXT	SEGMENT
this$ = 8
?data@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEBAPEBNXZ PROC ; Eigen::DenseStorage<double,-1,1,-1,1>::data, COMDAT

; 570  :     EIGEN_DEVICE_FUNC const T *data() const { return m_data; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000d	c3		 ret	 0
?data@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEBAPEBNXZ ENDP ; Eigen::DenseStorage<double,-1,1,-1,1>::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseBase.h
;	COMDAT ?innerSize@?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
tv83 = 32
tv85 = 40
this$ = 64
?innerSize@?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::DenseBase<Eigen::Matrix<double,1,-1,1,1,-1> >::innerSize, COMDAT

; 236  :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 237  :       return IsVectorAtCompileTime ? this->size()

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	74 11		 je	 SHORT $LN5@innerSize
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00015	e8 00 00 00 00	 call	 ?size@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::size
  0001a	48 89 44 24 28	 mov	 QWORD PTR tv85[rsp], rax
  0001f	eb 31		 jmp	 SHORT $LN6@innerSize
$LN5@innerSize:
  00021	33 c0		 xor	 eax, eax
  00023	83 f8 01	 cmp	 eax, 1
  00026	74 11		 je	 SHORT $LN3@innerSize
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002d	e8 00 00 00 00	 call	 ?cols@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::cols
  00032	48 89 44 24 20	 mov	 QWORD PTR tv83[rsp], rax
  00037	eb 0f		 jmp	 SHORT $LN4@innerSize
$LN3@innerSize:
  00039	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003e	e8 00 00 00 00	 call	 ?rows@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::rows
  00043	48 89 44 24 20	 mov	 QWORD PTR tv83[rsp], rax
$LN4@innerSize:
  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR tv83[rsp]
  0004d	48 89 44 24 28	 mov	 QWORD PTR tv85[rsp], rax
$LN6@innerSize:
  00052	48 8b 44 24 28	 mov	 rax, QWORD PTR tv85[rsp]

; 238  :            : int(IsRowMajor) ? this->cols() : this->rows();
; 239  :     }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	c3		 ret	 0
?innerSize@?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseBase<Eigen::Matrix<double,1,-1,1,1,-1> >::innerSize
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__E?$fix@$00@Eigen@@YAXXZ
text$di	SEGMENT
??__E?$fix@$00@Eigen@@YAXXZ PROC			; `dynamic initializer for 'Eigen::$00::$fix'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??$fix@$00@Eigen@@3V?$FixedInt@$00@internal@1@B
  0000b	e8 00 00 00 00	 call	 ??0?$FixedInt@$00@internal@Eigen@@QEAA@XZ ; Eigen::internal::FixedInt<1>::FixedInt<1>
  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
??__E?$fix@$00@Eigen@@YAXXZ ENDP			; `dynamic initializer for 'Eigen::$00::$fix''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\SymbolicIndex.h
;	COMDAT ??$?H$00@?$BaseExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@@symbolic@Eigen@@QEBA?AV?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@12@V?$FixedInt@$00@internal@2@@Z
_TEXT	SEGMENT
$T1 = 32
tv75 = 40
tv73 = 48
this$ = 80
__$ReturnUdt$ = 88
__formal$ = 96
??$?H$00@?$BaseExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@@symbolic@Eigen@@QEBA?AV?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@12@V?$FixedInt@$00@internal@2@@Z PROC ; Eigen::symbolic::BaseExpr<Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag> >::operator+<1>, COMDAT

; 118  :   { return AddExpr<Derived,ValueExpr<internal::FixedInt<N> > >(derived(), ValueExpr<internal::FixedInt<N> >()); }

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00013	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00018	e8 00 00 00 00	 call	 ??0?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@symbolic@Eigen@@QEAA@XZ ; Eigen::symbolic::ValueExpr<Eigen::internal::FixedInt<1> >::ValueExpr<Eigen::internal::FixedInt<1> >
  0001d	48 89 44 24 28	 mov	 QWORD PTR tv75[rsp], rax
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00027	e8 00 00 00 00	 call	 ?derived@?$BaseExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@@symbolic@Eigen@@QEBAAEBV?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@23@XZ ; Eigen::symbolic::BaseExpr<Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag> >::derived
  0002c	48 89 44 24 30	 mov	 QWORD PTR tv73[rsp], rax
  00031	4c 8b 44 24 28	 mov	 r8, QWORD PTR tv75[rsp]
  00036	48 8b 54 24 30	 mov	 rdx, QWORD PTR tv73[rsp]
  0003b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  00040	e8 00 00 00 00	 call	 ??0?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@symbolic@Eigen@@QEAA@AEBV?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@12@AEBV?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@12@@Z ; Eigen::symbolic::AddExpr<Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag>,Eigen::symbolic::ValueExpr<Eigen::internal::FixedInt<1> > >::AddExpr<Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag>,Eigen::symbolic::ValueExpr<Eigen::internal::FixedInt<1> > >
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  0004a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004e	c3		 ret	 0
??$?H$00@?$BaseExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@@symbolic@Eigen@@QEBA?AV?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@12@V?$FixedInt@$00@internal@2@@Z ENDP ; Eigen::symbolic::BaseExpr<Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag> >::operator+<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\Matrix.h
;	COMDAT ??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBU?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBU?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z PROC ; Eigen::Matrix<double,-1,-1,0,-1,-1>::Matrix<double,-1,-1,0,-1,-1><Eigen::Matrix<double,28,28,0,28,28> >, COMDAT

; 424  :     { }

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 423  :       : Base(other.derived())

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR other$[rsp]
  00013	e8 00 00 00 00	 call	 ?derived@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::derived
  00018	48 8b d0	 mov	 rdx, rax
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00020	e8 00 00 00 00	 call	 ??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> ><Eigen::Matrix<double,28,28,0,28,28> >

; 424  :     { }

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBU?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z ENDP ; Eigen::Matrix<double,-1,-1,0,-1,-1>::Matrix<double,-1,-1,0,-1,-1><Eigen::Matrix<double,28,28,0,28,28> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\IO.h
;	COMDAT ??$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z
_TEXT	SEGMENT
tv94 = 80
tv150 = 88
tv142 = 96
tv140 = 104
$T8 = 112
$T6 = 120
$T5 = 152
$T4 = 184
$T3 = 216
$T2 = 248
$T1 = 280
$T7 = 320
s$ = 576
m$ = 584
??$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z PROC ; Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >, COMDAT

; 252  : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 38 02
	00 00		 sub	 rsp, 568		; 00000238H

; 253  :   return internal::print_matrix(s, m.eval(), EIGEN_DEFAULT_IO_FORMAT);

  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294967136
  00018	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR $T1[rsp]
  00020	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00025	90		 npad	 1
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294967135
  0002d	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR $T2[rsp]
  00035	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003a	90		 npad	 1
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294967134
  00042	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR $T3[rsp]
  0004a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0004f	90		 npad	 1
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294967133
  00057	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR $T4[rsp]
  0005f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00064	90		 npad	 1
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294967132
  0006c	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  00074	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00079	90		 npad	 1
  0007a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294967131
  00081	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T6[rsp]
  00086	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0008b	90		 npad	 1
  0008c	c6 44 24 48 20	 mov	 BYTE PTR [rsp+72], 32	; 00000020H
  00091	48 8d 84 24 18
	01 00 00	 lea	 rax, QWORD PTR $T1[rsp]
  00099	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0009e	48 8d 84 24 f8
	00 00 00	 lea	 rax, QWORD PTR $T2[rsp]
  000a6	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000ab	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR $T3[rsp]
  000b3	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000b8	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR $T4[rsp]
  000c0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000c5	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR $T5[rsp]
  000cd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d2	4c 8d 4c 24 78	 lea	 r9, QWORD PTR $T6[rsp]
  000d7	45 33 c0	 xor	 r8d, r8d
  000da	ba ff ff ff ff	 mov	 edx, -1
  000df	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  000e7	e8 00 00 00 00	 call	 ??0IOFormat@Eigen@@QEAA@HHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00000D@Z ; Eigen::IOFormat::IOFormat
  000ec	48 89 44 24 50	 mov	 QWORD PTR tv94[rsp], rax
  000f1	48 8b 44 24 50	 mov	 rax, QWORD PTR tv94[rsp]
  000f6	48 89 44 24 58	 mov	 QWORD PTR tv150[rsp], rax
  000fb	48 8b 44 24 58	 mov	 rax, QWORD PTR tv150[rsp]
  00100	48 89 44 24 60	 mov	 QWORD PTR tv142[rsp], rax
  00105	48 8b 8c 24 48
	02 00 00	 mov	 rcx, QWORD PTR m$[rsp]
  0010d	e8 00 00 00 00	 call	 ?eval@?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$00$0?0$00$00$0?0@2@XZ ; Eigen::DenseBase<Eigen::Matrix<double,1,-1,1,1,-1> >::eval
  00112	48 89 44 24 68	 mov	 QWORD PTR tv140[rsp], rax
  00117	4c 8b 44 24 60	 mov	 r8, QWORD PTR tv142[rsp]
  0011c	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv140[rsp]
  00121	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00129	e8 00 00 00 00	 call	 ??$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z ; Eigen::internal::print_matrix<Eigen::Matrix<double,1,-1,1,1,-1> >
  0012e	48 89 44 24 70	 mov	 QWORD PTR $T8[rsp], rax
  00133	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  0013b	e8 00 00 00 00	 call	 ??1IOFormat@Eigen@@QEAA@XZ
  00140	90		 npad	 1
  00141	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T6[rsp]
  00146	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0014b	90		 npad	 1
  0014c	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  00154	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00159	90		 npad	 1
  0015a	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR $T4[rsp]
  00162	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00167	90		 npad	 1
  00168	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR $T3[rsp]
  00170	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00175	90		 npad	 1
  00176	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR $T2[rsp]
  0017e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00183	90		 npad	 1
  00184	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR $T1[rsp]
  0018c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00191	48 8b 44 24 70	 mov	 rax, QWORD PTR $T8[rsp]

; 254  : }

  00196	48 81 c4 38 02
	00 00		 add	 rsp, 568		; 00000238H
  0019d	c3		 ret	 0
??$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z ENDP ; Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv94 = 80
tv150 = 88
tv142 = 96
tv140 = 104
$T8 = 112
$T6 = 120
$T5 = 152
$T4 = 184
$T3 = 216
$T2 = 248
$T1 = 280
$T7 = 320
s$ = 576
m$ = 584
?dtor$0@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA PROC ; `Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 18 01
	00 00		 lea	 rcx, QWORD PTR $T1[rbp]
  00010	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$0@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA ENDP ; `Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv94 = 80
tv150 = 88
tv142 = 96
tv140 = 104
$T8 = 112
$T6 = 120
$T5 = 152
$T4 = 184
$T3 = 216
$T2 = 248
$T1 = 280
$T7 = 320
s$ = 576
m$ = 584
?dtor$1@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA PROC ; `Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >'::`1'::dtor$1
  0001b	40 55		 push	 rbp
  0001d	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00021	48 8b ea	 mov	 rbp, rdx
  00024	48 8d 8d f8 00
	00 00		 lea	 rcx, QWORD PTR $T2[rbp]
  0002b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5d		 pop	 rbp
  00035	c3		 ret	 0
?dtor$1@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA ENDP ; `Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv94 = 80
tv150 = 88
tv142 = 96
tv140 = 104
$T8 = 112
$T6 = 120
$T5 = 152
$T4 = 184
$T3 = 216
$T2 = 248
$T1 = 280
$T7 = 320
s$ = 576
m$ = 584
?dtor$2@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA PROC ; `Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >'::`1'::dtor$2
  00036	40 55		 push	 rbp
  00038	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0003c	48 8b ea	 mov	 rbp, rdx
  0003f	48 8d 8d d8 00
	00 00		 lea	 rcx, QWORD PTR $T3[rbp]
  00046	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5d		 pop	 rbp
  00050	c3		 ret	 0
?dtor$2@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA ENDP ; `Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv94 = 80
tv150 = 88
tv142 = 96
tv140 = 104
$T8 = 112
$T6 = 120
$T5 = 152
$T4 = 184
$T3 = 216
$T2 = 248
$T1 = 280
$T7 = 320
s$ = 576
m$ = 584
?dtor$3@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA PROC ; `Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >'::`1'::dtor$3
  00051	40 55		 push	 rbp
  00053	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00057	48 8b ea	 mov	 rbp, rdx
  0005a	48 8d 8d b8 00
	00 00		 lea	 rcx, QWORD PTR $T4[rbp]
  00061	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00066	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006a	5d		 pop	 rbp
  0006b	c3		 ret	 0
?dtor$3@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA ENDP ; `Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv94 = 80
tv150 = 88
tv142 = 96
tv140 = 104
$T8 = 112
$T6 = 120
$T5 = 152
$T4 = 184
$T3 = 216
$T2 = 248
$T1 = 280
$T7 = 320
s$ = 576
m$ = 584
?dtor$4@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA PROC ; `Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >'::`1'::dtor$4
  0006c	40 55		 push	 rbp
  0006e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00072	48 8b ea	 mov	 rbp, rdx
  00075	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR $T5[rbp]
  0007c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00081	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00085	5d		 pop	 rbp
  00086	c3		 ret	 0
?dtor$4@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA ENDP ; `Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv94 = 80
tv150 = 88
tv142 = 96
tv140 = 104
$T8 = 112
$T6 = 120
$T5 = 152
$T4 = 184
$T3 = 216
$T2 = 248
$T1 = 280
$T7 = 320
s$ = 576
m$ = 584
?dtor$5@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA PROC ; `Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >'::`1'::dtor$5
  00087	40 55		 push	 rbp
  00089	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0008d	48 8b ea	 mov	 rbp, rdx
  00090	48 8d 4d 78	 lea	 rcx, QWORD PTR $T6[rbp]
  00094	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00099	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009d	5d		 pop	 rbp
  0009e	c3		 ret	 0
?dtor$5@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA ENDP ; `Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv94 = 80
tv150 = 88
tv142 = 96
tv140 = 104
$T8 = 112
$T6 = 120
$T5 = 152
$T4 = 184
$T3 = 216
$T2 = 248
$T1 = 280
$T7 = 320
s$ = 576
m$ = 584
?dtor$6@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA PROC ; `Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >'::`1'::dtor$6
  0009f	40 55		 push	 rbp
  000a1	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000a5	48 8b ea	 mov	 rbp, rdx
  000a8	48 8d 8d 40 01
	00 00		 lea	 rcx, QWORD PTR $T7[rbp]
  000af	e8 00 00 00 00	 call	 ??1IOFormat@Eigen@@QEAA@XZ
  000b4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b8	5d		 pop	 rbp
  000b9	c3		 ret	 0
?dtor$6@?0???$?6V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@0@@Z@4HA ENDP ; `Eigen::operator<<<Eigen::Matrix<double,1,-1,1,1,-1> >'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
_State$ = 32
tv311 = 36
tv192 = 37
tv316 = 38
tv254 = 39
_Pad$ = 40
_Count$ = 48
tv139 = 56
tv312 = 60
$T1 = 64
$T2 = 68
tv317 = 72
$T3 = 76
$T4 = 80
tv137 = 88
tv310 = 96
tv194 = 104
tv313 = 112
tv219 = 120
tv314 = 128
tv315 = 136
tv256 = 144
tv277 = 152
tv291 = 160
tv306 = 168
$T5 = 176
_Ok$ = 184
__$ArrayPad$ = 200
_Ostr$ = 224
_Val$ = 232
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 761  : basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 762  :     // insert NTBS into char stream
; 763  :     using _Elem = char;
; 764  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 765  : 
; 766  :     ios_base::iostate _State = ios_base::goodbit;

  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _State$[rsp], 0

; 767  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));

  0002b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR _Val$[rsp]
  00033	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
  00038	48 89 44 24 30	 mov	 QWORD PTR _Count$[rsp], rax

; 768  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  0003d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00045	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00048	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0004c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00054	48 03 c8	 add	 rcx, rax
  00057	48 8b c1	 mov	 rax, rcx
  0005a	48 8b c8	 mov	 rcx, rax
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  00063	48 85 c0	 test	 rax, rax
  00066	7e 5f		 jle	 SHORT $LN17@operator
  00068	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00070	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00073	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00077	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  0007f	48 03 c8	 add	 rcx, rax
  00082	48 8b c1	 mov	 rax, rcx
  00085	48 8b c8	 mov	 rcx, rax
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  0008e	48 3b 44 24 30	 cmp	 rax, QWORD PTR _Count$[rsp]
  00093	7e 32		 jle	 SHORT $LN17@operator
  00095	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  0009d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a0	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000a4	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  000bb	48 2b 44 24 30	 sub	 rax, QWORD PTR _Count$[rsp]
  000c0	48 89 44 24 58	 mov	 QWORD PTR tv137[rsp], rax
  000c5	eb 09		 jmp	 SHORT $LN18@operator
$LN17@operator:
  000c7	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv137[rsp], 0
$LN18@operator:
  000d0	48 8b 44 24 58	 mov	 rax, QWORD PTR tv137[rsp]
  000d5	48 89 44 24 28	 mov	 QWORD PTR _Pad$[rsp], rax

; 769  :     const typename _Myos::sentry _Ok(_Ostr);

  000da	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR _Ostr$[rsp]
  000e2	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR _Ok$[rsp]
  000ea	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  000ef	90		 npad	 1

; 770  : 
; 771  :     if (!_Ok) {

  000f0	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR _Ok$[rsp]
  000f8	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  000fd	0f b6 c0	 movzx	 eax, al
  00100	85 c0		 test	 eax, eax
  00102	75 10		 jne	 SHORT $LN8@operator

; 772  :         _State |= ios_base::badbit;

  00104	8b 44 24 20	 mov	 eax, DWORD PTR _State$[rsp]
  00108	83 c8 04	 or	 eax, 4
  0010b	89 44 24 20	 mov	 DWORD PTR _State$[rsp], eax

; 773  :     } else { // state okay, insert

  0010f	e9 a1 02 00 00	 jmp	 $LN9@operator
$LN8@operator:

; 774  :         _TRY_IO_BEGIN
; 775  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  00114	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  0011c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0011f	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00123	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  0012b	48 03 c8	 add	 rcx, rax
  0012e	48 8b c1	 mov	 rax, rcx
  00131	48 8b c8	 mov	 rcx, rax
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flags@ios_base@std@@QEBAHXZ
  0013a	89 44 24 38	 mov	 DWORD PTR tv139[rsp], eax
  0013e	8b 44 24 38	 mov	 eax, DWORD PTR tv139[rsp]
  00142	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00147	83 f8 40	 cmp	 eax, 64			; 00000040H
  0014a	0f 84 d0 00 00
	00		 je	 $LN11@operator

; 776  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00150	eb 0d		 jmp	 SHORT $LN4@operator
$LN2@operator:
  00152	48 8b 44 24 28	 mov	 rax, QWORD PTR _Pad$[rsp]
  00157	48 ff c8	 dec	 rax
  0015a	48 89 44 24 28	 mov	 QWORD PTR _Pad$[rsp], rax
$LN4@operator:
  0015f	48 83 7c 24 28
	00		 cmp	 QWORD PTR _Pad$[rsp], 0
  00165	0f 8e b5 00 00
	00		 jle	 $LN11@operator

; 777  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0016b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00173	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00176	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0017a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00182	48 03 c8	 add	 rcx, rax
  00185	48 8b c1	 mov	 rax, rcx
  00188	48 8b c8	 mov	 rcx, rax
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00191	48 89 44 24 60	 mov	 QWORD PTR tv310[rsp], rax
  00196	48 8b 44 24 60	 mov	 rax, QWORD PTR tv310[rsp]
  0019b	48 89 44 24 68	 mov	 QWORD PTR tv194[rsp], rax
  001a0	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  001a8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001ab	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  001af	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  001b7	48 03 c8	 add	 rcx, rax
  001ba	48 8b c1	 mov	 rax, rcx
  001bd	48 8b c8	 mov	 rcx, rax
  001c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
  001c6	88 44 24 24	 mov	 BYTE PTR tv311[rsp], al
  001ca	0f b6 44 24 24	 movzx	 eax, BYTE PTR tv311[rsp]
  001cf	88 44 24 25	 mov	 BYTE PTR tv192[rsp], al
  001d3	0f b6 54 24 25	 movzx	 edx, BYTE PTR tv192[rsp]
  001d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv194[rsp]
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  001e3	89 44 24 3c	 mov	 DWORD PTR tv312[rsp], eax
  001e7	8b 44 24 3c	 mov	 eax, DWORD PTR tv312[rsp]
  001eb	89 44 24 40	 mov	 DWORD PTR $T1[rsp], eax
  001ef	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  001f4	89 44 24 44	 mov	 DWORD PTR $T2[rsp], eax
  001f8	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T1[rsp]
  001fd	48 8d 4c 24 44	 lea	 rcx, QWORD PTR $T2[rsp]
  00202	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00207	0f b6 c0	 movzx	 eax, al
  0020a	85 c0		 test	 eax, eax
  0020c	74 0d		 je	 SHORT $LN12@operator

; 778  :                     _State |= ios_base::badbit; // insertion failed, quit

  0020e	8b 44 24 20	 mov	 eax, DWORD PTR _State$[rsp]
  00212	83 c8 04	 or	 eax, 4
  00215	89 44 24 20	 mov	 DWORD PTR _State$[rsp], eax

; 779  :                     break;

  00219	eb 05		 jmp	 SHORT $LN11@operator
$LN12@operator:

; 780  :                 }
; 781  :             }

  0021b	e9 32 ff ff ff	 jmp	 $LN2@operator
$LN11@operator:

; 782  :         }
; 783  : 
; 784  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  00220	83 7c 24 20 00	 cmp	 DWORD PTR _State$[rsp], 0
  00225	75 6f		 jne	 SHORT $LN13@operator
  00227	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  0022f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00232	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00236	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  0023e	48 03 c8	 add	 rcx, rax
  00241	48 8b c1	 mov	 rax, rcx
  00244	48 8b c8	 mov	 rcx, rax
  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0024d	48 89 44 24 70	 mov	 QWORD PTR tv313[rsp], rax
  00252	48 8b 44 24 70	 mov	 rax, QWORD PTR tv313[rsp]
  00257	48 89 44 24 78	 mov	 QWORD PTR tv219[rsp], rax
  0025c	4c 8b 44 24 30	 mov	 r8, QWORD PTR _Count$[rsp]
  00261	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR _Val$[rsp]
  00269	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv219[rsp]
  0026e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
  00274	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv314[rsp], rax
  0027c	48 8b 44 24 30	 mov	 rax, QWORD PTR _Count$[rsp]
  00281	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR tv314[rsp], rax
  00289	74 0b		 je	 SHORT $LN13@operator

; 785  :             _State |= ios_base::badbit;

  0028b	8b 44 24 20	 mov	 eax, DWORD PTR _State$[rsp]
  0028f	83 c8 04	 or	 eax, 4
  00292	89 44 24 20	 mov	 DWORD PTR _State$[rsp], eax
$LN13@operator:

; 786  :         }
; 787  : 
; 788  :         if (_State == ios_base::goodbit) {

  00296	83 7c 24 20 00	 cmp	 DWORD PTR _State$[rsp], 0
  0029b	0f 85 dc 00 00
	00		 jne	 $LN14@operator

; 789  :             for (; 0 < _Pad; --_Pad) { // pad on right

  002a1	eb 0d		 jmp	 SHORT $LN7@operator
$LN5@operator:
  002a3	48 8b 44 24 28	 mov	 rax, QWORD PTR _Pad$[rsp]
  002a8	48 ff c8	 dec	 rax
  002ab	48 89 44 24 28	 mov	 QWORD PTR _Pad$[rsp], rax
$LN7@operator:
  002b0	48 83 7c 24 28
	00		 cmp	 QWORD PTR _Pad$[rsp], 0
  002b6	0f 8e c1 00 00
	00		 jle	 $LN14@operator

; 790  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  002bc	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  002c4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002c7	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  002cb	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  002d3	48 03 c8	 add	 rcx, rax
  002d6	48 8b c1	 mov	 rax, rcx
  002d9	48 8b c8	 mov	 rcx, rax
  002dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  002e2	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv315[rsp], rax
  002ea	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv315[rsp]
  002f2	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv256[rsp], rax
  002fa	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00302	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00305	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00309	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00311	48 03 c8	 add	 rcx, rax
  00314	48 8b c1	 mov	 rax, rcx
  00317	48 8b c8	 mov	 rcx, rax
  0031a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
  00320	88 44 24 26	 mov	 BYTE PTR tv316[rsp], al
  00324	0f b6 44 24 26	 movzx	 eax, BYTE PTR tv316[rsp]
  00329	88 44 24 27	 mov	 BYTE PTR tv254[rsp], al
  0032d	0f b6 54 24 27	 movzx	 edx, BYTE PTR tv254[rsp]
  00332	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv256[rsp]
  0033a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  00340	89 44 24 48	 mov	 DWORD PTR tv317[rsp], eax
  00344	8b 44 24 48	 mov	 eax, DWORD PTR tv317[rsp]
  00348	89 44 24 4c	 mov	 DWORD PTR $T3[rsp], eax
  0034c	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00351	89 44 24 50	 mov	 DWORD PTR $T4[rsp], eax
  00355	48 8d 54 24 4c	 lea	 rdx, QWORD PTR $T3[rsp]
  0035a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  0035f	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00364	0f b6 c0	 movzx	 eax, al
  00367	85 c0		 test	 eax, eax
  00369	74 0d		 je	 SHORT $LN15@operator

; 791  :                     _State |= ios_base::badbit; // insertion failed, quit

  0036b	8b 44 24 20	 mov	 eax, DWORD PTR _State$[rsp]
  0036f	83 c8 04	 or	 eax, 4
  00372	89 44 24 20	 mov	 DWORD PTR _State$[rsp], eax

; 792  :                     break;

  00376	eb 05		 jmp	 SHORT $LN14@operator
$LN15@operator:

; 793  :                 }
; 794  :             }

  00378	e9 26 ff ff ff	 jmp	 $LN5@operator
$LN14@operator:

; 795  :         }
; 796  : 
; 797  :         _Ostr.width(0);

  0037d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00385	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00388	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0038c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00394	48 03 c8	 add	 rcx, rax
  00397	48 8b c1	 mov	 rax, rcx
  0039a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv277[rsp], rax
  003a2	33 d2		 xor	 edx, edx
  003a4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv277[rsp]
  003ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEAA_J_J@Z
  003b2	90		 npad	 1
  003b3	eb 00		 jmp	 SHORT $LN9@operator
$LN23@operator:
$LN9@operator:

; 798  :         _CATCH_IO_(ios_base, _Ostr)
; 799  :     }
; 800  : 
; 801  :     _Ostr.setstate(_State);

  003b5	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  003bd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003c0	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  003c4	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  003cc	48 03 c8	 add	 rcx, rax
  003cf	48 8b c1	 mov	 rax, rcx
  003d2	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv306[rsp], rax
  003da	45 33 c0	 xor	 r8d, r8d
  003dd	8b 54 24 20	 mov	 edx, DWORD PTR _State$[rsp]
  003e1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv306[rsp]
  003e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 802  :     return _Ostr;

  003ef	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  003f7	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR $T5[rsp], rax
  003ff	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR _Ok$[rsp]
  00407	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  0040c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR $T5[rsp]

; 803  : }

  00414	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0041c	48 33 cc	 xor	 rcx, rsp
  0041f	e8 00 00 00 00	 call	 __security_check_cookie
  00424	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0042b	c3		 ret	 0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv311 = 36
tv192 = 37
tv316 = 38
tv254 = 39
_Pad$ = 40
_Count$ = 48
tv139 = 56
tv312 = 60
$T1 = 64
$T2 = 68
tv317 = 72
$T3 = 76
$T4 = 80
tv137 = 88
tv310 = 96
tv194 = 104
tv313 = 112
tv219 = 120
tv314 = 128
tv315 = 136
tv256 = 144
tv277 = 152
tv291 = 160
tv306 = 168
$T5 = 176
_Ok$ = 184
__$ArrayPad$ = 200
_Ostr$ = 224
_Val$ = 232
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d b8 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rbp]
  00010	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv311 = 36
tv192 = 37
tv316 = 38
tv254 = 39
_Pad$ = 40
_Count$ = 48
tv139 = 56
tv312 = 60
$T1 = 64
$T2 = 68
tv317 = 72
$T3 = 76
$T4 = 80
tv137 = 88
tv310 = 96
tv194 = 104
tv313 = 112
tv219 = 120
tv314 = 128
tv315 = 136
tv256 = 144
tv277 = 152
tv291 = 160
tv306 = 168
$T5 = 176
_Ok$ = 184
__$ArrayPad$ = 200
_Ostr$ = 224
_Val$ = 232
?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$1

; 798  :         _CATCH_IO_(ios_base, _Ostr)

  0001b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00020	55		 push	 rbp
  00021	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00025	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  0002f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00032	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00036	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  0003d	48 03 c8	 add	 rcx, rax
  00040	48 8b c1	 mov	 rax, rcx
  00043	48 89 85 a0 00
	00 00		 mov	 QWORD PTR tv291[rbp], rax
  0004a	41 b0 01	 mov	 r8b, 1
  0004d	ba 04 00 00 00	 mov	 edx, 4
  00052	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR tv291[rbp]
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0005f	90		 npad	 1
  00060	48 8d 05 00 00
	00 00		 lea	 rax, $LN23@catch$1
  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5d		 pop	 rbp
  0006c	c3		 ret	 0
  0006d	cc		 int	 3
?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\Memory.h
;	COMDAT ??$conditional_aligned_delete_auto@N$00@internal@Eigen@@YAXPEAN_K@Z
_TEXT	SEGMENT
ptr$ = 48
size$ = 56
??$conditional_aligned_delete_auto@N$00@internal@Eigen@@YAXPEAN_K@Z PROC ; Eigen::internal::conditional_aligned_delete_auto<double,1>, COMDAT

; 443  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 444  :   if(NumTraits<T>::RequireInitialization)

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	74 0f		 je	 SHORT $LN2@conditiona

; 445  :     destruct_elements_of_array<T>(ptr, size);

  00014	48 8b 54 24 38	 mov	 rdx, QWORD PTR size$[rsp]
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$[rsp]
  0001e	e8 00 00 00 00	 call	 ??$destruct_elements_of_array@N@internal@Eigen@@YAXPEAN_K@Z ; Eigen::internal::destruct_elements_of_array<double>
$LN2@conditiona:

; 446  :   conditional_aligned_free<Align>(ptr);

  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$[rsp]
  00028	e8 00 00 00 00	 call	 ??$conditional_aligned_free@$00@internal@Eigen@@YAXPEAX@Z ; Eigen::internal::conditional_aligned_free<1>

; 447  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
??$conditional_aligned_delete_auto@N$00@internal@Eigen@@YAXPEAN_K@Z ENDP ; Eigen::internal::conditional_aligned_delete_auto<double,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\utility
;	COMDAT ??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z PROC		; std::max<char *>, COMDAT

; 41   :     (max) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 42   :     // return larger of _Left and _Right
; 43   :     return _Left < _Right ? _Right : _Left;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR _Left$[rsp]
  00013	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Right$[rsp]
  00018	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001e	73 0b		 jae	 SHORT $LN3@max
  00020	48 8b 44 24 28	 mov	 rax, QWORD PTR _Right$[rsp]
  00025	48 89 04 24	 mov	 QWORD PTR tv65[rsp], rax
  00029	eb 09		 jmp	 SHORT $LN4@max
$LN3@max:
  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR _Left$[rsp]
  00030	48 89 04 24	 mov	 QWORD PTR tv65[rsp], rax
$LN4@max:
  00034	48 8b 04 24	 mov	 rax, QWORD PTR tv65[rsp]
  00038	48 89 44 24 08	 mov	 QWORD PTR $T1[rsp], rax
  0003d	48 8b 44 24 08	 mov	 rax, QWORD PTR $T1[rsp]

; 44   : }

  00042	48 83 c4 18	 add	 rsp, 24
  00046	c3		 ret	 0
??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z ENDP		; std::max<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 265  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 266  :     return _Ptr;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Ptr$[rsp]

; 267  : }

  0000a	c3		 ret	 0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 64   :     (min) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 65   :     // return smaller of _Left and _Right
; 66   :     return _Right < _Left ? _Right : _Left;

  0000e	48 8b 44 24 28	 mov	 rax, QWORD PTR _Right$[rsp]
  00013	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Left$[rsp]
  00018	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001e	73 0b		 jae	 SHORT $LN3@min
  00020	48 8b 44 24 28	 mov	 rax, QWORD PTR _Right$[rsp]
  00025	48 89 04 24	 mov	 QWORD PTR tv65[rsp], rax
  00029	eb 09		 jmp	 SHORT $LN4@min
$LN3@min:
  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR _Left$[rsp]
  00030	48 89 04 24	 mov	 QWORD PTR tv65[rsp], rax
$LN4@min:
  00034	48 8b 04 24	 mov	 rax, QWORD PTR tv65[rsp]
  00038	48 89 44 24 08	 mov	 QWORD PTR $T1[rsp], rax
  0003d	48 8b 44 24 08	 mov	 rax, QWORD PTR $T1[rsp]

; 67   : }

  00042	48 83 c4 18	 add	 rsp, 24
  00046	c3		 ret	 0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Convert_size@_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K@std@@YA_K_K@Z PROC			; std::_Convert_size<unsigned __int64>, COMDAT

; 965  : _NODISCARD constexpr _Size_type _Convert_size(const size_t _Len) noexcept(is_same_v<_Size_type, size_t>) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 966  :     // convert size_t to _Size_type, avoiding truncation
; 967  :     if constexpr (!is_same_v<_Size_type, size_t>) {
; 968  :         if (_Len > (numeric_limits<_Size_type>::max)()) {
; 969  :             _Xlength_error("size_t too long for _Size_type");
; 970  :         }
; 971  :     }
; 972  : 
; 973  :     return static_cast<_Size_type>(_Len);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Len$[rsp]

; 974  : }

  0000a	c3		 ret	 0
??$_Convert_size@_K@std@@YA_K_K@Z ENDP			; std::_Convert_size<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1422 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1423 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1424 : }

  0000a	c3		 ret	 0
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT

; 1380 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Val1$[rsp]
  00017	e8 00 00 00 00	 call	 ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT

; 1375 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QEAA@XZ ; std::allocator<char>::allocator<char>
  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
tv86 = 32
_Stay_small$ = 33
$T1 = 34
$T2 = 35
_My_data$ = 40
_New_capacity$ = 48
_Alproxy$ = 56
_Al$ = 64
tv164 = 72
_New_ptr$ = 80
_Proxy$ = 88
__$ArrayPad$ = 96
this$ = 128
_Arg$ = 136
_Count$ = 144
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT

; 2672 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN10:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2673 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2674 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2675 :         } else {
; 2676 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2677 :         }
; 2678 : 
; 2679 :         if (_Count > max_size()) {

  00022	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0002a	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0002f	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR _Count$[rsp], rax
  00037	76 05		 jbe	 SHORT $LN2@Construct

; 2680 :             _Xlen_string(); // result too long

  00039	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Construct:

; 2681 :         }
; 2682 : 
; 2683 :         auto& _My_data  = _Mypair._Myval2;

  0003e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00046	48 89 44 24 28	 mov	 QWORD PTR _My_data$[rsp], rax

; 2684 :         auto& _Al       = _Getal();

  0004b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00053	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00058	48 89 44 24 40	 mov	 QWORD PTR _Al$[rsp], rax

; 2685 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

  0005d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
  00064	48 89 44 24 38	 mov	 QWORD PTR _Alproxy$[rsp], rax

; 2686 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  00069	4c 8b 44 24 28	 mov	 r8, QWORD PTR _My_data$[rsp]
  0006e	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Alproxy$[rsp]
  00073	48 8d 4c 24 58	 lea	 rcx, QWORD PTR _Proxy$[rsp]
  00078	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 2687 : 
; 2688 : #if _HAS_CXX20
; 2689 :         if (_STD is_constant_evaluated()) {

  0007d	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00082	0f b6 c0	 movzx	 eax, al
  00085	85 c0		 test	 eax, eax
  00087	74 0d		 je	 SHORT $LN3@Construct

; 2690 :             _My_data._Myres = _BUF_SIZE; // TRANSITION: constexpr SSO

  00089	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  0008e	48 c7 40 18 10
	00 00 00	 mov	 QWORD PTR [rax+24], 16
$LN3@Construct:

; 2691 :         }
; 2692 : 
; 2693 :         const bool _Stay_small = _Count < _BUF_SIZE && !_STD is_constant_evaluated();

  00096	48 83 bc 24 90
	00 00 00 10	 cmp	 QWORD PTR _Count$[rsp], 16
  0009f	73 13		 jae	 SHORT $LN8@Construct
  000a1	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  000a6	0f b6 c0	 movzx	 eax, al
  000a9	85 c0		 test	 eax, eax
  000ab	75 07		 jne	 SHORT $LN8@Construct
  000ad	c6 44 24 20 01	 mov	 BYTE PTR tv86[rsp], 1
  000b2	eb 05		 jmp	 SHORT $LN9@Construct
$LN8@Construct:
  000b4	c6 44 24 20 00	 mov	 BYTE PTR tv86[rsp], 0
$LN9@Construct:
  000b9	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv86[rsp]
  000be	88 44 24 21	 mov	 BYTE PTR _Stay_small$[rsp], al

; 2694 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 2695 :         const bool _Stay_small = _Count < _BUF_SIZE;
; 2696 : #endif // _HAS_CXX20
; 2697 : 
; 2698 :         if (_Stay_small) {

  000c2	0f b6 44 24 21	 movzx	 eax, BYTE PTR _Stay_small$[rsp]
  000c7	85 c0		 test	 eax, eax
  000c9	0f 84 88 00 00
	00		 je	 $LN4@Construct

; 2699 : #if _HAS_CXX20
; 2700 :             // TRANSITION: This is currently unused until SSO support is merged
; 2701 :             if (_STD is_constant_evaluated()) {

  000cf	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  000d4	0f b6 c0	 movzx	 eax, al
  000d7	85 c0		 test	 eax, eax
  000d9	74 0d		 je	 SHORT $LN5@Construct

; 2702 :                 _Construct_in_place(_My_data._Bx);

  000db	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  000e0	48 8b c8	 mov	 rcx, rax
  000e3	e8 00 00 00 00	 call	 ??$_Construct_in_place@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$V@std@@YAXAEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@@Z ; std::_Construct_in_place<std::_String_val<std::_Simple_types<char> >::_Bxty>
$LN5@Construct:

; 2703 :             }
; 2704 : #endif // _HAS_CXX20
; 2705 : 
; 2706 :             _My_data._Mysize = _Count;

  000e8	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  000ed	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _Count$[rsp]
  000f5	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 2707 :             _My_data._Myres  = _BUF_SIZE - 1;

  000f9	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  000fe	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15

; 2708 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2709 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2710 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2711 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2712 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);

  00106	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  0010b	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR _Count$[rsp]
  00113	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR _Arg$[rsp]
  0011b	48 8b c8	 mov	 rcx, rax
  0011e	e8 00 00 00 00	 call	 ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 2713 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00123	c6 44 24 22 00	 mov	 BYTE PTR $T1[rsp], 0
  00128	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR _Count$[rsp]
  00130	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _My_data$[rsp]
  00135	48 03 c8	 add	 rcx, rax
  00138	48 8b c1	 mov	 rax, rcx
  0013b	48 8d 54 24 22	 lea	 rdx, QWORD PTR $T1[rsp]
  00140	48 8b c8	 mov	 rcx, rax
  00143	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2714 :             } else { // _Strat == _Construct_strategy::_From_string
; 2715 : #ifdef _INSERT_STRING_ANNOTATION
; 2716 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);
; 2717 : #else // ^^^ _INSERT_STRING_ANNOTATION ^^^ // vvv !_INSERT_STRING_ANNOTATION vvv
; 2718 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2719 : #endif // !_INSERT_STRING_ANNOTATION
; 2720 :             }
; 2721 : 
; 2722 :             _ASAN_STRING_CREATE(*this);
; 2723 :             _Proxy._Release();

  00148	48 8d 4c 24 58	 lea	 rcx, QWORD PTR _Proxy$[rsp]
  0014d	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release

; 2724 :             return;

  00152	e9 04 01 00 00	 jmp	 $LN1@Construct
$LN4@Construct:

; 2725 :         }
; 2726 : 
; 2727 :         _My_data._Myres               = _BUF_SIZE - 1;

  00157	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  0015c	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15

; 2728 :         const size_type _New_capacity = _Calculate_growth(_Count);

  00164	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR _Count$[rsp]
  0016c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00174	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00179	48 89 44 24 30	 mov	 QWORD PTR _New_capacity$[rsp], rax

; 2729 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0017e	48 8b 44 24 30	 mov	 rax, QWORD PTR _New_capacity$[rsp]
  00183	48 83 c0 01	 add	 rax, 1
  00187	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  0018e	48 0f 42 c1	 cmovb	 rax, rcx
  00192	48 8b d0	 mov	 rdx, rax
  00195	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Al$[rsp]
  0019a	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
  0019f	48 89 44 24 50	 mov	 QWORD PTR _New_ptr$[rsp], rax

; 2730 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  001a4	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  001a9	48 8d 54 24 50	 lea	 rdx, QWORD PTR _New_ptr$[rsp]
  001ae	48 8b c8	 mov	 rcx, rax
  001b1	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2731 : 
; 2732 : #if _HAS_CXX20
; 2733 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB

  001b6	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  001bb	0f b6 c0	 movzx	 eax, al
  001be	85 c0		 test	 eax, eax
  001c0	74 2a		 je	 SHORT $LN6@Construct

; 2734 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());

  001c2	48 8b 44 24 30	 mov	 rax, QWORD PTR _New_capacity$[rsp]
  001c7	48 ff c0	 inc	 rax
  001ca	48 89 44 24 48	 mov	 QWORD PTR tv164[rsp], rax
  001cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  001d4	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  001d9	45 33 c0	 xor	 r8d, r8d
  001dc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv164[rsp]
  001e1	48 8b d1	 mov	 rdx, rcx
  001e4	48 8b c8	 mov	 rcx, rax
  001e7	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign
$LN6@Construct:

; 2735 :         }
; 2736 : #endif // _HAS_CXX20
; 2737 : 
; 2738 :         _My_data._Mysize = _Count;

  001ec	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  001f1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _Count$[rsp]
  001f9	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 2739 :         _My_data._Myres  = _New_capacity;

  001fd	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00202	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _New_capacity$[rsp]
  00207	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2740 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2741 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2742 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2743 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2744 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

  0020b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  00210	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00215	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR _Count$[rsp]
  0021d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR _Arg$[rsp]
  00225	48 8b c8	 mov	 rcx, rax
  00228	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 2745 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  0022d	c6 44 24 23 00	 mov	 BYTE PTR $T2[rsp], 0
  00232	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  00237	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  0023c	48 03 84 24 90
	00 00 00	 add	 rax, QWORD PTR _Count$[rsp]
  00244	48 8d 54 24 23	 lea	 rdx, QWORD PTR $T2[rsp]
  00249	48 8b c8	 mov	 rcx, rax
  0024c	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2746 :         } else { // _Strat == _Construct_strategy::_From_string
; 2747 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2748 :         }
; 2749 : 
; 2750 :         _ASAN_STRING_CREATE(*this);
; 2751 :         _Proxy._Release();

  00251	48 8d 4c 24 58	 lea	 rcx, QWORD PTR _Proxy$[rsp]
  00256	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
$LN1@Construct:
$LN7@Construct:

; 2752 :     }

  0025b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00260	48 33 cc	 xor	 rcx, rsp
  00263	e8 00 00 00 00	 call	 __security_check_cookie
  00268	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0026c	c3		 ret	 0
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
tv86 = 32
_Stay_small$ = 33
_My_data$ = 40
_New_capacity$ = 48
_Alproxy$ = 56
_Al$ = 64
tv158 = 72
tv165 = 80
_New_ptr$ = 88
_Proxy$ = 96
__$ArrayPad$ = 104
this$ = 128
_Arg$ = 136
_Count$ = 144
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>, COMDAT

; 2672 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN10:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2673 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2674 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2675 :         } else {
; 2676 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2677 :         }
; 2678 : 
; 2679 :         if (_Count > max_size()) {

  00022	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0002a	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0002f	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR _Count$[rsp], rax
  00037	76 05		 jbe	 SHORT $LN2@Construct

; 2680 :             _Xlen_string(); // result too long

  00039	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Construct:

; 2681 :         }
; 2682 : 
; 2683 :         auto& _My_data  = _Mypair._Myval2;

  0003e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00046	48 89 44 24 28	 mov	 QWORD PTR _My_data$[rsp], rax

; 2684 :         auto& _Al       = _Getal();

  0004b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00053	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00058	48 89 44 24 40	 mov	 QWORD PTR _Al$[rsp], rax

; 2685 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

  0005d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
  00064	48 89 44 24 38	 mov	 QWORD PTR _Alproxy$[rsp], rax

; 2686 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  00069	4c 8b 44 24 28	 mov	 r8, QWORD PTR _My_data$[rsp]
  0006e	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Alproxy$[rsp]
  00073	48 8d 4c 24 60	 lea	 rcx, QWORD PTR _Proxy$[rsp]
  00078	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 2687 : 
; 2688 : #if _HAS_CXX20
; 2689 :         if (_STD is_constant_evaluated()) {

  0007d	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00082	0f b6 c0	 movzx	 eax, al
  00085	85 c0		 test	 eax, eax
  00087	74 0d		 je	 SHORT $LN3@Construct

; 2690 :             _My_data._Myres = _BUF_SIZE; // TRANSITION: constexpr SSO

  00089	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  0008e	48 c7 40 18 10
	00 00 00	 mov	 QWORD PTR [rax+24], 16
$LN3@Construct:

; 2691 :         }
; 2692 : 
; 2693 :         const bool _Stay_small = _Count < _BUF_SIZE && !_STD is_constant_evaluated();

  00096	48 83 bc 24 90
	00 00 00 10	 cmp	 QWORD PTR _Count$[rsp], 16
  0009f	73 13		 jae	 SHORT $LN8@Construct
  000a1	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  000a6	0f b6 c0	 movzx	 eax, al
  000a9	85 c0		 test	 eax, eax
  000ab	75 07		 jne	 SHORT $LN8@Construct
  000ad	c6 44 24 20 01	 mov	 BYTE PTR tv86[rsp], 1
  000b2	eb 05		 jmp	 SHORT $LN9@Construct
$LN8@Construct:
  000b4	c6 44 24 20 00	 mov	 BYTE PTR tv86[rsp], 0
$LN9@Construct:
  000b9	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv86[rsp]
  000be	88 44 24 21	 mov	 BYTE PTR _Stay_small$[rsp], al

; 2694 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 2695 :         const bool _Stay_small = _Count < _BUF_SIZE;
; 2696 : #endif // _HAS_CXX20
; 2697 : 
; 2698 :         if (_Stay_small) {

  000c2	0f b6 44 24 21	 movzx	 eax, BYTE PTR _Stay_small$[rsp]
  000c7	85 c0		 test	 eax, eax
  000c9	74 61		 je	 SHORT $LN4@Construct

; 2699 : #if _HAS_CXX20
; 2700 :             // TRANSITION: This is currently unused until SSO support is merged
; 2701 :             if (_STD is_constant_evaluated()) {

  000cb	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  000d0	0f b6 c0	 movzx	 eax, al
  000d3	85 c0		 test	 eax, eax
  000d5	74 0d		 je	 SHORT $LN5@Construct

; 2702 :                 _Construct_in_place(_My_data._Bx);

  000d7	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  000dc	48 8b c8	 mov	 rcx, rax
  000df	e8 00 00 00 00	 call	 ??$_Construct_in_place@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$V@std@@YAXAEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@@Z ; std::_Construct_in_place<std::_String_val<std::_Simple_types<char> >::_Bxty>
$LN5@Construct:

; 2703 :             }
; 2704 : #endif // _HAS_CXX20
; 2705 : 
; 2706 :             _My_data._Mysize = _Count;

  000e4	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  000e9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _Count$[rsp]
  000f1	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 2707 :             _My_data._Myres  = _BUF_SIZE - 1;

  000f5	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  000fa	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15

; 2708 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2709 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2710 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2711 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2712 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);
; 2713 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2714 :             } else { // _Strat == _Construct_strategy::_From_string
; 2715 : #ifdef _INSERT_STRING_ANNOTATION
; 2716 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);
; 2717 : #else // ^^^ _INSERT_STRING_ANNOTATION ^^^ // vvv !_INSERT_STRING_ANNOTATION vvv
; 2718 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _BUF_SIZE);

  00102	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00107	41 b8 10 00 00
	00		 mov	 r8d, 16
  0010d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR _Arg$[rsp]
  00115	48 8b c8	 mov	 rcx, rax
  00118	e8 00 00 00 00	 call	 ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 2719 : #endif // !_INSERT_STRING_ANNOTATION
; 2720 :             }
; 2721 : 
; 2722 :             _ASAN_STRING_CREATE(*this);
; 2723 :             _Proxy._Release();

  0011d	48 8d 4c 24 60	 lea	 rcx, QWORD PTR _Proxy$[rsp]
  00122	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release

; 2724 :             return;

  00127	e9 f0 00 00 00	 jmp	 $LN1@Construct
$LN4@Construct:

; 2725 :         }
; 2726 : 
; 2727 :         _My_data._Myres               = _BUF_SIZE - 1;

  0012c	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  00131	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15

; 2728 :         const size_type _New_capacity = _Calculate_growth(_Count);

  00139	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR _Count$[rsp]
  00141	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00149	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0014e	48 89 44 24 30	 mov	 QWORD PTR _New_capacity$[rsp], rax

; 2729 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00153	48 8b 44 24 30	 mov	 rax, QWORD PTR _New_capacity$[rsp]
  00158	48 83 c0 01	 add	 rax, 1
  0015c	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00163	48 0f 42 c1	 cmovb	 rax, rcx
  00167	48 8b d0	 mov	 rdx, rax
  0016a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Al$[rsp]
  0016f	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
  00174	48 89 44 24 58	 mov	 QWORD PTR _New_ptr$[rsp], rax

; 2730 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00179	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  0017e	48 8d 54 24 58	 lea	 rdx, QWORD PTR _New_ptr$[rsp]
  00183	48 8b c8	 mov	 rcx, rax
  00186	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2731 : 
; 2732 : #if _HAS_CXX20
; 2733 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB

  0018b	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00190	0f b6 c0	 movzx	 eax, al
  00193	85 c0		 test	 eax, eax
  00195	74 2a		 je	 SHORT $LN6@Construct

; 2734 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());

  00197	48 8b 44 24 30	 mov	 rax, QWORD PTR _New_capacity$[rsp]
  0019c	48 ff c0	 inc	 rax
  0019f	48 89 44 24 48	 mov	 QWORD PTR tv158[rsp], rax
  001a4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  001a9	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  001ae	45 33 c0	 xor	 r8d, r8d
  001b1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv158[rsp]
  001b6	48 8b d1	 mov	 rdx, rcx
  001b9	48 8b c8	 mov	 rcx, rax
  001bc	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign
$LN6@Construct:

; 2735 :         }
; 2736 : #endif // _HAS_CXX20
; 2737 : 
; 2738 :         _My_data._Mysize = _Count;

  001c1	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  001c6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _Count$[rsp]
  001ce	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 2739 :         _My_data._Myres  = _New_capacity;

  001d2	48 8b 44 24 28	 mov	 rax, QWORD PTR _My_data$[rsp]
  001d7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _New_capacity$[rsp]
  001dc	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2740 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2741 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2742 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2743 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2744 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2745 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2746 :         } else { // _Strat == _Construct_strategy::_From_string
; 2747 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

  001e0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR _Count$[rsp]
  001e8	48 ff c0	 inc	 rax
  001eb	48 89 44 24 50	 mov	 QWORD PTR tv165[rsp], rax
  001f0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  001f5	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  001fa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv165[rsp]
  001ff	4c 8b c1	 mov	 r8, rcx
  00202	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR _Arg$[rsp]
  0020a	48 8b c8	 mov	 rcx, rax
  0020d	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 2748 :         }
; 2749 : 
; 2750 :         _ASAN_STRING_CREATE(*this);
; 2751 :         _Proxy._Release();

  00212	48 8d 4c 24 60	 lea	 rcx, QWORD PTR _Proxy$[rsp]
  00217	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
$LN1@Construct:
$LN7@Construct:

; 2752 :     }

  0021c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00221	48 33 cc	 xor	 rcx, rsp
  00224	e8 00 00 00 00	 call	 __security_check_cookie
  00229	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0022d	c3		 ret	 0
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPEADAEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@D@std@@YAPEADAEAD@Z PROC			; std::addressof<char>, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Val$[rsp]

; 254  : }

  0000a	c3		 ret	 0
??$addressof@D@std@@YAPEADAEAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 296  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 297  :     if constexpr (is_array_v<_Ty>) {
; 298  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 299  :     } else {
; 300  :         _Obj.~_Ty();
; 301  :     }
; 302  : }

  00005	c3		 ret	 0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Construct_in_place@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$V@std@@YAXAEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
??$_Construct_in_place@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$V@std@@YAXAEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@@Z PROC ; std::_Construct_in_place<std::_String_val<std::_Simple_types<char> >::_Bxty>, COMDAT

; 231  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 232  : #if _HAS_CXX20
; 233  :     if (_STD is_constant_evaluated()) {

  00009	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0000e	0f b6 c0	 movzx	 eax, al
  00011	85 c0		 test	 eax, eax
  00013	74 14		 je	 SHORT $LN2@Construct_

; 234  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  00015	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Obj$[rsp]
  0001a	e8 00 00 00 00	 call	 ??$addressof@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@AEAT120@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> >::_Bxty>
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ??$construct_at@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$VX@std@@YAPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@QEAT120@@Z ; std::construct_at<std::_String_val<std::_Simple_types<char> >::_Bxty,void>

; 235  :     } else

  00027	eb 2e		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 236  : #endif // _HAS_CXX20
; 237  :     {
; 238  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00029	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Obj$[rsp]
  0002e	e8 00 00 00 00	 call	 ??$addressof@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@AEAT120@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> >::_Bxty>
  00033	48 8b c8	 mov	 rcx, rax
  00036	e8 00 00 00 00	 call	 ??$_Voidify_iter@PEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAXPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@@Z ; std::_Voidify_iter<std::_String_val<std::_Simple_types<char> >::_Bxty *>
  0003b	48 8b d0	 mov	 rdx, rax
  0003e	b9 10 00 00 00	 mov	 ecx, 16
  00043	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00048	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00052	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
$LN3@Construct_:

; 239  :     }
; 240  : }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	c3		 ret	 0
??$_Construct_in_place@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$V@std@@YAXAEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@@Z ENDP ; std::_Construct_in_place<std::_String_val<std::_Simple_types<char> >::_Bxty>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
_TEXT	SEGMENT
_My_data$ = 48
_Old_size$ = 56
_New_capacity$ = 64
_New_size$ = 72
_Old_capacity$ = 80
_Old_ptr$1 = 88
_Al$ = 96
_Raw_new$ = 104
tv94 = 112
_New_ptr$ = 120
__$ArrayPad$ = 128
this$ = 160
_Size_increase$ = 168
_Fn$ = 176
<_Args_0>$ = 184
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>, COMDAT

; 4802 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN7:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4803 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4804 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4805 :         auto& _My_data            = _Mypair._Myval2;

  0002d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00035	48 89 44 24 30	 mov	 QWORD PTR _My_data$[rsp], rax

; 4806 :         const size_type _Old_size = _My_data._Mysize;

  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  0003f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00043	48 89 44 24 38	 mov	 QWORD PTR _Old_size$[rsp], rax

; 4807 :         if (max_size() - _Old_size < _Size_increase) {

  00048	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00050	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00055	48 2b 44 24 38	 sub	 rax, QWORD PTR _Old_size$[rsp]
  0005a	48 3b 84 24 a8
	00 00 00	 cmp	 rax, QWORD PTR _Size_increase$[rsp]
  00062	73 05		 jae	 SHORT $LN2@Reallocate

; 4808 :             _Xlen_string(); // result too long

  00064	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4809 :         }
; 4810 : 
; 4811 :         const size_type _New_size     = _Old_size + _Size_increase;

  00069	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR _Size_increase$[rsp]
  00071	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _Old_size$[rsp]
  00076	48 03 c8	 add	 rcx, rax
  00079	48 8b c1	 mov	 rax, rcx
  0007c	48 89 44 24 48	 mov	 QWORD PTR _New_size$[rsp], rax

; 4812 :         const size_type _Old_capacity = _My_data._Myres;

  00081	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  00086	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0008a	48 89 44 24 50	 mov	 QWORD PTR _Old_capacity$[rsp], rax

; 4813 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  0008f	48 8b 54 24 48	 mov	 rdx, QWORD PTR _New_size$[rsp]
  00094	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0009c	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  000a1	48 89 44 24 40	 mov	 QWORD PTR _New_capacity$[rsp], rax

; 4814 :         auto& _Al                     = _Getal();

  000a6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000ae	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  000b3	48 89 44 24 60	 mov	 QWORD PTR _Al$[rsp], rax

; 4815 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000b8	48 8b 44 24 40	 mov	 rax, QWORD PTR _New_capacity$[rsp]
  000bd	48 83 c0 01	 add	 rax, 1
  000c1	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  000c8	48 0f 42 c1	 cmovb	 rax, rcx
  000cc	48 8b d0	 mov	 rdx, rax
  000cf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Al$[rsp]
  000d4	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
  000d9	48 89 44 24 78	 mov	 QWORD PTR _New_ptr$[rsp], rax

; 4816 : 
; 4817 : #if _HAS_CXX20
; 4818 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB

  000de	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  000e3	0f b6 c0	 movzx	 eax, al
  000e6	85 c0		 test	 eax, eax
  000e8	74 2a		 je	 SHORT $LN3@Reallocate

; 4819 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());

  000ea	48 8b 44 24 40	 mov	 rax, QWORD PTR _New_capacity$[rsp]
  000ef	48 ff c0	 inc	 rax
  000f2	48 89 44 24 70	 mov	 QWORD PTR tv94[rsp], rax
  000f7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  000fc	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00101	45 33 c0	 xor	 r8d, r8d
  00104	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv94[rsp]
  00109	48 8b d1	 mov	 rdx, rcx
  0010c	48 8b c8	 mov	 rcx, rax
  0010f	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign
$LN3@Reallocate:

; 4820 :         }
; 4821 : #endif // _HAS_CXX20
; 4822 :         _My_data._Orphan_all();

  00114	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _My_data$[rsp]
  00119	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 4823 :         _ASAN_STRING_REMOVE(*this);
; 4824 :         _My_data._Mysize      = _New_size;

  0011e	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  00123	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _New_size$[rsp]
  00128	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 4825 :         _My_data._Myres       = _New_capacity;

  0012c	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  00131	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _New_capacity$[rsp]
  00136	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  0013a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  0013f	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00144	48 89 44 24 68	 mov	 QWORD PTR _Raw_new$[rsp], rax

; 4827 :         if (_BUF_SIZE <= _Old_capacity) {

  00149	48 83 7c 24 50
	10		 cmp	 QWORD PTR _Old_capacity$[rsp], 16
  0014f	72 66		 jb	 SHORT $LN4@Reallocate

; 4828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  00151	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  00156	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00159	48 89 44 24 58	 mov	 QWORD PTR _Old_ptr$1[rsp], rax

; 4829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  0015e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Old_ptr$1[rsp]
  00163	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  00168	0f b6 8c 24 b8
	00 00 00	 movzx	 ecx, BYTE PTR <_Args_0>$[rsp]
  00170	88 4c 24 20	 mov	 BYTE PTR [rsp+32], cl
  00174	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _Old_size$[rsp]
  00179	4c 8b c0	 mov	 r8, rax
  0017c	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Raw_new$[rsp]
  00181	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Fn$[rsp]
  00189	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()

; 4830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  0018e	48 8b 44 24 50	 mov	 rax, QWORD PTR _Old_capacity$[rsp]
  00193	48 ff c0	 inc	 rax
  00196	4c 8b c0	 mov	 r8, rax
  00199	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Old_ptr$1[rsp]
  0019e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Al$[rsp]
  001a3	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate

; 4831 :             _My_data._Bx._Ptr = _New_ptr;

  001a8	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  001ad	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  001b2	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4832 :         } else {

  001b5	eb 3d		 jmp	 SHORT $LN5@Reallocate
$LN4@Reallocate:

; 4833 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  001b7	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  001bc	0f b6 8c 24 b8
	00 00 00	 movzx	 ecx, BYTE PTR <_Args_0>$[rsp]
  001c4	88 4c 24 20	 mov	 BYTE PTR [rsp+32], cl
  001c8	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _Old_size$[rsp]
  001cd	4c 8b c0	 mov	 r8, rax
  001d0	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Raw_new$[rsp]
  001d5	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR _Fn$[rsp]
  001dd	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()

; 4834 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  001e2	48 8b 44 24 30	 mov	 rax, QWORD PTR _My_data$[rsp]
  001e7	48 8d 54 24 78	 lea	 rdx, QWORD PTR _New_ptr$[rsp]
  001ec	48 8b c8	 mov	 rcx, rax
  001ef	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
$LN5@Reallocate:

; 4835 :         }
; 4836 : 
; 4837 :         _ASAN_STRING_CREATE(*this);
; 4838 :         return *this;

  001f4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
$LN6@Reallocate:

; 4839 :     }

  001fc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00204	48 33 cc	 xor	 rcx, rsp
  00207	e8 00 00 00 00	 call	 __security_check_cookie
  0020c	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00213	c3		 ret	 0
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
_TEXT	SEGMENT
tv77 = 32
tv75 = 40
$T1 = 48
_Obj$ = 80
<_Args_0>$ = 88
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z PROC ; std::_Construct_in_place<char *,char * &>, COMDAT

; 231  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 232  : #if _HAS_CXX20
; 233  :     if (_STD is_constant_evaluated()) {

  0000e	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00013	0f b6 c0	 movzx	 eax, al
  00016	85 c0		 test	 eax, eax
  00018	74 2f		 je	 SHORT $LN2@Construct_

; 234  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0001a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR <_Args_0>$[rsp]
  0001f	e8 00 00 00 00	 call	 ??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ; std::forward<char * &>
  00024	48 89 44 24 20	 mov	 QWORD PTR tv77[rsp], rax
  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Obj$[rsp]
  0002e	e8 00 00 00 00	 call	 ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
  00033	48 89 44 24 28	 mov	 QWORD PTR tv75[rsp], rax
  00038	48 8b 54 24 20	 mov	 rdx, QWORD PTR tv77[rsp]
  0003d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv75[rsp]
  00042	e8 00 00 00 00	 call	 ??$construct_at@PEADAEAPEADX@std@@YAPEAPEADQEAPEADAEAPEAD@Z ; std::construct_at<char *,char * &,void>

; 235  :     } else

  00047	eb 39		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 236  : #endif // _HAS_CXX20
; 237  :     {
; 238  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Obj$[rsp]
  0004e	e8 00 00 00 00	 call	 ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 ??$_Voidify_iter@PEAPEAD@std@@YAPEAXPEAPEAD@Z ; std::_Voidify_iter<char * *>
  0005b	48 8b d0	 mov	 rdx, rax
  0005e	b9 08 00 00 00	 mov	 ecx, 8
  00063	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00068	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR <_Args_0>$[rsp]
  00072	e8 00 00 00 00	 call	 ??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ; std::forward<char * &>
  00077	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T1[rsp]
  0007c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007f	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN3@Construct_:

; 239  :     }
; 240  : }

  00082	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00086	c3		 ret	 0
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ENDP ; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Count$ = 32
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 04 24 00	 mov	 BYTE PTR _Overflow_is_possible$[rsp], 0

; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 60   :         if (_Count > _Max_possible) {
; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0000d	48 8b 44 24 20	 mov	 rax, QWORD PTR _Count$[rsp]

; 66   : }

  00012	48 83 c4 18	 add	 rsp, 24
  00016	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits,0>, COMDAT

; 223  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 224  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 225  : #if defined(_M_IX86) || defined(_M_X64)
; 226  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 227  :     if (!_STD is_constant_evaluated())

  00009	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0000e	0f b6 c0	 movzx	 eax, al
  00011	85 c0		 test	 eax, eax
  00013	75 17		 jne	 SHORT $LN2@Allocate

; 228  : #endif // _HAS_CXX20
; 229  :     {
; 230  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00015	48 81 7c 24 30
	00 10 00 00	 cmp	 QWORD PTR _Bytes$[rsp], 4096 ; 00001000H
  0001e	72 0c		 jb	 SHORT $LN3@Allocate

; 231  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Bytes$[rsp]
  00025	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0002a	eb 16		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:
$LN2@Allocate:

; 232  :         }
; 233  :     }
; 234  : #endif // defined(_M_IX86) || defined(_M_X64)
; 235  : 
; 236  :     if (_Bytes != 0) {

  0002c	48 83 7c 24 30
	00		 cmp	 QWORD PTR _Bytes$[rsp], 0
  00032	74 0c		 je	 SHORT $LN4@Allocate

; 237  :         return _Traits::_Allocate(_Bytes);

  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Bytes$[rsp]
  00039	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
  0003e	eb 02		 jmp	 SHORT $LN1@Allocate
$LN4@Allocate:

; 238  :     }
; 239  : 
; 240  :     return nullptr;

  00040	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 241  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16,0>, COMDAT

; 244  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 245  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 246  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 247  :     if (_STD is_constant_evaluated()) {

  0000e	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00013	0f b6 c0	 movzx	 eax, al
  00016	85 c0		 test	 eax, eax
  00018	74 0c		 je	 SHORT $LN2@Deallocate

; 248  :         ::operator delete(_Ptr);

  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 249  :     } else

  00024	eb 2a		 jmp	 SHORT $LN3@Deallocate
$LN2@Deallocate:

; 250  : #endif // _HAS_CXX20
; 251  :     {
; 252  : #if defined(_M_IX86) || defined(_M_X64)
; 253  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00026	48 81 7c 24 38
	00 10 00 00	 cmp	 QWORD PTR _Bytes$[rsp], 4096 ; 00001000H
  0002f	72 0f		 jb	 SHORT $LN4@Deallocate

; 254  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  00031	48 8d 54 24 38	 lea	 rdx, QWORD PTR _Bytes$[rsp]
  00036	48 8d 4c 24 30	 lea	 rcx, QWORD PTR _Ptr$[rsp]
  0003b	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
$LN4@Deallocate:

; 255  :         }
; 256  : #endif // defined(_M_IX86) || defined(_M_X64)
; 257  :         ::operator delete(_Ptr, _Bytes);

  00040	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Bytes$[rsp]
  00045	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  0004a	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  0004f	90		 npad	 1
$LN3@Deallocate:

; 258  :     }
; 259  : }

  00050	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00054	c3		 ret	 0
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Val$[rsp]

; 254  : }

  0000a	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > const >, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Val$[rsp]

; 254  : }

  0000a	c3		 ret	 0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$construct_at@DAEBDX@std@@YAPEADQEADAEBD@Z
_TEXT	SEGMENT
$T1 = 32
_Location$ = 64
<_Args_0>$ = 72
??$construct_at@DAEBDX@std@@YAPEADQEADAEBD@Z PROC	; std::construct_at<char,char const &,void>, COMDAT

; 224  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 225  :     _MSVC_CONSTEXPR return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Location$[rsp]
  00013	e8 00 00 00 00	 call	 ??$_Voidify_iter@PEAD@std@@YAPEAXPEAD@Z ; std::_Voidify_iter<char *>
  00018	48 8b d0	 mov	 rdx, rax
  0001b	b9 01 00 00 00	 mov	 ecx, 1
  00020	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00025	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  0002a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR <_Args_0>$[rsp]
  0002f	e8 00 00 00 00	 call	 ??$forward@AEBD@std@@YAAEBDAEBD@Z ; std::forward<char const &>
  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00039	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003c	88 01		 mov	 BYTE PTR [rcx], al
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR $T1[rsp]

; 226  : }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	c3		 ret	 0
??$construct_at@DAEBDX@std@@YAPEADQEADAEBD@Z ENDP	; std::construct_at<char,char const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\Macros.h
;	COMDAT ??$ignore_unused_variable@_J@internal@Eigen@@YAXAEB_J@Z
_TEXT	SEGMENT
__formal$ = 8
??$ignore_unused_variable@_J@internal@Eigen@@YAXAEB_J@Z PROC ; Eigen::internal::ignore_unused_variable<__int64>, COMDAT

; 1073 :     template<typename T> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void ignore_unused_variable(const T&) {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	c3		 ret	 0
??$ignore_unused_variable@_J@internal@Eigen@@YAXAEB_J@Z ENDP ; Eigen::internal::ignore_unused_variable<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\IntegralConstant.h
;	COMDAT ??0?$FixedInt@$00@internal@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$FixedInt@$00@internal@Eigen@@QEAA@XZ PROC		; Eigen::internal::FixedInt<1>::FixedInt<1>, COMDAT

; 56   :   FixedInt() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
??0?$FixedInt@$00@internal@Eigen@@QEAA@XZ ENDP		; Eigen::internal::FixedInt<1>::FixedInt<1>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1IOFormat@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1IOFormat@Eigen@@QEAA@XZ PROC				; Eigen::IOFormat::~IOFormat, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 05 c0 00 00
	00		 add	 rax, 192		; 000000c0H
  00014	48 8b c8	 mov	 rcx, rax
  00017	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00027	48 8b c8	 mov	 rcx, rax
  0002a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002f	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00034	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00047	48 83 c0 60	 add	 rax, 96			; 00000060H
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00058	48 83 c0 40	 add	 rax, 64			; 00000040H
  0005c	48 8b c8	 mov	 rcx, rax
  0005f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00064	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00069	48 83 c0 20	 add	 rax, 32			; 00000020H
  0006d	48 8b c8	 mov	 rcx, rax
  00070	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00075	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0007a	48 8b c8	 mov	 rcx, rax
  0007d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00082	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00086	c3		 ret	 0
??1IOFormat@Eigen@@QEAA@XZ ENDP				; Eigen::IOFormat::~IOFormat
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseBase.h
;	COMDAT ?eval@?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$00$0?0$00$00$0?0@2@XZ
_TEXT	SEGMENT
this$ = 48
?eval@?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$00$0?0$00$00$0?0@2@XZ PROC ; Eigen::DenseBase<Eigen::Matrix<double,1,-1,1,1,-1> >::eval, COMDAT

; 408  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 409  :       // Even though MSVC does not honor strong inlining when the return type
; 410  :       // is a dynamic matrix, we desperately need strong inlining for fixed
; 411  :       // size types on MSVC.
; 412  :       return typename internal::eval<Derived>::type(derived());

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?derived@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$00$0?0$00$00$0?0@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::derived

; 413  :     }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
?eval@?$DenseBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$00$0?0$00$00$0?0@2@XZ ENDP ; Eigen::DenseBase<Eigen::Matrix<double,1,-1,1,1,-1> >::eval
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\EigenBase.h
;	COMDAT ?derived@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@XZ
_TEXT	SEGMENT
this$ = 8
?derived@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@XZ PROC ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::derived, COMDAT

; 49   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
?derived@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@XZ ENDP ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::derived
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\SymbolicIndex.h
;	COMDAT ??0?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@symbolic@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@symbolic@Eigen@@QEAA@XZ PROC ; Eigen::symbolic::ValueExpr<Eigen::internal::FixedInt<1> >::ValueExpr<Eigen::internal::FixedInt<1> >, COMDAT

; 66   :   ValueExpr() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
??0?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@symbolic@Eigen@@QEAA@XZ ENDP ; Eigen::symbolic::ValueExpr<Eigen::internal::FixedInt<1> >::ValueExpr<Eigen::internal::FixedInt<1> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\SymbolicIndex.h
;	COMDAT ??0?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@symbolic@Eigen@@QEAA@AEBV?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@12@AEBV?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@12@@Z
_TEXT	SEGMENT
this$ = 8
arg0$ = 16
arg1$ = 24
??0?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@symbolic@Eigen@@QEAA@AEBV?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@12@AEBV?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@12@@Z PROC ; Eigen::symbolic::AddExpr<Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag>,Eigen::symbolic::ValueExpr<Eigen::internal::FixedInt<1> > >::AddExpr<Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag>,Eigen::symbolic::ValueExpr<Eigen::internal::FixedInt<1> > >, COMDAT

; 254  :   AddExpr(const Arg0& arg0, const Arg1& arg1) : m_arg0(arg0), m_arg1(arg1) {}

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00014	c3		 ret	 0
??0?$AddExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@V?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@23@@symbolic@Eigen@@QEAA@AEBV?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@12@AEBV?$ValueExpr@V?$FixedInt@$00@internal@Eigen@@@12@@Z ENDP ; Eigen::symbolic::AddExpr<Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag>,Eigen::symbolic::ValueExpr<Eigen::internal::FixedInt<1> > >::AddExpr<Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag>,Eigen::symbolic::ValueExpr<Eigen::internal::FixedInt<1> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\SymbolicIndex.h
;	COMDAT ?derived@?$BaseExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@@symbolic@Eigen@@QEBAAEBV?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@23@XZ
_TEXT	SEGMENT
this$ = 8
?derived@?$BaseExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@@symbolic@Eigen@@QEBAAEBV?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@23@XZ PROC ; Eigen::symbolic::BaseExpr<Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag> >::derived, COMDAT

; 80   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
?derived@?$BaseExpr@V?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@symbolic@Eigen@@@symbolic@Eigen@@QEBAAEBV?$SymbolExpr@Usymbolic_last_tag@internal@Eigen@@@23@XZ ENDP ; Eigen::symbolic::BaseExpr<Eigen::symbolic::SymbolExpr<Eigen::internal::symbolic_last_tag> >::derived
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
tv76 = 32
tv74 = 40
this$ = 64
_Requested$ = 72
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4763 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4764 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00013	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00018	48 89 44 24 20	 mov	 QWORD PTR tv76[rsp], rax
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00026	48 89 44 24 28	 mov	 QWORD PTR tv74[rsp], rax
  0002b	4c 8b 44 24 20	 mov	 r8, QWORD PTR tv76[rsp]
  00030	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv74[rsp]
  00035	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Requested$[rsp]
  0003a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth

; 4765 :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
_Storage_max$ = 40
$T2 = 48
$T3 = 56
_Alloc_max$ = 64
__$ArrayPad$ = 72
this$ = 96
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 4157 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4158 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

  00018	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
  0002a	48 89 44 24 40	 mov	 QWORD PTR _Alloc_max$[rsp], rax

; 4159 :         const size_type _Storage_max = // can always store small string

  0002f	48 c7 44 24 20
	10 00 00 00	 mov	 QWORD PTR $T1[rsp], 16
  00038	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0003d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Alloc_max$[rsp]
  00042	e8 00 00 00 00	 call	 ??$max@_K@std@@YAAEB_KAEB_K0@Z ; std::max<unsigned __int64>
  00047	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004a	48 89 44 24 28	 mov	 QWORD PTR _Storage_max$[rsp], rax

; 4160 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 4161 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004f	48 8b 44 24 28	 mov	 rax, QWORD PTR _Storage_max$[rsp]
  00054	48 ff c8	 dec	 rax
  00057	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp], rax
  0005c	e8 00 00 00 00	 call	 ?max@?$numeric_limits@_J@std@@SA_JXZ ; std::numeric_limits<__int64>::max
  00061	48 89 44 24 38	 mov	 QWORD PTR $T3[rsp], rax
  00066	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  0006b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T3[rsp]
  00070	e8 00 00 00 00	 call	 ??$min@_K@std@@YAAEB_KAEB_K0@Z ; std::min<unsigned __int64>
  00075	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 4162 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 4163 :         );
; 4164 :     }

  00078	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007d	48 33 cc	 xor	 rcx, rsp
  00080	e8 00 00 00 00	 call	 __security_check_cookie
  00085	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00089	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 2311 :         _CONSTEXPR20 _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00016	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 2249 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty

; 2250 : 
; 2251 :     // length of internal buffer, [1, 16]:
; 2252 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2253 :     // roundup mask for allocated buffers, [0, 15]:
; 2254 :     static constexpr size_type _ALLOC_MASK = sizeof(value_type) <= 1 ? 15
; 2255 :                                            : sizeof(value_type) <= 2 ? 7
; 2256 :                                            : sizeof(value_type) <= 4 ? 3
; 2257 :                                            : sizeof(value_type) <= 8 ? 1
; 2258 :                                                                      : 0;
; 2259 : 
; 2260 :     _CONSTEXPR20 value_type* _Myptr() noexcept {
; 2261 :         value_type* _Result = _Bx._Buf;
; 2262 :         if (_Large_string_engaged()) {
; 2263 :             _Result = _Unfancy(_Bx._Ptr);
; 2264 :         }
; 2265 : 
; 2266 :         return _Result;
; 2267 :     }
; 2268 : 
; 2269 :     _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 2270 :         const value_type* _Result = _Bx._Buf;
; 2271 :         if (_Large_string_engaged()) {
; 2272 :             _Result = _Unfancy(_Bx._Ptr);
; 2273 :         }
; 2274 : 
; 2275 :         return _Result;
; 2276 :     }
; 2277 : 
; 2278 :     _CONSTEXPR20 bool _Large_string_engaged() const noexcept {
; 2279 : #if _HAS_CXX20
; 2280 :         if (_STD is_constant_evaluated()) {
; 2281 :             return true;
; 2282 :         }
; 2283 : #endif // _HAS_CXX20
; 2284 :         return _BUF_SIZE <= _Myres;
; 2285 :     }
; 2286 : 
; 2287 :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 2288 :         // checks whether _Off is in the bounds of [0, size()]
; 2289 :         if (_Mysize < _Off) {
; 2290 :             _Xran();
; 2291 :         }
; 2292 :     }
; 2293 : 
; 2294 :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 2295 :         // checks whether _Off is in the bounds of [0, size())
; 2296 :         if (_Mysize <= _Off) {
; 2297 :             _Xran();
; 2298 :         }
; 2299 :     }
; 2300 : 
; 2301 :     [[noreturn]] static void _Xran() {
; 2302 :         _Xout_of_range("invalid string position");
; 2303 :     }
; 2304 : 
; 2305 :     _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2306 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2307 :         return (_STD min)(_Size, _Mysize - _Off);
; 2308 :     }
; 2309 : 
; 2310 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2311 :         _CONSTEXPR20 _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers
; 2312 : 
; 2313 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2314 : 
; 2315 :         value_type _Buf[_BUF_SIZE];
; 2316 :         pointer _Ptr;
; 2317 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2318 :     } _Bx;
; 2319 : 
; 2320 :     size_type _Mysize = 0; // current length of string

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001b	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 2321 :     size_type _Myres  = 0; // current storage reserved for string

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00028	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 2249 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 821  :     constexpr allocator() noexcept {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
$T1 = 32
_Masked$ = 40
__$ArrayPad$ = 48
_Requested$ = 80
_Old$ = 88
_Max$ = 96
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4750 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4751 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR _Requested$[rsp]
  00027	48 83 c8 0f	 or	 rax, 15
  0002b	48 89 44 24 28	 mov	 QWORD PTR _Masked$[rsp], rax

; 4752 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00030	48 8b 44 24 60	 mov	 rax, QWORD PTR _Max$[rsp]
  00035	48 39 44 24 28	 cmp	 QWORD PTR _Masked$[rsp], rax
  0003a	76 07		 jbe	 SHORT $LN2@Calculate_

; 4753 :             return _Max;

  0003c	48 8b 44 24 60	 mov	 rax, QWORD PTR _Max$[rsp]
  00041	eb 59		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 4754 :         }
; 4755 : 
; 4756 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00043	33 d2		 xor	 edx, edx
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR _Old$[rsp]
  0004a	b9 02 00 00 00	 mov	 ecx, 2
  0004f	48 f7 f1	 div	 rcx
  00052	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Max$[rsp]
  00057	48 2b c8	 sub	 rcx, rax
  0005a	48 8b c1	 mov	 rax, rcx
  0005d	48 39 44 24 58	 cmp	 QWORD PTR _Old$[rsp], rax
  00062	76 07		 jbe	 SHORT $LN3@Calculate_

; 4757 :             return _Max;

  00064	48 8b 44 24 60	 mov	 rax, QWORD PTR _Max$[rsp]
  00069	eb 31		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 4758 :         }
; 4759 : 
; 4760 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0006b	33 d2		 xor	 edx, edx
  0006d	48 8b 44 24 58	 mov	 rax, QWORD PTR _Old$[rsp]
  00072	b9 02 00 00 00	 mov	 ecx, 2
  00077	48 f7 f1	 div	 rcx
  0007a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Old$[rsp]
  0007f	48 03 c8	 add	 rcx, rax
  00082	48 8b c1	 mov	 rax, rcx
  00085	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  0008a	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0008f	48 8d 4c 24 28	 lea	 rcx, QWORD PTR _Masked$[rsp]
  00094	e8 00 00 00 00	 call	 ??$max@_K@std@@YAAEB_KAEB_K0@Z ; std::max<unsigned __int64>
  00099	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN1@Calculate_:

; 4761 :     }

  0009c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a1	48 33 cc	 xor	 rcx, rsp
  000a4	e8 00 00 00 00	 call	 __security_check_cookie
  000a9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ad	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 695  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 696  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00005	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1

; 697  :     }

  0000c	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Voidify_iter@PEAD@std@@YAPEAXPEAD@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAD@std@@YAPEAXPEAD@Z PROC		; std::_Voidify_iter<char *>, COMDAT

; 212  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 213  :     if constexpr (is_pointer_v<_Iter>) {
; 214  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _It$[rsp]

; 215  :     } else {
; 216  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 217  :     }
; 218  : }

  0000a	c3		 ret	 0
??$_Voidify_iter@PEAD@std@@YAPEAXPEAD@Z ENDP		; std::_Voidify_iter<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@AEBD@std@@YAAEBDAEBD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBD@std@@YAAEBDAEBD@Z PROC			; std::forward<char const &>, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1413 : }

  0000a	c3		 ret	 0
??$forward@AEBD@std@@YAAEBDAEBD@Z ENDP			; std::forward<char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> ><Eigen::Matrix<double,28,28,0,28,28> >, COMDAT

; 591  :     {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00013	e8 00 00 00 00	 call	 ??0?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@XZ ; Eigen::MatrixBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::MatrixBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >

; 590  :       : m_storage()

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 ??0?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ ; Eigen::DenseStorage<double,-1,-1,-1,0>::DenseStorage<double,-1,-1,-1,0>
  00025	90		 npad	 1

; 592  :       _check_template_params();

  00026	e8 00 00 00 00	 call	 ?_check_template_params@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@SAXXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::_check_template_params

; 593  :       resizeLike(other);

  0002b	48 8b 54 24 38	 mov	 rdx, QWORD PTR other$[rsp]
  00030	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00035	e8 00 00 00 00	 call	 ??$resizeLike@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::resizeLike<Eigen::Matrix<double,28,28,0,28,28> >

; 594  :       _set_noalias(other);

  0003a	48 8b 54 24 38	 mov	 rdx, QWORD PTR other$[rsp]
  0003f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00044	e8 00 00 00 00	 call	 ??$_set_noalias@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::_set_noalias<Eigen::Matrix<double,28,28,0,28,28> >
  00049	90		 npad	 1

; 595  :     }

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0004f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00053	c3		 ret	 0
??$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> ><Eigen::Matrix<double,28,28,0,28,28> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
other$ = 56
?dtor$0@?0???$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z@4HA PROC ; `Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> ><Eigen::Matrix<double,28,28,0,28,28> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 30	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ ; Eigen::DenseStorage<double,-1,-1,-1,0>::~DenseStorage<double,-1,-1,-1,0>
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???$?0V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z@4HA ENDP ; `Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> ><Eigen::Matrix<double,28,28,0,28,28> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\IO.h
;	COMDAT ??$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z
_TEXT	SEGMENT
align_cols$ = 32
old_fill_character$ = 33
m$ = 40
i$3 = 48
explicit_precision$ = 56
tv138 = 64
j$4 = 72
i$5 = 80
j$6 = 88
old_precision$ = 96
tv134 = 104
tv188 = 112
tv204 = 120
tv410 = 128
$T2 = 136
tv272 = 144
tv286 = 152
tv323 = 160
tv337 = 168
tv379 = 176
tv394 = 184
old_width$ = 192
tv408 = 200
$T1 = 208
sstr$7 = 240
width$ = 496
__$ArrayPad$ = 504
s$ = 528
_m$ = 536
fmt$ = 544
??$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z PROC ; Eigen::internal::print_matrix<Eigen::Matrix<double,1,-1,1,1,-1> >, COMDAT

; 132  : {

$LN34:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 08 02
	00 00		 sub	 rsp, 520		; 00000208H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 f8
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 133  :   using internal::is_same;
; 134  :   using internal::conditional;
; 135  : 
; 136  :   if(_m.size() == 0)

  00028	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR _m$[rsp]
  00030	e8 00 00 00 00	 call	 ?size@?$EigenBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,1,-1,1,1,-1> >::size
  00035	48 85 c0	 test	 rax, rax
  00038	75 3c		 jne	 SHORT $LN14@print_matr

; 137  :   {
; 138  :     s << fmt.matPrefix << fmt.matSuffix;

  0003a	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00042	48 8b d0	 mov	 rdx, rax
  00045	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0004d	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
  00052	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  0005a	48 83 c1 20	 add	 rcx, 32			; 00000020H
  0005e	48 8b d1	 mov	 rdx, rcx
  00061	48 8b c8	 mov	 rcx, rax
  00064	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 139  :     return s;

  00069	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00071	e9 26 06 00 00	 jmp	 $LN1@print_matr
$LN14@print_matr:

; 140  :   }
; 141  :   
; 142  :   typename Derived::Nested m = _m;

  00076	48 8b 84 24 18
	02 00 00	 mov	 rax, QWORD PTR _m$[rsp]
  0007e	48 89 44 24 28	 mov	 QWORD PTR m$[rsp], rax

; 143  :   typedef typename Derived::Scalar Scalar;
; 144  :   typedef typename
; 145  :       conditional<
; 146  :           is_same<Scalar, char>::value ||
; 147  :             is_same<Scalar, unsigned char>::value ||
; 148  :             is_same<Scalar, numext::int8_t>::value ||
; 149  :             is_same<Scalar, numext::uint8_t>::value,
; 150  :           int,
; 151  :           typename conditional<
; 152  :               is_same<Scalar, std::complex<char> >::value ||
; 153  :                 is_same<Scalar, std::complex<unsigned char> >::value ||
; 154  :                 is_same<Scalar, std::complex<numext::int8_t> >::value ||
; 155  :                 is_same<Scalar, std::complex<numext::uint8_t> >::value,
; 156  :               std::complex<int>,
; 157  :               const Scalar&
; 158  :             >::type
; 159  :         >::type PrintType;
; 160  : 
; 161  :   Index width = 0;

  00083	48 c7 84 24 f0
	01 00 00 00 00
	00 00		 mov	 QWORD PTR width$[rsp], 0

; 162  : 
; 163  :   std::streamsize explicit_precision;
; 164  :   if(fmt.precision == StreamPrecision)

  0008f	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00097	83 b8 e4 00 00
	00 ff		 cmp	 DWORD PTR [rax+228], -1
  0009e	75 0b		 jne	 SHORT $LN15@print_matr

; 165  :   {
; 166  :     explicit_precision = 0;

  000a0	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR explicit_precision$[rsp], 0

; 167  :   }

  000a9	eb 44		 jmp	 SHORT $LN16@print_matr
$LN15@print_matr:

; 168  :   else if(fmt.precision == FullPrecision)

  000ab	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  000b3	83 b8 e4 00 00
	00 fe		 cmp	 DWORD PTR [rax+228], -2
  000ba	75 1f		 jne	 SHORT $LN17@print_matr

; 169  :   {
; 170  :     if (NumTraits<Scalar>::IsInteger)

  000bc	33 c0		 xor	 eax, eax
  000be	85 c0		 test	 eax, eax
  000c0	74 0b		 je	 SHORT $LN19@print_matr

; 171  :     {
; 172  :       explicit_precision = 0;

  000c2	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR explicit_precision$[rsp], 0

; 173  :     }

  000cb	eb 0c		 jmp	 SHORT $LN20@print_matr
$LN19@print_matr:

; 174  :     else
; 175  :     {
; 176  :       explicit_precision = significant_decimals_impl<Scalar>::run();

  000cd	e8 00 00 00 00	 call	 ?run@?$significant_decimals_impl@N@internal@Eigen@@SAHXZ ; Eigen::internal::significant_decimals_impl<double>::run
  000d2	48 98		 cdqe
  000d4	48 89 44 24 38	 mov	 QWORD PTR explicit_precision$[rsp], rax
$LN20@print_matr:

; 177  :     }
; 178  :   }

  000d9	eb 14		 jmp	 SHORT $LN16@print_matr
$LN17@print_matr:

; 179  :   else
; 180  :   {
; 181  :     explicit_precision = fmt.precision;

  000db	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  000e3	48 63 80 e4 00
	00 00		 movsxd	 rax, DWORD PTR [rax+228]
  000ea	48 89 44 24 38	 mov	 QWORD PTR explicit_precision$[rsp], rax
$LN16@print_matr:

; 182  :   }
; 183  : 
; 184  :   std::streamsize old_precision = 0;

  000ef	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR old_precision$[rsp], 0

; 185  :   if(explicit_precision) old_precision = s.precision(explicit_precision);

  000f8	48 83 7c 24 38
	00		 cmp	 QWORD PTR explicit_precision$[rsp], 0
  000fe	74 37		 je	 SHORT $LN21@print_matr
  00100	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00108	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0010b	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0010f	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00117	48 03 c8	 add	 rcx, rax
  0011a	48 8b c1	 mov	 rax, rcx
  0011d	48 89 44 24 68	 mov	 QWORD PTR tv134[rsp], rax
  00122	48 8b 54 24 38	 mov	 rdx, QWORD PTR explicit_precision$[rsp]
  00127	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv134[rsp]
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?precision@ios_base@std@@QEAA_J_J@Z
  00132	48 89 44 24 60	 mov	 QWORD PTR old_precision$[rsp], rax
$LN21@print_matr:

; 186  : 
; 187  :   bool align_cols = !(fmt.flags & DontAlignCols);

  00137	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  0013f	8b 80 e8 00 00
	00		 mov	 eax, DWORD PTR [rax+232]
  00145	83 e0 01	 and	 eax, 1
  00148	85 c0		 test	 eax, eax
  0014a	75 0a		 jne	 SHORT $LN30@print_matr
  0014c	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv138[rsp], 1
  00154	eb 08		 jmp	 SHORT $LN31@print_matr
$LN30@print_matr:
  00156	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN31@print_matr:
  0015e	0f b6 44 24 40	 movzx	 eax, BYTE PTR tv138[rsp]
  00163	88 44 24 20	 mov	 BYTE PTR align_cols$[rsp], al

; 188  :   if(align_cols)

  00167	0f b6 44 24 20	 movzx	 eax, BYTE PTR align_cols$[rsp]
  0016c	85 c0		 test	 eax, eax
  0016e	0f 84 6a 01 00
	00		 je	 $LN22@print_matr

; 189  :   {
; 190  :     // compute the largest width
; 191  :     for(Index j = 0; j < m.cols(); ++j)

  00174	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR j$4[rsp], 0
  0017d	eb 0d		 jmp	 SHORT $LN4@print_matr
$LN2@print_matr:
  0017f	48 8b 44 24 48	 mov	 rax, QWORD PTR j$4[rsp]
  00184	48 ff c0	 inc	 rax
  00187	48 89 44 24 48	 mov	 QWORD PTR j$4[rsp], rax
$LN4@print_matr:
  0018c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR m$[rsp]
  00191	e8 00 00 00 00	 call	 ?cols@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::cols
  00196	48 39 44 24 48	 cmp	 QWORD PTR j$4[rsp], rax
  0019b	0f 8d 3d 01 00
	00		 jge	 $LN22@print_matr

; 192  :       for(Index i = 0; i < m.rows(); ++i)

  001a1	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR i$5[rsp], 0
  001aa	eb 0d		 jmp	 SHORT $LN7@print_matr
$LN5@print_matr:
  001ac	48 8b 44 24 50	 mov	 rax, QWORD PTR i$5[rsp]
  001b1	48 ff c0	 inc	 rax
  001b4	48 89 44 24 50	 mov	 QWORD PTR i$5[rsp], rax
$LN7@print_matr:
  001b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR m$[rsp]
  001be	e8 00 00 00 00	 call	 ?rows@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::rows
  001c3	48 39 44 24 50	 cmp	 QWORD PTR i$5[rsp], rax
  001c8	0f 8d 0b 01 00
	00		 jge	 $LN6@print_matr

; 193  :       {
; 194  :         std::stringstream sstr;

  001ce	ba f8 00 00 00	 mov	 edx, 248		; 000000f8H
  001d3	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR sstr$7[rsp]
  001db	e8 00 00 00 00	 call	 ?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
  001e0	ba 01 00 00 00	 mov	 edx, 1
  001e5	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR sstr$7[rsp]
  001ed	e8 00 00 00 00	 call	 ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  001f2	90		 npad	 1

; 195  :         sstr.copyfmt(s);

  001f3	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR sstr$7[rsp]
  001fb	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  001ff	48 8d 84 04 f0
	00 00 00	 lea	 rax, QWORD PTR sstr$7[rsp+rax]
  00207	48 89 44 24 70	 mov	 QWORD PTR tv188[rsp], rax
  0020c	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00214	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00217	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0021b	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00223	48 03 c8	 add	 rcx, rax
  00226	48 8b c1	 mov	 rax, rcx
  00229	48 8b d0	 mov	 rdx, rax
  0022c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv188[rsp]
  00231	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?copyfmt@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAAEAV12@AEBV12@@Z

; 196  :         sstr << static_cast<PrintType>(m.coeff(i,j));

  00237	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR sstr$7[rsp+16]
  0023f	48 89 44 24 78	 mov	 QWORD PTR tv204[rsp], rax
  00244	4c 8b 44 24 48	 mov	 r8, QWORD PTR j$4[rsp]
  00249	48 8b 54 24 50	 mov	 rdx, QWORD PTR i$5[rsp]
  0024e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR m$[rsp]
  00253	e8 00 00 00 00	 call	 ?coeff@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBN_J0@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::coeff
  00258	c5 fb 10 08	 vmovsd	 xmm1, QWORD PTR [rax]
  0025c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv204[rsp]
  00261	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z

; 197  :         width = std::max<Index>(width, Index(sstr.str().length()));

  00267	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR $T1[rsp]
  0026f	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR sstr$7[rsp]
  00277	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  0027c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv410[rsp], rax
  00284	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv410[rsp]
  0028c	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  00291	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR $T2[rsp], rax
  00299	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR $T2[rsp]
  002a1	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR width$[rsp]
  002a9	e8 00 00 00 00	 call	 ??$max@_J@std@@YAAEB_JAEB_J0@Z ; std::max<__int64>
  002ae	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002b1	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR width$[rsp], rax
  002b9	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR $T1[rsp]
  002c1	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  002c6	90		 npad	 1

; 198  :       }

  002c7	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR sstr$7[rsp]
  002cf	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
  002d4	e9 d3 fe ff ff	 jmp	 $LN5@print_matr
$LN6@print_matr:
  002d9	e9 a1 fe ff ff	 jmp	 $LN2@print_matr
$LN22@print_matr:

; 199  :   }
; 200  :   std::streamsize old_width = s.width();

  002de	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002e6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002e9	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  002ed	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002f5	48 03 c8	 add	 rcx, rax
  002f8	48 8b c1	 mov	 rax, rcx
  002fb	48 8b c8	 mov	 rcx, rax
  002fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  00304	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR old_width$[rsp], rax

; 201  :   char old_fill_character = s.fill();

  0030c	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00314	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00317	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0031b	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00323	48 03 c8	 add	 rcx, rax
  00326	48 8b c1	 mov	 rax, rcx
  00329	48 8b c8	 mov	 rcx, rax
  0032c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
  00332	88 44 24 21	 mov	 BYTE PTR old_fill_character$[rsp], al

; 202  :   s << fmt.matPrefix;

  00336	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  0033e	48 8b d0	 mov	 rdx, rax
  00341	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00349	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 203  :   for(Index i = 0; i < m.rows(); ++i)

  0034e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$3[rsp], 0
  00357	eb 0d		 jmp	 SHORT $LN10@print_matr
$LN8@print_matr:
  00359	48 8b 44 24 30	 mov	 rax, QWORD PTR i$3[rsp]
  0035e	48 ff c0	 inc	 rax
  00361	48 89 44 24 30	 mov	 QWORD PTR i$3[rsp], rax
$LN10@print_matr:
  00366	48 8b 4c 24 28	 mov	 rcx, QWORD PTR m$[rsp]
  0036b	e8 00 00 00 00	 call	 ?rows@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::rows
  00370	48 39 44 24 30	 cmp	 QWORD PTR i$3[rsp], rax
  00375	0f 8d 3f 02 00
	00		 jge	 $LN9@print_matr

; 204  :   {
; 205  :     if (i)

  0037b	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$3[rsp], 0
  00381	74 1e		 je	 SHORT $LN23@print_matr

; 206  :       s << fmt.rowSpacer;

  00383	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  0038b	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00391	48 8b d0	 mov	 rdx, rax
  00394	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0039c	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
$LN23@print_matr:

; 207  :     s << fmt.rowPrefix;

  003a1	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  003a9	48 83 c0 40	 add	 rax, 64			; 00000040H
  003ad	48 8b d0	 mov	 rdx, rax
  003b0	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003b8	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 208  :     if(width) {

  003bd	48 83 bc 24 f0
	01 00 00 00	 cmp	 QWORD PTR width$[rsp], 0
  003c6	74 7d		 je	 SHORT $LN24@print_matr

; 209  :       s.fill(fmt.fill);

  003c8	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003d0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003d3	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  003d7	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003df	48 03 c8	 add	 rcx, rax
  003e2	48 8b c1	 mov	 rax, rcx
  003e5	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv272[rsp], rax
  003ed	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  003f5	0f b6 90 e0 00
	00 00		 movzx	 edx, BYTE PTR [rax+224]
  003fc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv272[rsp]
  00404	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAADD@Z

; 210  :       s.width(width);

  0040a	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00412	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00415	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00419	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00421	48 03 c8	 add	 rcx, rax
  00424	48 8b c1	 mov	 rax, rcx
  00427	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv286[rsp], rax
  0042f	48 8b 94 24 f0
	01 00 00	 mov	 rdx, QWORD PTR width$[rsp]
  00437	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv286[rsp]
  0043f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEAA_J_J@Z
$LN24@print_matr:

; 211  :     }
; 212  :     s << static_cast<PrintType>(m.coeff(i, 0));

  00445	45 33 c0	 xor	 r8d, r8d
  00448	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$3[rsp]
  0044d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR m$[rsp]
  00452	e8 00 00 00 00	 call	 ?coeff@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBN_J0@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::coeff
  00457	c5 fb 10 08	 vmovsd	 xmm1, QWORD PTR [rax]
  0045b	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00463	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z

; 213  :     for(Index j = 1; j < m.cols(); ++j)

  00469	48 c7 44 24 58
	01 00 00 00	 mov	 QWORD PTR j$6[rsp], 1
  00472	eb 0d		 jmp	 SHORT $LN13@print_matr
$LN11@print_matr:
  00474	48 8b 44 24 58	 mov	 rax, QWORD PTR j$6[rsp]
  00479	48 ff c0	 inc	 rax
  0047c	48 89 44 24 58	 mov	 QWORD PTR j$6[rsp], rax
$LN13@print_matr:
  00481	48 8b 4c 24 28	 mov	 rcx, QWORD PTR m$[rsp]
  00486	e8 00 00 00 00	 call	 ?cols@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::cols
  0048b	48 39 44 24 58	 cmp	 QWORD PTR j$6[rsp], rax
  00490	0f 8d d1 00 00
	00		 jge	 $LN12@print_matr

; 214  :     {
; 215  :       s << fmt.coeffSeparator;

  00496	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  0049e	48 05 c0 00 00
	00		 add	 rax, 192		; 000000c0H
  004a4	48 8b d0	 mov	 rdx, rax
  004a7	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004af	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 216  :       if(width) {

  004b4	48 83 bc 24 f0
	01 00 00 00	 cmp	 QWORD PTR width$[rsp], 0
  004bd	74 7d		 je	 SHORT $LN25@print_matr

; 217  :         s.fill(fmt.fill);

  004bf	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004c7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004ca	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  004ce	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004d6	48 03 c8	 add	 rcx, rax
  004d9	48 8b c1	 mov	 rax, rcx
  004dc	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv323[rsp], rax
  004e4	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  004ec	0f b6 90 e0 00
	00 00		 movzx	 edx, BYTE PTR [rax+224]
  004f3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv323[rsp]
  004fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAADD@Z

; 218  :         s.width(width);

  00501	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00509	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0050c	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00510	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00518	48 03 c8	 add	 rcx, rax
  0051b	48 8b c1	 mov	 rax, rcx
  0051e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv337[rsp], rax
  00526	48 8b 94 24 f0
	01 00 00	 mov	 rdx, QWORD PTR width$[rsp]
  0052e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv337[rsp]
  00536	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEAA_J_J@Z
$LN25@print_matr:

; 219  :       }
; 220  :       s << static_cast<PrintType>(m.coeff(i, j));

  0053c	4c 8b 44 24 58	 mov	 r8, QWORD PTR j$6[rsp]
  00541	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$3[rsp]
  00546	48 8b 4c 24 28	 mov	 rcx, QWORD PTR m$[rsp]
  0054b	e8 00 00 00 00	 call	 ?coeff@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBN_J0@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::coeff
  00550	c5 fb 10 08	 vmovsd	 xmm1, QWORD PTR [rax]
  00554	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0055c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z

; 221  :     }

  00562	e9 0d ff ff ff	 jmp	 $LN11@print_matr
$LN12@print_matr:

; 222  :     s << fmt.rowSuffix;

  00567	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  0056f	48 83 c0 60	 add	 rax, 96			; 00000060H
  00573	48 8b d0	 mov	 rdx, rax
  00576	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0057e	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 223  :     if( i < m.rows() - 1)

  00583	48 8b 4c 24 28	 mov	 rcx, QWORD PTR m$[rsp]
  00588	e8 00 00 00 00	 call	 ?rows@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::rows
  0058d	48 ff c8	 dec	 rax
  00590	48 39 44 24 30	 cmp	 QWORD PTR i$3[rsp], rax
  00595	7d 1e		 jge	 SHORT $LN26@print_matr

; 224  :       s << fmt.rowSeparator;

  00597	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  0059f	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  005a5	48 8b d0	 mov	 rdx, rax
  005a8	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005b0	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
$LN26@print_matr:

; 225  :   }

  005b5	e9 9f fd ff ff	 jmp	 $LN8@print_matr
$LN9@print_matr:

; 226  :   s << fmt.matSuffix;

  005ba	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  005c2	48 83 c0 20	 add	 rax, 32			; 00000020H
  005c6	48 8b d0	 mov	 rdx, rax
  005c9	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005d1	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 227  :   if(explicit_precision) s.precision(old_precision);

  005d6	48 83 7c 24 38
	00		 cmp	 QWORD PTR explicit_precision$[rsp], 0
  005dc	74 38		 je	 SHORT $LN27@print_matr
  005de	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005e6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005e9	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  005ed	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005f5	48 03 c8	 add	 rcx, rax
  005f8	48 8b c1	 mov	 rax, rcx
  005fb	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv379[rsp], rax
  00603	48 8b 54 24 60	 mov	 rdx, QWORD PTR old_precision$[rsp]
  00608	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv379[rsp]
  00610	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?precision@ios_base@std@@QEAA_J_J@Z
$LN27@print_matr:

; 228  :   if(width) {

  00616	48 83 bc 24 f0
	01 00 00 00	 cmp	 QWORD PTR width$[rsp], 0
  0061f	74 73		 je	 SHORT $LN28@print_matr

; 229  :     s.fill(old_fill_character);

  00621	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00629	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0062c	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00630	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00638	48 03 c8	 add	 rcx, rax
  0063b	48 8b c1	 mov	 rax, rcx
  0063e	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv394[rsp], rax
  00646	0f b6 54 24 21	 movzx	 edx, BYTE PTR old_fill_character$[rsp]
  0064b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv394[rsp]
  00653	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAADD@Z

; 230  :     s.width(old_width);

  00659	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00661	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00664	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00668	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00670	48 03 c8	 add	 rcx, rax
  00673	48 8b c1	 mov	 rax, rcx
  00676	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv408[rsp], rax
  0067e	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR old_width$[rsp]
  00686	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv408[rsp]
  0068e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEAA_J_J@Z
$LN28@print_matr:

; 231  :   }
; 232  :   return s;

  00694	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$[rsp]
$LN1@print_matr:

; 233  : }

  0069c	48 8b 8c 24 f8
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  006a4	48 33 cc	 xor	 rcx, rsp
  006a7	e8 00 00 00 00	 call	 __security_check_cookie
  006ac	48 81 c4 08 02
	00 00		 add	 rsp, 520		; 00000208H
  006b3	c3		 ret	 0
??$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z ENDP ; Eigen::internal::print_matrix<Eigen::Matrix<double,1,-1,1,1,-1> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
align_cols$ = 32
old_fill_character$ = 33
m$ = 40
i$3 = 48
explicit_precision$ = 56
tv138 = 64
j$4 = 72
i$5 = 80
j$6 = 88
old_precision$ = 96
tv134 = 104
tv188 = 112
tv204 = 120
tv410 = 128
$T2 = 136
tv272 = 144
tv286 = 152
tv323 = 160
tv337 = 168
tv379 = 176
tv394 = 184
old_width$ = 192
tv408 = 200
$T1 = 208
sstr$7 = 240
width$ = 496
__$ArrayPad$ = 504
s$ = 528
_m$ = 536
fmt$ = 544
?dtor$0@?0???$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z@4HA PROC ; `Eigen::internal::print_matrix<Eigen::Matrix<double,1,-1,1,1,-1> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d f0 00
	00 00		 lea	 rcx, QWORD PTR sstr$7[rbp]
  00010	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$0@?0???$print_matrix@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@internal@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBV?$Matrix@N$00$0?0$00$00$0?0@1@AEBUIOFormat@1@@Z@4HA ENDP ; `Eigen::internal::print_matrix<Eigen::Matrix<double,1,-1,1,1,-1> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\Memory.h
;	COMDAT ??$destruct_elements_of_array@N@internal@Eigen@@YAXPEAN_K@Z
_TEXT	SEGMENT
ptr$ = 8
size$ = 16
??$destruct_elements_of_array@N@internal@Eigen@@YAXPEAN_K@Z PROC ; Eigen::internal::destruct_elements_of_array<double>, COMDAT

; 286  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 287  :   // always destruct an array starting from the end.
; 288  :   if(ptr)

  0000a	48 83 7c 24 08
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  00010	74 17		 je	 SHORT $LN4@destruct_e
$LN2@destruct_e:

; 289  :     while(size) ptr[--size].~T();

  00012	48 83 7c 24 10
	00		 cmp	 QWORD PTR size$[rsp], 0
  00018	74 0f		 je	 SHORT $LN3@destruct_e
  0001a	48 8b 44 24 10	 mov	 rax, QWORD PTR size$[rsp]
  0001f	48 ff c8	 dec	 rax
  00022	48 89 44 24 10	 mov	 QWORD PTR size$[rsp], rax
  00027	eb e9		 jmp	 SHORT $LN2@destruct_e
$LN3@destruct_e:
$LN4@destruct_e:

; 290  : }

  00029	c3		 ret	 0
??$destruct_elements_of_array@N@internal@Eigen@@YAXPEAN_K@Z ENDP ; Eigen::internal::destruct_elements_of_array<double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\Memory.h
;	COMDAT ??$conditional_aligned_free@$00@internal@Eigen@@YAXPEAX@Z
_TEXT	SEGMENT
ptr$ = 48
??$conditional_aligned_free@$00@internal@Eigen@@YAXPEAX@Z PROC ; Eigen::internal::conditional_aligned_free<1>, COMDAT

; 258  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 259  :   aligned_free(ptr);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$[rsp]
  0000e	e8 00 00 00 00	 call	 ?aligned_free@internal@Eigen@@YAXPEAX@Z ; Eigen::internal::aligned_free

; 260  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??$conditional_aligned_free@$00@internal@Eigen@@YAXPEAX@Z ENDP ; Eigen::internal::conditional_aligned_free<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1413 : }

  0000a	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
tv77 = 32
tv75 = 40
$T1 = 48
_Obj$ = 80
<_Args_0>$ = 88
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 231  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 232  : #if _HAS_CXX20
; 233  :     if (_STD is_constant_evaluated()) {

  0000e	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00013	0f b6 c0	 movzx	 eax, al
  00016	85 c0		 test	 eax, eax
  00018	74 2f		 je	 SHORT $LN2@Construct_

; 234  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0001a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR <_Args_0>$[rsp]
  0001f	e8 00 00 00 00	 call	 ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ; std::forward<char * const &>
  00024	48 89 44 24 20	 mov	 QWORD PTR tv77[rsp], rax
  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Obj$[rsp]
  0002e	e8 00 00 00 00	 call	 ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
  00033	48 89 44 24 28	 mov	 QWORD PTR tv75[rsp], rax
  00038	48 8b 54 24 20	 mov	 rdx, QWORD PTR tv77[rsp]
  0003d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv75[rsp]
  00042	e8 00 00 00 00	 call	 ??$construct_at@PEADAEBQEADX@std@@YAPEAPEADQEAPEADAEBQEAD@Z ; std::construct_at<char *,char * const &,void>

; 235  :     } else

  00047	eb 39		 jmp	 SHORT $LN3@Construct_
$LN2@Construct_:

; 236  : #endif // _HAS_CXX20
; 237  :     {
; 238  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Obj$[rsp]
  0004e	e8 00 00 00 00	 call	 ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 ??$_Voidify_iter@PEAPEAD@std@@YAPEAXPEAPEAD@Z ; std::_Voidify_iter<char * *>
  0005b	48 8b d0	 mov	 rdx, rax
  0005e	b9 08 00 00 00	 mov	 ecx, 8
  00063	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00068	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR <_Args_0>$[rsp]
  00072	e8 00 00 00 00	 call	 ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ; std::forward<char * const &>
  00077	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T1[rsp]
  0007c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007f	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN3@Construct_:

; 239  :     }
; 240  : }

  00082	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00086	c3		 ret	 0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@AEAT120@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@AEAT120@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> >::_Bxty>, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Val$[rsp]

; 254  : }

  0000a	c3		 ret	 0
??$addressof@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@AEAT120@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> >::_Bxty>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$construct_at@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$VX@std@@YAPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@QEAT120@@Z
_TEXT	SEGMENT
$T1 = 32
_Location$ = 64
??$construct_at@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$VX@std@@YAPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@QEAT120@@Z PROC ; std::construct_at<std::_String_val<std::_Simple_types<char> >::_Bxty,void>, COMDAT

; 224  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 225  :     _MSVC_CONSTEXPR return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Location$[rsp]
  0000e	e8 00 00 00 00	 call	 ??$_Voidify_iter@PEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAXPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@@Z ; std::_Voidify_iter<std::_String_val<std::_Simple_types<char> >::_Bxty *>
  00013	48 8b d0	 mov	 rdx, rax
  00016	b9 10 00 00 00	 mov	 ecx, 16
  0001b	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00020	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00025	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  0002a	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty

; 226  : }

  0002f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00033	c3		 ret	 0
??$construct_at@T_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@$$VX@std@@YAPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@QEAT120@@Z ENDP ; std::construct_at<std::_String_val<std::_Simple_types<char> >::_Bxty,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Voidify_iter@PEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAXPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAXPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@@Z PROC ; std::_Voidify_iter<std::_String_val<std::_Simple_types<char> >::_Bxty *>, COMDAT

; 212  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 213  :     if constexpr (is_pointer_v<_Iter>) {
; 214  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _It$[rsp]

; 215  :     } else {
; 216  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 217  :     }
; 218  : }

  0000a	c3		 ret	 0
??$_Voidify_iter@PEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAXPEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@0@@Z ENDP ; std::_Voidify_iter<std::_String_val<std::_Simple_types<char> >::_Bxty *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Val$[rsp]

; 254  : }

  0000a	c3		 ret	 0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z PROC		; std::forward<char * &>, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1413 : }

  0000a	c3		 ret	 0
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$construct_at@PEADAEAPEADX@std@@YAPEAPEADQEAPEADAEAPEAD@Z
_TEXT	SEGMENT
$T1 = 32
_Location$ = 64
<_Args_0>$ = 72
??$construct_at@PEADAEAPEADX@std@@YAPEAPEADQEAPEADAEAPEAD@Z PROC ; std::construct_at<char *,char * &,void>, COMDAT

; 224  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 225  :     _MSVC_CONSTEXPR return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Location$[rsp]
  00013	e8 00 00 00 00	 call	 ??$_Voidify_iter@PEAPEAD@std@@YAPEAXPEAPEAD@Z ; std::_Voidify_iter<char * *>
  00018	48 8b d0	 mov	 rdx, rax
  0001b	b9 08 00 00 00	 mov	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00025	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  0002a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR <_Args_0>$[rsp]
  0002f	e8 00 00 00 00	 call	 ??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ; std::forward<char * &>
  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 89 01	 mov	 QWORD PTR [rcx], rax
  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR $T1[rsp]

; 226  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
??$construct_at@PEADAEAPEADX@std@@YAPEAPEADQEAPEADAEAPEAD@Z ENDP ; std::construct_at<char *,char * &,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Voidify_iter@PEAPEAD@std@@YAPEAXPEAPEAD@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAPEAD@std@@YAPEAXPEAPEAD@Z PROC	; std::_Voidify_iter<char * *>, COMDAT

; 212  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 213  :     if constexpr (is_pointer_v<_Iter>) {
; 214  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _It$[rsp]

; 215  :     } else {
; 216  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 217  :     }
; 218  : }

  0000a	c3		 ret	 0
??$_Voidify_iter@PEAPEAD@std@@YAPEAXPEAPEAD@Z ENDP	; std::_Voidify_iter<char * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Ptr_container$ = 32
_Block_size$ = 40
_Ptr$ = 48
_Bytes$ = 80
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 129  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 130  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 131  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR _Bytes$[rsp]
  0000e	48 83 c0 27	 add	 rax, 39			; 00000027H
  00012	48 89 44 24 28	 mov	 QWORD PTR _Block_size$[rsp], rax

; 132  :     if (_Block_size <= _Bytes) {

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR _Bytes$[rsp]
  0001c	48 39 44 24 28	 cmp	 QWORD PTR _Block_size$[rsp], rax
  00021	77 05		 ja	 SHORT $LN8@Allocate_m

; 133  :         _Throw_bad_array_new_length(); // add overflow

  00023	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 134  :     }
; 135  : 
; 136  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00028	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Block_size$[rsp]
  0002d	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
  00032	48 89 44 24 20	 mov	 QWORD PTR _Ptr_container$[rsp], rax
$LN4@Allocate_m:

; 137  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00037	48 83 7c 24 20
	00		 cmp	 QWORD PTR _Ptr_container$[rsp], 0
  0003d	74 02		 je	 SHORT $LN9@Allocate_m
  0003f	eb 0c		 jmp	 SHORT $LN10@Allocate_m
$LN9@Allocate_m:
$LN7@Allocate_m:
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00047	33 c0		 xor	 eax, eax
  00049	85 c0		 test	 eax, eax
  0004b	75 f4		 jne	 SHORT $LN7@Allocate_m
$LN10@Allocate_m:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e4		 jne	 SHORT $LN4@Allocate_m

; 138  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR _Ptr_container$[rsp]
  00058	48 83 c0 27	 add	 rax, 39			; 00000027H
  0005c	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H
  00060	48 89 44 24 30	 mov	 QWORD PTR _Ptr$[rsp], rax

; 139  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00065	b8 08 00 00 00	 mov	 eax, 8
  0006a	48 6b c0 ff	 imul	 rax, rax, -1
  0006e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Ptr$[rsp]
  00073	48 8b 54 24 20	 mov	 rdx, QWORD PTR _Ptr_container$[rsp]
  00078	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 140  : 
; 141  : #ifdef _DEBUG
; 142  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 143  : #endif // _DEBUG
; 144  :     return _Ptr;

  0007c	48 8b 44 24 30	 mov	 rax, QWORD PTR _Ptr$[rsp]
$LN11@Allocate_m:

; 145  : }

  00081	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00085	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\MatrixBase.h
;	COMDAT ??0?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@XZ PROC ; Eigen::MatrixBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::MatrixBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >, COMDAT

; 485  :     EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(MatrixBase)

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??0?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@XZ ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >
  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
??0?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@XZ ENDP ; Eigen::MatrixBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::MatrixBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\IO.h
;	COMDAT ?run@?$significant_decimals_impl@N@internal@Eigen@@SAHXZ
_TEXT	SEGMENT
?run@?$significant_decimals_impl@N@internal@Eigen@@SAHXZ PROC ; Eigen::internal::significant_decimals_impl<double>::run, COMDAT

; 123  :   {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 124  :     return NumTraits<Scalar>::digits10();

  00004	e8 00 00 00 00	 call	 ?digits10@?$GenericNumTraits@N@Eigen@@SAHXZ ; Eigen::GenericNumTraits<double>::digits10

; 125  :   }

  00009	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000d	c3		 ret	 0
?run@?$significant_decimals_impl@N@internal@Eigen@@SAHXZ ENDP ; Eigen::internal::significant_decimals_impl<double>::run
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ?coeff@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBN_J0@Z
_TEXT	SEGMENT
tv76 = 32
tv78 = 40
tv88 = 48
tv90 = 56
this$ = 80
rowId$ = 88
colId$ = 96
?coeff@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBN_J0@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::coeff, COMDAT

; 153  :     {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 154  :       if(Flags & RowMajorBit)

  00013	33 c0		 xor	 eax, eax
  00015	83 f8 01	 cmp	 eax, 1
  00018	74 53		 je	 SHORT $LN2@coeff

; 155  :         return m_storage.data()[colId + rowId * m_storage.cols()];

  0001a	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?data@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEBAPEBNXZ ; Eigen::DenseStorage<double,-1,1,-1,1>::data
  00027	48 89 44 24 28	 mov	 QWORD PTR tv78[rsp], rax
  0002c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 ?cols@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEBA_JXZ ; Eigen::DenseStorage<double,-1,1,-1,1>::cols
  00039	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rowId$[rsp]
  0003e	48 0f af c8	 imul	 rcx, rax
  00042	48 8b c1	 mov	 rax, rcx
  00045	48 8b 4c 24 60	 mov	 rcx, QWORD PTR colId$[rsp]
  0004a	48 03 c8	 add	 rcx, rax
  0004d	48 8b c1	 mov	 rax, rcx
  00050	48 c1 e0 03	 shl	 rax, 3
  00054	48 89 44 24 20	 mov	 QWORD PTR tv76[rsp], rax
  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR tv76[rsp]
  0005e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv78[rsp]
  00063	48 03 c8	 add	 rcx, rax
  00066	48 8b c1	 mov	 rax, rcx
  00069	eb 49		 jmp	 SHORT $LN1@coeff
  0006b	eb 47		 jmp	 SHORT $LN3@coeff
$LN2@coeff:

; 156  :       else // column-major
; 157  :         return m_storage.data()[rowId + colId * m_storage.rows()];

  0006d	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 ?data@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@QEBAPEBNXZ ; Eigen::DenseStorage<double,-1,1,-1,1>::data
  0007a	48 89 44 24 38	 mov	 QWORD PTR tv90[rsp], rax
  0007f	e8 00 00 00 00	 call	 ?rows@?$DenseStorage@N$0?0$00$0?0$00@Eigen@@SA_JXZ ; Eigen::DenseStorage<double,-1,1,-1,1>::rows
  00084	48 8b 4c 24 60	 mov	 rcx, QWORD PTR colId$[rsp]
  00089	48 0f af c8	 imul	 rcx, rax
  0008d	48 8b c1	 mov	 rax, rcx
  00090	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rowId$[rsp]
  00095	48 03 c8	 add	 rcx, rax
  00098	48 8b c1	 mov	 rax, rcx
  0009b	48 c1 e0 03	 shl	 rax, 3
  0009f	48 89 44 24 30	 mov	 QWORD PTR tv88[rsp], rax
  000a4	48 8b 44 24 30	 mov	 rax, QWORD PTR tv88[rsp]
  000a9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv90[rsp]
  000ae	48 03 c8	 add	 rcx, rax
  000b1	48 8b c1	 mov	 rax, rcx
$LN3@coeff:
$LN1@coeff:

; 158  :     }

  000b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b8	c3		 ret	 0
?coeff@?$PlainObjectBase@V?$Matrix@N$00$0?0$00$00$0?0@Eigen@@@Eigen@@QEBAAEBN_J0@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,1,-1,1,1,-1> >::coeff
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ?_check_template_params@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@SAXXZ
_TEXT	SEGMENT
?_check_template_params@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@SAXXZ PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::_check_template_params, COMDAT

; 970  :       EIGEN_STATIC_ASSERT((EIGEN_IMPLIES(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1, (int(Options)&RowMajor)==RowMajor)
; 971  :                         && EIGEN_IMPLIES(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1, (int(Options)&RowMajor)==0)
; 972  :                         && ((RowsAtCompileTime == Dynamic) || (RowsAtCompileTime >= 0))
; 973  :                         && ((ColsAtCompileTime == Dynamic) || (ColsAtCompileTime >= 0))
; 974  :                         && ((MaxRowsAtCompileTime == Dynamic) || (MaxRowsAtCompileTime >= 0))
; 975  :                         && ((MaxColsAtCompileTime == Dynamic) || (MaxColsAtCompileTime >= 0))
; 976  :                         && (MaxRowsAtCompileTime == RowsAtCompileTime || RowsAtCompileTime==Dynamic)
; 977  :                         && (MaxColsAtCompileTime == ColsAtCompileTime || ColsAtCompileTime==Dynamic)
; 978  :                         && (Options & (DontAlign|RowMajor)) == Options),
; 979  :         INVALID_MATRIX_TEMPLATE_PARAMETERS)
; 980  :     }

  00000	c2 00 00	 ret	 0
?_check_template_params@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@SAXXZ ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::_check_template_params
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseStorage.h
;	COMDAT ??0?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ PROC	; Eigen::DenseStorage<double,-1,-1,-1,0>::DenseStorage<double,-1,-1,-1,0>, COMDAT

; 419  :     EIGEN_DEVICE_FUNC DenseStorage() : m_data(0), m_rows(0), m_cols(0) {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00016	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  0001e	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00023	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
  0002b	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00030	c3		 ret	 0
??0?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAA@XZ ENDP	; Eigen::DenseStorage<double,-1,-1,-1,0>::DenseStorage<double,-1,-1,-1,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseBase.h
;	COMDAT ??0?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@XZ PROC ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >, COMDAT

; 681  :     EIGEN_DEVICE_FUNC DenseBase()

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 682  :     {
; 683  :       /* Just checks for self-consistency of the flags.
; 684  :        * Only do it when debugging Eigen, as this borders on paranoia and could slow compilation down
; 685  :        */
; 686  : #ifdef EIGEN_INTERNAL_DEBUGGING
; 687  :       EIGEN_STATIC_ASSERT((EIGEN_IMPLIES(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1, int(IsRowMajor))
; 688  :                         && EIGEN_IMPLIES(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1, int(!IsRowMajor))),
; 689  :                           INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION)
; 690  : #endif
; 691  :     }

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
??0?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAA@XZ ENDP ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\sstream
;	COMDAT ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
__$ReturnUdt$ = 72
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT

; 857  :     {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0

; 858  :         return _Stringbuffer.str();

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001b	48 83 c0 18	 add	 rax, 24
  0001f	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
  00024	48 8b 54 24 48	 mov	 rdx, QWORD PTR __$ReturnUdt$[rsp]
  00029	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv69[rsp]
  0002e	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
  00033	8b 44 24 20	 mov	 eax, DWORD PTR $T1[rsp]
  00037	83 c8 01	 or	 eax, 1
  0003a	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax
  0003e	48 8b 44 24 48	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 859  :     }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	c3		 ret	 0
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\sstream
;	COMDAT ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv163 = 40
this$ = 64
$initVBases$ = 72
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 791  :     basic_stringstream() : _Mybase(_STD addressof(_Stringbuffer)), _Stringbuffer(ios_base::in | ios_base::out) {}

$LN8:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0
  00015	83 7c 24 48 00	 cmp	 DWORD PTR $initVBases$[rsp], 0
  0001a	74 3f		 je	 SHORT $LN2@basic_stri
  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  00028	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00037	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00040	48 05 98 00 00
	00		 add	 rax, 152		; 00000098H
  00046	48 8b c8	 mov	 rcx, rax
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0004f	90		 npad	 1
  00050	8b 44 24 20	 mov	 eax, DWORD PTR $T1[rsp]
  00054	83 c8 01	 or	 eax, 1
  00057	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax
$LN2@basic_stri:
  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00060	48 83 c0 18	 add	 rax, 24
  00064	48 8b c8	 mov	 rcx, rax
  00067	e8 00 00 00 00	 call	 ??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > >
  0006c	45 33 c0	 xor	 r8d, r8d
  0006f	48 8b d0	 mov	 rdx, rax
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  0007d	90		 npad	 1
  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00083	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00086	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0008a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00096	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  0009a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0009f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a2	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000a6	48 2d 98 00 00
	00		 sub	 rax, 152		; 00000098H
  000ac	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000b1	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b4	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  000b8	48 8b 54 24 40	 mov	 rdx, QWORD PTR this$[rsp]
  000bd	89 44 0a fc	 mov	 DWORD PTR [rdx+rcx-4], eax
  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000c6	48 83 c0 18	 add	 rax, 24
  000ca	48 89 44 24 28	 mov	 QWORD PTR tv163[rsp], rax
  000cf	ba 03 00 00 00	 mov	 edx, 3
  000d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv163[rsp]
  000d9	e8 00 00 00 00	 call	 ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  000de	90		 npad	 1
  000df	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000e4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e8	c3		 ret	 0
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv163 = 40
this$ = 64
$initVBases$ = 72
?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0001b	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv163 = 40
this$ = 64
$initVBases$ = 72
?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  0002e	40 55		 push	 rbp
  00030	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00034	48 8b ea	 mov	 rbp, rdx
  00037	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0003b	48 83 c1 20	 add	 rcx, 32			; 00000020H
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5d		 pop	 rbp
  0004a	c3		 ret	 0
?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\sstream
;	COMDAT ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = 32
_View$ = 40
_Result$ = 64
__$ArrayPad$ = 96
this$ = 128
__$ReturnUdt$ = 136
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT

; 155  :     {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0

; 156  :         _Mystr _Result(_Al);

  00025	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0002d	48 83 c0 74	 add	 rax, 116		; 00000074H
  00031	48 8b d0	 mov	 rdx, rax
  00034	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Result$[rsp]
  00039	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003e	90		 npad	 1

; 157  :         const auto _View = _Get_buffer_view();

  0003f	48 8d 54 24 28	 lea	 rdx, QWORD PTR _View$[rsp]
  00044	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0004c	e8 00 00 00 00	 call	 ?_Get_buffer_view@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AU_Buffer_view@12@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Get_buffer_view

; 158  :         if (_View._Ptr) {

  00051	48 83 7c 24 28
	00		 cmp	 QWORD PTR _View$[rsp], 0
  00057	74 14		 je	 SHORT $LN2@str

; 159  :             _Result.assign(_View._Ptr, _View._Size);

  00059	4c 8b 44 24 30	 mov	 r8, QWORD PTR _View$[rsp+8]
  0005e	48 8b 54 24 28	 mov	 rdx, QWORD PTR _View$[rsp]
  00063	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Result$[rsp]
  00068	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@str:

; 160  :         }
; 161  :         return _Result;

  0006d	48 8d 54 24 40	 lea	 rdx, QWORD PTR _Result$[rsp]
  00072	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ReturnUdt$[rsp]
  0007a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0007f	8b 44 24 20	 mov	 eax, DWORD PTR $T1[rsp]
  00083	83 c8 01	 or	 eax, 1
  00086	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax
  0008a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Result$[rsp]
  0008f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00094	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 162  :     }

  0009c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a1	48 33 cc	 xor	 rcx, rsp
  000a4	e8 00 00 00 00	 call	 __security_check_cookie
  000a9	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000ad	c3		 ret	 0
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_View$ = 40
_Result$ = 64
__$ArrayPad$ = 96
this$ = 128
__$ReturnUdt$ = 136
?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA PROC ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 40	 lea	 rcx, QWORD PTR _Result$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0??str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEGBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA ENDP ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\sstream
;	COMDAT ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
_TEXT	SEGMENT
this$ = 48
_Mode$ = 56
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 37   :     explicit basic_stringbuf(ios_base::openmode _Mode) : _Seekhigh(nullptr), _Mystate(_Getstate(_Mode)), _Al() {}

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00018	90		 npad	 1
  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00025	48 89 08	 mov	 QWORD PTR [rax], rcx
  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002d	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
  00035	8b 4c 24 38	 mov	 ecx, DWORD PTR _Mode$[rsp]
  00039	e8 00 00 00 00	 call	 ?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
  0003e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00043	89 41 70	 mov	 DWORD PTR [rcx+112], eax
  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0004b	48 83 c0 74	 add	 rax, 116		; 00000074H
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QEAA@XZ ; std::allocator<char>::allocator<char>
  00057	90		 npad	 1
  00058	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0005d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00061	c3		 ret	 0
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Mode$ = 56
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 30	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\NumTraits.h
;	COMDAT ?digits10@?$GenericNumTraits@N@Eigen@@SAHXZ
_TEXT	SEGMENT
?digits10@?$GenericNumTraits@N@Eigen@@SAHXZ PROC	; Eigen::GenericNumTraits<double>::digits10, COMDAT

; 181  :   {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 182  :     return internal::default_digits10_impl<T>::run();

  00004	e8 00 00 00 00	 call	 ?run@?$default_digits10_impl@N$00$0A@@internal@Eigen@@SAHXZ ; Eigen::internal::default_digits10_impl<double,1,0>::run

; 183  :   }

  00009	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000d	c3		 ret	 0
?digits10@?$GenericNumTraits@N@Eigen@@SAHXZ ENDP	; Eigen::GenericNumTraits<double>::digits10
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\NumTraits.h
;	COMDAT ?run@?$default_digits10_impl@N$00$0A@@internal@Eigen@@SAHXZ
_TEXT	SEGMENT
?run@?$default_digits10_impl@N$00$0A@@internal@Eigen@@SAHXZ PROC ; Eigen::internal::default_digits10_impl<double,1,0>::run, COMDAT

; 25   :   static int run() { return std::numeric_limits<T>::digits10; }

  00000	b8 0f 00 00 00	 mov	 eax, 15
  00005	c3		 ret	 0
?run@?$default_digits10_impl@N$00$0A@@internal@Eigen@@SAHXZ ENDP ; Eigen::internal::default_digits10_impl<double,1,0>::run
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\sstream
;	COMDAT ?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z
_TEXT	SEGMENT
_State$ = 0
_Mode$ = 32
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate, COMDAT

; 502  :     static int _Getstate(ios_base::openmode _Mode) { // convert open mode to stream state bits

$LN7:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 503  :         int _State = 0;

  00008	c7 04 24 00 00
	00 00		 mov	 DWORD PTR _State$[rsp], 0

; 504  :         if (!(_Mode & ios_base::in)) {

  0000f	8b 44 24 20	 mov	 eax, DWORD PTR _Mode$[rsp]
  00013	83 e0 01	 and	 eax, 1
  00016	85 c0		 test	 eax, eax
  00018	75 09		 jne	 SHORT $LN2@Getstate

; 505  :             _State |= _Noread;

  0001a	8b 04 24	 mov	 eax, DWORD PTR _State$[rsp]
  0001d	83 c8 04	 or	 eax, 4
  00020	89 04 24	 mov	 DWORD PTR _State$[rsp], eax
$LN2@Getstate:

; 506  :         }
; 507  : 
; 508  :         if (!(_Mode & ios_base::out)) {

  00023	8b 44 24 20	 mov	 eax, DWORD PTR _Mode$[rsp]
  00027	83 e0 02	 and	 eax, 2
  0002a	85 c0		 test	 eax, eax
  0002c	75 09		 jne	 SHORT $LN3@Getstate

; 509  :             _State |= _Constant;

  0002e	8b 04 24	 mov	 eax, DWORD PTR _State$[rsp]
  00031	83 c8 02	 or	 eax, 2
  00034	89 04 24	 mov	 DWORD PTR _State$[rsp], eax
$LN3@Getstate:

; 510  :         }
; 511  : 
; 512  :         if (_Mode & ios_base::app) {

  00037	8b 44 24 20	 mov	 eax, DWORD PTR _Mode$[rsp]
  0003b	83 e0 08	 and	 eax, 8
  0003e	85 c0		 test	 eax, eax
  00040	74 09		 je	 SHORT $LN4@Getstate

; 513  :             _State |= _Append;

  00042	8b 04 24	 mov	 eax, DWORD PTR _State$[rsp]
  00045	83 c8 08	 or	 eax, 8
  00048	89 04 24	 mov	 DWORD PTR _State$[rsp], eax
$LN4@Getstate:

; 514  :         }
; 515  : 
; 516  :         if (_Mode & ios_base::ate) {

  0004b	8b 44 24 20	 mov	 eax, DWORD PTR _Mode$[rsp]
  0004f	83 e0 04	 and	 eax, 4
  00052	85 c0		 test	 eax, eax
  00054	74 09		 je	 SHORT $LN5@Getstate

; 517  :             _State |= _Atend;

  00056	8b 04 24	 mov	 eax, DWORD PTR _State$[rsp]
  00059	83 c8 10	 or	 eax, 16
  0005c	89 04 24	 mov	 DWORD PTR _State$[rsp], eax
$LN5@Getstate:

; 518  :         }
; 519  : 
; 520  :         return _State;

  0005f	8b 04 24	 mov	 eax, DWORD PTR _State$[rsp]

; 521  :     }

  00062	48 83 c4 18	 add	 rsp, 24
  00066	c3		 ret	 0
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\sstream
;	COMDAT ?_Get_buffer_view@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AU_Buffer_view@12@XZ
_TEXT	SEGMENT
_Base$2 = 32
_Base$3 = 40
$T1 = 48
_Result$ = 56
__$ArrayPad$ = 80
this$ = 128
__$ReturnUdt$ = 136
?_Get_buffer_view@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AU_Buffer_view@12@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Get_buffer_view, COMDAT

; 132  :     _NODISCARD _Buffer_view _Get_buffer_view() const noexcept {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 133  :         _Buffer_view _Result{};

  0001f	48 8d 44 24 38	 lea	 rax, QWORD PTR _Result$[rsp]
  00024	48 8b f8	 mov	 rdi, rax
  00027	33 c0		 xor	 eax, eax
  00029	b9 18 00 00 00	 mov	 ecx, 24
  0002e	f3 aa		 rep stosb

; 134  :         if ((!(_Mystate & _Constant) || (_Mystate & _From_rvalue)) && _Mysb::pptr()) {

  00030	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00038	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0003b	83 e0 02	 and	 eax, 2
  0003e	85 c0		 test	 eax, eax
  00040	74 16		 je	 SHORT $LN4@Get_buffer
  00042	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0004a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0004d	83 e0 20	 and	 eax, 32			; 00000020H
  00050	85 c0		 test	 eax, eax
  00052	0f 84 86 00 00
	00		 je	 $LN2@Get_buffer
$LN4@Get_buffer:
  00058	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00066	48 85 c0	 test	 rax, rax
  00069	74 73		 je	 SHORT $LN2@Get_buffer

; 135  :             // writable, make string view from write buffer
; 136  :             const auto _Base = _Mysb::pbase();

  0006b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00079	48 89 44 24 20	 mov	 QWORD PTR _Base$2[rsp], rax

; 137  :             _Result._Ptr     = _Base;

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR _Base$2[rsp]
  00083	48 89 44 24 38	 mov	 QWORD PTR _Result$[rsp], rax

; 138  :             _Result._Size    = static_cast<_Mysize_type>((_STD max)(_Mysb::pptr(), _Seekhigh) - _Base);

  00088	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00096	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  0009b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000a3	48 83 c0 68	 add	 rax, 104		; 00000068H
  000a7	48 8b d0	 mov	 rdx, rax
  000aa	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  000af	e8 00 00 00 00	 call	 ??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z ; std::max<char *>
  000b4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _Base$2[rsp]
  000b9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000bc	48 2b c1	 sub	 rax, rcx
  000bf	48 89 44 24 40	 mov	 QWORD PTR _Result$[rsp+8], rax

; 139  :             _Result._Res     = static_cast<_Mysize_type>(_Mysb::epptr() - _Base);

  000c4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  000d2	48 2b 44 24 20	 sub	 rax, QWORD PTR _Base$2[rsp]
  000d7	48 89 44 24 48	 mov	 QWORD PTR _Result$[rsp+16], rax
  000dc	eb 64		 jmp	 SHORT $LN3@Get_buffer
$LN2@Get_buffer:

; 140  :         } else if (!(_Mystate & _Noread) && _Mysb::gptr()) {

  000de	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000e6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000e9	83 e0 04	 and	 eax, 4
  000ec	85 c0		 test	 eax, eax
  000ee	75 52		 jne	 SHORT $LN3@Get_buffer
  000f0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  000fe	48 85 c0	 test	 rax, rax
  00101	74 3f		 je	 SHORT $LN3@Get_buffer

; 141  :             // readable, make string view from read buffer
; 142  :             const auto _Base = _Mysb::eback();

  00103	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  00111	48 89 44 24 28	 mov	 QWORD PTR _Base$3[rsp], rax

; 143  :             _Result._Ptr     = _Base;

  00116	48 8b 44 24 28	 mov	 rax, QWORD PTR _Base$3[rsp]
  0011b	48 89 44 24 38	 mov	 QWORD PTR _Result$[rsp], rax

; 144  :             _Result._Size    = static_cast<_Mysize_type>(_Mysb::egptr() - _Base);

  00120	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
  0012e	48 2b 44 24 28	 sub	 rax, QWORD PTR _Base$3[rsp]
  00133	48 89 44 24 40	 mov	 QWORD PTR _Result$[rsp+8], rax

; 145  :             _Result._Res     = _Result._Size;

  00138	48 8b 44 24 40	 mov	 rax, QWORD PTR _Result$[rsp+8]
  0013d	48 89 44 24 48	 mov	 QWORD PTR _Result$[rsp+16], rax
$LN3@Get_buffer:

; 146  :         }
; 147  :         return _Result;

  00142	48 8d 44 24 38	 lea	 rax, QWORD PTR _Result$[rsp]
  00147	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR __$ReturnUdt$[rsp]
  0014f	48 8b f0	 mov	 rsi, rax
  00152	b9 18 00 00 00	 mov	 ecx, 24
  00157	f3 a4		 rep movsb
  00159	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 148  :     }

  00161	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00166	48 33 cc	 xor	 rcx, rsp
  00169	e8 00 00 00 00	 call	 __security_check_cookie
  0016e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00172	5f		 pop	 rdi
  00173	5e		 pop	 rsi
  00174	c3		 ret	 0
?_Get_buffer_view@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AU_Buffer_view@12@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Get_buffer_view
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_Old_ptr$3 = 40
this$ = 64
_Ptr$ = 72
_Count$ = 80
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 3454 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3455 :         // assign [_Ptr, _Ptr + _Count)
; 3456 :         if (_Count <= _Mypair._Myval2._Myres) {

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0001c	48 39 44 24 50	 cmp	 QWORD PTR _Count$[rsp], rax
  00021	77 5d		 ja	 SHORT $LN2@assign

; 3457 :             _ASAN_STRING_MODIFY(static_cast<difference_type>(_Count - _Mypair._Myval2._Mysize));
; 3458 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00030	48 89 44 24 28	 mov	 QWORD PTR _Old_ptr$3[rsp], rax

; 3459 :             _Mypair._Myval2._Mysize = _Count;

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0003a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Count$[rsp]
  0003f	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 3460 :             _Traits::move(_Old_ptr, _Ptr, _Count);

  00043	4c 8b 44 24 50	 mov	 r8, QWORD PTR _Count$[rsp]
  00048	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  0004d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Old_ptr$3[rsp]
  00052	e8 00 00 00 00	 call	 ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 3461 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00057	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0
  0005c	48 8b 44 24 50	 mov	 rax, QWORD PTR _Count$[rsp]
  00061	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Old_ptr$3[rsp]
  00066	48 03 c8	 add	 rcx, rax
  00069	48 8b c1	 mov	 rax, rcx
  0006c	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00071	48 8b c8	 mov	 rcx, rax
  00074	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3462 :             return *this;

  00079	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0007e	eb 1a		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3463 :         }
; 3464 : 
; 3465 :         return _Reallocate_for(

  00080	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Ptr$[rsp]
  00085	44 0f b6 44 24
	21		 movzx	 r8d, BYTE PTR $T2[rsp]
  0008b	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Count$[rsp]
  00090	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00095	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
$LN1@assign:

; 3466 :             _Count,
; 3467 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3468 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3469 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3470 :             },
; 3471 :             _Ptr);
; 3472 :     }

  0009a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009e	c3		 ret	 0
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_ptr$ = 72
_Count$ = 80
_Ptr$ = 88
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator(), COMDAT

; 3467 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3468 :                 _Traits::copy(_New_ptr, _Ptr, _Count);

  00018	4c 8b 44 24 50	 mov	 r8, QWORD PTR _Count$[rsp]
  0001d	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  00022	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  00027	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3469 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0002c	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0
  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR _Count$[rsp]
  00036	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  0003b	48 03 c8	 add	 rcx, rax
  0003e	48 8b c1	 mov	 rax, rcx
  00041	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00046	48 8b c8	 mov	 rcx, rax
  00049	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3470 :             },

  0004e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00052	c3		 ret	 0
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
tv82 = 48
this$ = 80
_Al$ = 88
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2580 :     _CONSTEXPR20 explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  00018	4c 8b 44 24 58	 mov	 r8, QWORD PTR _Al$[rsp]
  0001d	0f b6 54 24 20	 movzx	 edx, BYTE PTR $T1[rsp]
  00022	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv70[rsp]
  00027	e8 00 00 00 00	 call	 ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>

; 2581 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  0002c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00031	48 89 44 24 30	 mov	 QWORD PTR tv82[rsp], rax
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv82[rsp]
  00042	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 2582 :         _Tidy_init();

  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0004c	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2583 :     }

  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00056	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005a	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv75 = 32
tv73 = 40
_Ostr$ = 64
_Str$ = 72
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 5255 :     basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5256 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Str$[rsp]
  00013	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00018	48 89 44 24 20	 mov	 QWORD PTR tv75[rsp], rax
  0001d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _Str$[rsp]
  00022	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  00027	48 89 44 24 28	 mov	 QWORD PTR tv73[rsp], rax
  0002c	4c 8b 44 24 20	 mov	 r8, QWORD PTR tv75[rsp]
  00031	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv73[rsp]
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  0003b	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>

; 5257 : }

  00040	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00044	c3		 ret	 0
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT

; 1380 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Val1$[rsp]
  00017	e8 00 00 00 00	 call	 ??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ; std::forward<std::allocator<char> const &>
  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ??$resizeLike@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z
_TEXT	SEGMENT
other$ = 32
othersize$ = 40
tv83 = 48
tv81 = 56
tv89 = 64
tv191 = 72
tv189 = 80
this$ = 112
_other$ = 120
??$resizeLike@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::resizeLike<Eigen::Matrix<double,28,28,0,28,28> >, COMDAT

; 355  :     {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 356  :       const OtherDerived& other = _other.derived();

  0000e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _other$[rsp]
  00013	e8 00 00 00 00	 call	 ?derived@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::derived
  00018	48 89 44 24 20	 mov	 QWORD PTR other$[rsp], rax

; 357  :       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(other.rows(), other.cols());

  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR other$[rsp]
  00022	e8 00 00 00 00	 call	 ?cols@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::cols
  00027	48 89 44 24 30	 mov	 QWORD PTR tv83[rsp], rax
  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR other$[rsp]
  00031	e8 00 00 00 00	 call	 ?rows@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::rows
  00036	48 89 44 24 38	 mov	 QWORD PTR tv81[rsp], rax
  0003b	48 8b 54 24 30	 mov	 rdx, QWORD PTR tv83[rsp]
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv81[rsp]
  00045	e8 00 00 00 00	 call	 ??$run@_J@?$check_rows_cols_for_overflow@$0?0@internal@Eigen@@SAX_J0@Z ; Eigen::internal::check_rows_cols_for_overflow<-1>::run<__int64>

; 358  :       const Index othersize = other.rows()*other.cols();

  0004a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR other$[rsp]
  0004f	e8 00 00 00 00	 call	 ?rows@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::rows
  00054	48 89 44 24 40	 mov	 QWORD PTR tv89[rsp], rax
  00059	48 8b 4c 24 20	 mov	 rcx, QWORD PTR other$[rsp]
  0005e	e8 00 00 00 00	 call	 ?cols@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::cols
  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv89[rsp]
  00068	48 0f af c8	 imul	 rcx, rax
  0006c	48 8b c1	 mov	 rax, rcx
  0006f	48 89 44 24 28	 mov	 QWORD PTR othersize$[rsp], rax

; 359  :       if(RowsAtCompileTime == 1)

  00074	33 c0		 xor	 eax, eax
  00076	85 c0		 test	 eax, eax
  00078	74 55		 je	 SHORT $LN2@resizeLike

; 360  :       {
; 361  :         eigen_assert(other.rows() == 1 || other.cols() == 1);

  0007a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR other$[rsp]
  0007f	e8 00 00 00 00	 call	 ?rows@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::rows
  00084	48 83 f8 01	 cmp	 rax, 1
  00088	74 2c		 je	 SHORT $LN7@resizeLike
  0008a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR other$[rsp]
  0008f	e8 00 00 00 00	 call	 ?cols@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::cols
  00094	48 83 f8 01	 cmp	 rax, 1
  00098	74 1c		 je	 SHORT $LN7@resizeLike
  0009a	41 b8 69 01 00
	00		 mov	 r8d, 361		; 00000169H
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1MO@IEDNFCAN@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@NAOGFKEJ@?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN@
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b4	33 c0		 xor	 eax, eax
$LN7@resizeLike:

; 362  :         resize(1, othersize);

  000b6	4c 8b 44 24 28	 mov	 r8, QWORD PTR othersize$[rsp]
  000bb	ba 01 00 00 00	 mov	 edx, 1
  000c0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  000c5	e8 00 00 00 00	 call	 ?resize@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAX_J0@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::resize

; 363  :       }

  000ca	e9 8b 00 00 00	 jmp	 $LN3@resizeLike
$LN2@resizeLike:

; 364  :       else if(ColsAtCompileTime == 1)

  000cf	33 c0		 xor	 eax, eax
  000d1	85 c0		 test	 eax, eax
  000d3	74 53		 je	 SHORT $LN4@resizeLike

; 365  :       {
; 366  :         eigen_assert(other.rows() == 1 || other.cols() == 1);

  000d5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR other$[rsp]
  000da	e8 00 00 00 00	 call	 ?rows@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::rows
  000df	48 83 f8 01	 cmp	 rax, 1
  000e3	74 2c		 je	 SHORT $LN8@resizeLike
  000e5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR other$[rsp]
  000ea	e8 00 00 00 00	 call	 ?cols@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::cols
  000ef	48 83 f8 01	 cmp	 rax, 1
  000f3	74 1c		 je	 SHORT $LN8@resizeLike
  000f5	41 b8 6e 01 00
	00		 mov	 r8d, 366		; 0000016eH
  000fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1MO@IEDNFCAN@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@NAOGFKEJ@?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN@
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0010f	33 c0		 xor	 eax, eax
$LN8@resizeLike:

; 367  :         resize(othersize, 1);

  00111	41 b8 01 00 00
	00		 mov	 r8d, 1
  00117	48 8b 54 24 28	 mov	 rdx, QWORD PTR othersize$[rsp]
  0011c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00121	e8 00 00 00 00	 call	 ?resize@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAX_J0@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::resize

; 368  :       }

  00126	eb 32		 jmp	 SHORT $LN5@resizeLike
$LN4@resizeLike:

; 369  :       else resize(other.rows(), other.cols());

  00128	48 8b 4c 24 20	 mov	 rcx, QWORD PTR other$[rsp]
  0012d	e8 00 00 00 00	 call	 ?cols@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::cols
  00132	48 89 44 24 48	 mov	 QWORD PTR tv191[rsp], rax
  00137	48 8b 4c 24 20	 mov	 rcx, QWORD PTR other$[rsp]
  0013c	e8 00 00 00 00	 call	 ?rows@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::rows
  00141	48 89 44 24 50	 mov	 QWORD PTR tv189[rsp], rax
  00146	4c 8b 44 24 48	 mov	 r8, QWORD PTR tv191[rsp]
  0014b	48 8b 54 24 50	 mov	 rdx, QWORD PTR tv189[rsp]
  00150	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00155	e8 00 00 00 00	 call	 ?resize@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAX_J0@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::resize
$LN5@resizeLike:
$LN3@resizeLike:

; 370  :     }

  0015a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0015e	c3		 ret	 0
??$resizeLike@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::resizeLike<Eigen::Matrix<double,28,28,0,28,28> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ??$_set_noalias@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv82 = 40
tv80 = 48
this$ = 80
other$ = 88
??$_set_noalias@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::_set_noalias<Eigen::Matrix<double,28,28,0,28,28> >, COMDAT

; 791  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 792  :       // I don't think we need this resize call since the lazyAssign will anyways resize
; 793  :       // and lazyAssign will be called by the assign selector.
; 794  :       //_resize_to_match(other);
; 795  :       // the 'false' below means to enforce lazy evaluation. We don't use lazyAssign() because
; 796  :       // it wouldn't allow to copy a row-vector into a column-vector.
; 797  :       internal::call_assignment_no_alias(this->derived(), other.derived(), internal::assign_op<Scalar,typename OtherDerived::Scalar>());

  0000e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR other$[rsp]
  00013	e8 00 00 00 00	 call	 ?derived@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::derived
  00018	48 89 44 24 28	 mov	 QWORD PTR tv82[rsp], rax
  0001d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00022	e8 00 00 00 00	 call	 ?derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::derived
  00027	48 89 44 24 30	 mov	 QWORD PTR tv80[rsp], rax
  0002c	4c 8d 44 24 20	 lea	 r8, QWORD PTR $T1[rsp]
  00031	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv82[rsp]
  00036	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv80[rsp]
  0003b	e8 00 00 00 00	 call	 ??$call_assignment_no_alias@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z ; Eigen::internal::call_assignment_no_alias<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,Eigen::internal::assign_op<double,double> >

; 798  :       return this->derived();

  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00045	e8 00 00 00 00	 call	 ?derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::derived

; 799  :     }

  0004a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004e	c3		 ret	 0
??$_set_noalias@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@1@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::_set_noalias<Eigen::Matrix<double,28,28,0,28,28> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\utility
;	COMDAT ??$max@_J@std@@YAAEB_JAEB_J0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$max@_J@std@@YAAEB_JAEB_J0@Z PROC			; std::max<__int64>, COMDAT

; 41   :     (max) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 42   :     // return larger of _Left and _Right
; 43   :     return _Left < _Right ? _Right : _Left;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR _Left$[rsp]
  00013	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _Right$[rsp]
  00018	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001e	7d 0b		 jge	 SHORT $LN3@max
  00020	48 8b 44 24 28	 mov	 rax, QWORD PTR _Right$[rsp]
  00025	48 89 04 24	 mov	 QWORD PTR tv65[rsp], rax
  00029	eb 09		 jmp	 SHORT $LN4@max
$LN3@max:
  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR _Left$[rsp]
  00030	48 89 04 24	 mov	 QWORD PTR tv65[rsp], rax
$LN4@max:
  00034	48 8b 04 24	 mov	 rax, QWORD PTR tv65[rsp]
  00038	48 89 44 24 08	 mov	 QWORD PTR $T1[rsp], rax
  0003d	48 8b 44 24 08	 mov	 rax, QWORD PTR $T1[rsp]

; 44   : }

  00042	48 83 c4 18	 add	 rsp, 24
  00046	c3		 ret	 0
??$max@_J@std@@YAAEB_JAEB_J0@Z ENDP			; std::max<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1413 : }

  0000a	c3		 ret	 0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$construct_at@PEADAEBQEADX@std@@YAPEAPEADQEAPEADAEBQEAD@Z
_TEXT	SEGMENT
$T1 = 32
_Location$ = 64
<_Args_0>$ = 72
??$construct_at@PEADAEBQEADX@std@@YAPEAPEADQEAPEADAEBQEAD@Z PROC ; std::construct_at<char *,char * const &,void>, COMDAT

; 224  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 225  :     _MSVC_CONSTEXPR return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Location$[rsp]
  00013	e8 00 00 00 00	 call	 ??$_Voidify_iter@PEAPEAD@std@@YAPEAXPEAPEAD@Z ; std::_Voidify_iter<char * *>
  00018	48 8b d0	 mov	 rdx, rax
  0001b	b9 08 00 00 00	 mov	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  00025	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  0002a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR <_Args_0>$[rsp]
  0002f	e8 00 00 00 00	 call	 ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ; std::forward<char * const &>
  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 89 01	 mov	 QWORD PTR [rcx], rax
  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR $T1[rsp]

; 226  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
??$construct_at@PEADAEBQEADX@std@@YAPEAPEADQEAPEADAEBQEAD@Z ENDP ; std::construct_at<char *,char * const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::addressof<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Val$[rsp]

; 254  : }

  0000a	c3		 ret	 0
??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z
_TEXT	SEGMENT
_New_capacity$ = 32
_Old_capacity$ = 40
_Al$ = 48
tv91 = 56
_New_ptr$ = 64
__$ArrayPad$ = 72
this$ = 96
_New_size$ = 104
_Fn$ = 112
<_Args_0>$ = 120
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>, COMDAT

; 4768 :     _CONSTEXPR20 basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4769 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4770 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4771 :         if (_New_size > max_size()) {

  00027	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00031	48 39 44 24 68	 cmp	 QWORD PTR _New_size$[rsp], rax
  00036	76 05		 jbe	 SHORT $LN2@Reallocate

; 4772 :             _Xlen_string(); // result too long

  00038	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4773 :         }
; 4774 : 
; 4775 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0003d	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00042	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00046	48 89 44 24 28	 mov	 QWORD PTR _Old_capacity$[rsp], rax

; 4776 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  0004b	48 8b 54 24 68	 mov	 rdx, QWORD PTR _New_size$[rsp]
  00050	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00055	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0005a	48 89 44 24 20	 mov	 QWORD PTR _New_capacity$[rsp], rax

; 4777 :         auto& _Al                     = _Getal();

  0005f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00064	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00069	48 89 44 24 30	 mov	 QWORD PTR _Al$[rsp], rax

; 4778 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR _New_capacity$[rsp]
  00073	48 83 c0 01	 add	 rax, 1
  00077	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  0007e	48 0f 42 c1	 cmovb	 rax, rcx
  00082	48 8b d0	 mov	 rdx, rax
  00085	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Al$[rsp]
  0008a	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
  0008f	48 89 44 24 40	 mov	 QWORD PTR _New_ptr$[rsp], rax

; 4779 : 
; 4780 : #if _HAS_CXX20
; 4781 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB

  00094	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00099	0f b6 c0	 movzx	 eax, al
  0009c	85 c0		 test	 eax, eax
  0009e	74 2a		 je	 SHORT $LN3@Reallocate

; 4782 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());

  000a0	48 8b 44 24 20	 mov	 rax, QWORD PTR _New_capacity$[rsp]
  000a5	48 ff c0	 inc	 rax
  000a8	48 89 44 24 38	 mov	 QWORD PTR tv91[rsp], rax
  000ad	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  000b2	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  000b7	45 33 c0	 xor	 r8d, r8d
  000ba	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv91[rsp]
  000bf	48 8b d1	 mov	 rdx, rcx
  000c2	48 8b c8	 mov	 rcx, rax
  000c5	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign
$LN3@Reallocate:

; 4783 :         }
; 4784 : #endif // _HAS_CXX20
; 4785 :         _Mypair._Myval2._Orphan_all();

  000ca	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000cf	48 8b c8	 mov	 rcx, rax
  000d2	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 4786 :         _ASAN_STRING_REMOVE(*this);
; 4787 :         _Mypair._Myval2._Mysize = _New_size;

  000d7	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000dc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _New_size$[rsp]
  000e1	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 4788 :         _Mypair._Myval2._Myres  = _New_capacity;

  000e5	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000ea	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _New_capacity$[rsp]
  000ef	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4789 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  000f3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  000f8	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPEADPEAD@Z ; std::_Unfancy<char>
  000fd	4c 8b 4c 24 78	 mov	 r9, QWORD PTR <_Args_0>$[rsp]
  00102	4c 8b 44 24 68	 mov	 r8, QWORD PTR _New_size$[rsp]
  00107	48 8b d0	 mov	 rdx, rax
  0010a	48 8d 4c 24 70	 lea	 rcx, QWORD PTR _Fn$[rsp]
  0010f	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()

; 4790 :         if (_BUF_SIZE <= _Old_capacity) {

  00114	48 83 7c 24 28
	10		 cmp	 QWORD PTR _Old_capacity$[rsp], 16
  0011a	72 2c		 jb	 SHORT $LN4@Reallocate

; 4791 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  0011c	48 8b 44 24 28	 mov	 rax, QWORD PTR _Old_capacity$[rsp]
  00121	48 ff c0	 inc	 rax
  00124	4c 8b c0	 mov	 r8, rax
  00127	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0012c	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0012f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Al$[rsp]
  00134	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate

; 4792 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  00139	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0013e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _New_ptr$[rsp]
  00143	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4793 :         } else {

  00146	eb 12		 jmp	 SHORT $LN5@Reallocate
$LN4@Reallocate:

; 4794 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  00148	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0014d	48 8d 54 24 40	 lea	 rdx, QWORD PTR _New_ptr$[rsp]
  00152	48 8b c8	 mov	 rcx, rax
  00155	e8 00 00 00 00	 call	 ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
$LN5@Reallocate:

; 4795 :         }
; 4796 : 
; 4797 :         _ASAN_STRING_CREATE(*this);
; 4798 :         return *this;

  0015a	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
$LN6@Reallocate:

; 4799 :     }

  0015f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00164	48 33 cc	 xor	 rcx, rsp
  00167	e8 00 00 00 00	 call	 __security_check_cookie
  0016c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00170	c3		 ret	 0
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ?resize@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAX_J0@Z
_TEXT	SEGMENT
tv81 = 32
this$ = 64
rows$ = 72
cols$ = 80
?resize@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAX_J0@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::resize, COMDAT

; 272  :     {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 273  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,rows==RowsAtCompileTime)

  00013	33 c0		 xor	 eax, eax
  00015	83 f8 01	 cmp	 eax, 1
  00018	74 1c		 je	 SHORT $LN3@resize
  0001a	48 83 7c 24 48
	00		 cmp	 QWORD PTR rows$[rsp], 0
  00020	7c 14		 jl	 SHORT $LN3@resize
  00022	48 83 7c 24 50
	00		 cmp	 QWORD PTR cols$[rsp], 0
  00028	7c 0c		 jl	 SHORT $LN3@resize
  0002a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CP@LINCKCAG@Invalid?5sizes?5when?5resizing?5a?5m@
  00031	48 85 c0	 test	 rax, rax
  00034	75 1c		 jne	 SHORT $LN4@resize
$LN3@resize:
  00036	41 b8 15 01 00
	00		 mov	 r8d, 277		; 00000115H
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1MO@IEDNFCAN@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DBO@BCDCEIEF@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl@
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00050	33 c0		 xor	 eax, eax
$LN4@resize:

; 274  :                    && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,cols==ColsAtCompileTime)
; 275  :                    && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,rows<=MaxRowsAtCompileTime)
; 276  :                    && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,cols<=MaxColsAtCompileTime)
; 277  :                    && rows>=0 && cols>=0 && "Invalid sizes when resizing a matrix or array.");
; 278  :       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(rows, cols);

  00052	48 8b 54 24 50	 mov	 rdx, QWORD PTR cols$[rsp]
  00057	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rows$[rsp]
  0005c	e8 00 00 00 00	 call	 ??$run@_J@?$check_rows_cols_for_overflow@$0?0@internal@Eigen@@SAX_J0@Z ; Eigen::internal::check_rows_cols_for_overflow<-1>::run<__int64>

; 279  :       #ifdef EIGEN_INITIALIZE_COEFFS
; 280  :         Index size = rows*cols;
; 281  :         bool size_changed = size != this->size();
; 282  :         m_storage.resize(size, rows, cols);
; 283  :         if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
; 284  :       #else
; 285  :         m_storage.resize(rows*cols, rows, cols);

  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00066	48 89 44 24 20	 mov	 QWORD PTR tv81[rsp], rax
  0006b	48 8b 44 24 48	 mov	 rax, QWORD PTR rows$[rsp]
  00070	48 0f af 44 24
	50		 imul	 rax, QWORD PTR cols$[rsp]
  00076	4c 8b 4c 24 50	 mov	 r9, QWORD PTR cols$[rsp]
  0007b	4c 8b 44 24 48	 mov	 r8, QWORD PTR rows$[rsp]
  00080	48 8b d0	 mov	 rdx, rax
  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv81[rsp]
  00088	e8 00 00 00 00	 call	 ?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z ; Eigen::DenseStorage<double,-1,-1,-1,0>::resize

; 286  :       #endif
; 287  :     }

  0008d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00091	c3		 ret	 0
?resize@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAX_J0@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\EigenBase.h
;	COMDAT ?derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ
_TEXT	SEGMENT
this$ = 8
?derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ PROC ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::derived, COMDAT

; 46   :   Derived& derived() { return *static_cast<Derived*>(this); }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
?derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ENDP ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::derived
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ?cols@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?cols@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::cols, COMDAT

; 145  :     Index cols() const EIGEN_NOEXCEPT { return m_storage.cols(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	e8 00 00 00 00	 call	 ?cols@?$DenseStorage@N$0DBA@$0BM@$0BM@$0A@@Eigen@@SA_JXZ ; Eigen::DenseStorage<double,784,28,28,0>::cols
  0000e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00012	c3		 ret	 0
?cols@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::cols
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ?rows@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?rows@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::rows, COMDAT

; 143  :     Index rows() const EIGEN_NOEXCEPT { return m_storage.rows(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	e8 00 00 00 00	 call	 ?rows@?$DenseStorage@N$0DBA@$0BM@$0BM@$0A@@Eigen@@SA_JXZ ; Eigen::DenseStorage<double,784,28,28,0>::rows
  0000e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00012	c3		 ret	 0
?rows@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::rows
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT

; 4139 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* data() const noexcept {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4140 :         return _Mypair._Myval2._Myptr();

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 4141 :     }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseStorage.h
;	COMDAT ?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z
_TEXT	SEGMENT
this$ = 48
size$ = 56
rows$ = 64
cols$ = 72
?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z PROC ; Eigen::DenseStorage<double,-1,-1,-1,0>::resize, COMDAT

; 481  :     {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 482  :       if(size != m_rows*m_cols)

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00022	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00026	48 0f af 41 10	 imul	 rax, QWORD PTR [rcx+16]
  0002b	48 39 44 24 38	 cmp	 QWORD PTR size$[rsp], rax
  00030	74 4b		 je	 SHORT $LN2@resize

; 483  :       {
; 484  :         internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols);

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00037	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0003c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00040	48 0f af 41 10	 imul	 rax, QWORD PTR [rcx+16]
  00045	48 8b d0	 mov	 rdx, rax
  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0004d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00050	e8 00 00 00 00	 call	 ??$conditional_aligned_delete_auto@N$00@internal@Eigen@@YAXPEAN_K@Z ; Eigen::internal::conditional_aligned_delete_auto<double,1>

; 485  :         if (size>0) // >0 and not simply !=0 to let the compiler knows that size cannot be negative

  00055	48 83 7c 24 38
	00		 cmp	 QWORD PTR size$[rsp], 0
  0005b	7e 14		 jle	 SHORT $LN3@resize

; 486  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

  0005d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR size$[rsp]
  00062	e8 00 00 00 00	 call	 ??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
  00067	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0006c	48 89 01	 mov	 QWORD PTR [rcx], rax
  0006f	eb 0c		 jmp	 SHORT $LN4@resize
$LN3@resize:

; 487  :         else
; 488  :           m_data = 0;

  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00076	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN4@resize:
$LN2@resize:

; 489  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})
; 490  :       }
; 491  :       m_rows = rows;

  0007d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00082	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rows$[rsp]
  00087	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 492  :       m_cols = cols;

  0008b	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00090	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cols$[rsp]
  00095	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 493  :     }

  00099	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009d	c3		 ret	 0
?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z ENDP ; Eigen::DenseStorage<double,-1,-1,-1,0>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseStorage.h
;	COMDAT ?cols@?$DenseStorage@N$0DBA@$0BM@$0BM@$0A@@Eigen@@SA_JXZ
_TEXT	SEGMENT
?cols@?$DenseStorage@N$0DBA@$0BM@$0BM@$0A@@Eigen@@SA_JXZ PROC ; Eigen::DenseStorage<double,784,28,28,0>::cols, COMDAT

; 263  :     EIGEN_DEVICE_FUNC static EIGEN_CONSTEXPR Index cols(void) EIGEN_NOEXCEPT {return _Cols;}

  00000	b8 1c 00 00 00	 mov	 eax, 28
  00005	c3		 ret	 0
?cols@?$DenseStorage@N$0DBA@$0BM@$0BM@$0A@@Eigen@@SA_JXZ ENDP ; Eigen::DenseStorage<double,784,28,28,0>::cols
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseStorage.h
;	COMDAT ?rows@?$DenseStorage@N$0DBA@$0BM@$0BM@$0A@@Eigen@@SA_JXZ
_TEXT	SEGMENT
?rows@?$DenseStorage@N$0DBA@$0BM@$0BM@$0A@@Eigen@@SA_JXZ PROC ; Eigen::DenseStorage<double,784,28,28,0>::rows, COMDAT

; 262  :     EIGEN_DEVICE_FUNC static EIGEN_CONSTEXPR Index rows(void) EIGEN_NOEXCEPT {return _Rows;}

  00000	b8 1c 00 00 00	 mov	 eax, 28
  00005	c3		 ret	 0
?rows@?$DenseStorage@N$0DBA@$0BM@$0BM@$0A@@Eigen@@SA_JXZ ENDP ; Eigen::DenseStorage<double,784,28,28,0>::rows
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
_TEXT	SEGMENT
_State$ = 32
tv307 = 36
tv189 = 37
tv312 = 38
tv250 = 39
_Pad$ = 40
tv136 = 48
tv308 = 52
$T1 = 56
$T2 = 60
tv313 = 64
$T3 = 68
$T4 = 72
tv306 = 80
tv191 = 88
tv309 = 96
tv216 = 104
tv310 = 112
tv311 = 120
tv252 = 128
tv273 = 136
tv287 = 144
tv302 = 152
$T5 = 160
_Ok$ = 168
__$ArrayPad$ = 184
_Ostr$ = 208
_Data$ = 216
_Size$ = 224
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z PROC ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>, COMDAT

; 489  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 490  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 491  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 492  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

  00028	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _State$[rsp], 0

; 493  : 
; 494  :     _SizeT _Pad;
; 495  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

  00030	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00038	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003b	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0003f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00047	48 03 c8	 add	 rcx, rax
  0004a	48 8b c1	 mov	 rax, rcx
  0004d	48 8b c8	 mov	 rcx, rax
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  00056	48 85 c0	 test	 rax, rax
  00059	7e 30		 jle	 SHORT $LN10@Insert_str
  0005b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00063	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00066	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0006a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00072	48 03 c8	 add	 rcx, rax
  00075	48 8b c1	 mov	 rax, rcx
  00078	48 8b c8	 mov	 rcx, rax
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  00081	48 3b 84 24 e0
	00 00 00	 cmp	 rax, QWORD PTR _Size$[rsp]
  00089	77 0b		 ja	 SHORT $LN8@Insert_str
$LN10@Insert_str:

; 496  :         _Pad = 0;

  0008b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _Pad$[rsp], 0

; 497  :     } else {

  00094	eb 33		 jmp	 SHORT $LN9@Insert_str
$LN8@Insert_str:

; 498  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;

  00096	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  0009e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a1	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000a5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 8b c8	 mov	 rcx, rax
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  000bc	48 2b 84 24 e0
	00 00 00	 sub	 rax, QWORD PTR _Size$[rsp]
  000c4	48 89 44 24 28	 mov	 QWORD PTR _Pad$[rsp], rax
$LN9@Insert_str:

; 499  :     }
; 500  : 
; 501  :     const typename _Ostr_t::sentry _Ok(_Ostr);

  000c9	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR _Ostr$[rsp]
  000d1	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR _Ok$[rsp]
  000d9	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  000de	90		 npad	 1

; 502  : 
; 503  :     if (!_Ok) {

  000df	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR _Ok$[rsp]
  000e7	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  000ec	0f b6 c0	 movzx	 eax, al
  000ef	85 c0		 test	 eax, eax
  000f1	75 10		 jne	 SHORT $LN11@Insert_str

; 504  :         _State |= _Ostr_t::badbit;

  000f3	8b 44 24 20	 mov	 eax, DWORD PTR _State$[rsp]
  000f7	83 c8 04	 or	 eax, 4
  000fa	89 44 24 20	 mov	 DWORD PTR _State$[rsp], eax

; 505  :     } else { // state okay, insert characters

  000fe	e9 95 02 00 00	 jmp	 $LN12@Insert_str
$LN11@Insert_str:

; 506  :         _TRY_IO_BEGIN
; 507  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {

  00103	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  0010b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0010e	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00112	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  0011a	48 03 c8	 add	 rcx, rax
  0011d	48 8b c1	 mov	 rax, rcx
  00120	48 8b c8	 mov	 rcx, rax
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flags@ios_base@std@@QEBAHXZ
  00129	89 44 24 30	 mov	 DWORD PTR tv136[rsp], eax
  0012d	8b 44 24 30	 mov	 eax, DWORD PTR tv136[rsp]
  00131	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00136	83 f8 40	 cmp	 eax, 64			; 00000040H
  00139	0f 84 d0 00 00
	00		 je	 $LN14@Insert_str

; 508  :             for (; 0 < _Pad; --_Pad) { // pad on left

  0013f	eb 0d		 jmp	 SHORT $LN4@Insert_str
$LN2@Insert_str:
  00141	48 8b 44 24 28	 mov	 rax, QWORD PTR _Pad$[rsp]
  00146	48 ff c8	 dec	 rax
  00149	48 89 44 24 28	 mov	 QWORD PTR _Pad$[rsp], rax
$LN4@Insert_str:
  0014e	48 83 7c 24 28
	00		 cmp	 QWORD PTR _Pad$[rsp], 0
  00154	0f 86 b5 00 00
	00		 jbe	 $LN14@Insert_str

; 509  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0015a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00162	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00165	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00169	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00171	48 03 c8	 add	 rcx, rax
  00174	48 8b c1	 mov	 rax, rcx
  00177	48 8b c8	 mov	 rcx, rax
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00180	48 89 44 24 50	 mov	 QWORD PTR tv306[rsp], rax
  00185	48 8b 44 24 50	 mov	 rax, QWORD PTR tv306[rsp]
  0018a	48 89 44 24 58	 mov	 QWORD PTR tv191[rsp], rax
  0018f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00197	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0019a	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0019e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  001a6	48 03 c8	 add	 rcx, rax
  001a9	48 8b c1	 mov	 rax, rcx
  001ac	48 8b c8	 mov	 rcx, rax
  001af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
  001b5	88 44 24 24	 mov	 BYTE PTR tv307[rsp], al
  001b9	0f b6 44 24 24	 movzx	 eax, BYTE PTR tv307[rsp]
  001be	88 44 24 25	 mov	 BYTE PTR tv189[rsp], al
  001c2	0f b6 54 24 25	 movzx	 edx, BYTE PTR tv189[rsp]
  001c7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv191[rsp]
  001cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  001d2	89 44 24 34	 mov	 DWORD PTR tv308[rsp], eax
  001d6	8b 44 24 34	 mov	 eax, DWORD PTR tv308[rsp]
  001da	89 44 24 38	 mov	 DWORD PTR $T1[rsp], eax
  001de	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  001e3	89 44 24 3c	 mov	 DWORD PTR $T2[rsp], eax
  001e7	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T1[rsp]
  001ec	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR $T2[rsp]
  001f1	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  001f6	0f b6 c0	 movzx	 eax, al
  001f9	85 c0		 test	 eax, eax
  001fb	74 0d		 je	 SHORT $LN15@Insert_str

; 510  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

  001fd	8b 44 24 20	 mov	 eax, DWORD PTR _State$[rsp]
  00201	83 c8 04	 or	 eax, 4
  00204	89 44 24 20	 mov	 DWORD PTR _State$[rsp], eax

; 511  :                     break;

  00208	eb 05		 jmp	 SHORT $LN14@Insert_str
$LN15@Insert_str:

; 512  :                 }
; 513  :             }

  0020a	e9 32 ff ff ff	 jmp	 $LN2@Insert_str
$LN14@Insert_str:

; 514  :         }
; 515  : 
; 516  :         if (_State == _Ostr_t::goodbit
; 517  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

  0020f	83 7c 24 20 00	 cmp	 DWORD PTR _State$[rsp], 0
  00214	75 74		 jne	 SHORT $LN16@Insert_str
  00216	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  0021e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00221	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00225	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  0022d	48 03 c8	 add	 rcx, rax
  00230	48 8b c1	 mov	 rax, rcx
  00233	48 8b c8	 mov	 rcx, rax
  00236	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0023c	48 89 44 24 60	 mov	 QWORD PTR tv309[rsp], rax
  00241	48 8b 44 24 60	 mov	 rax, QWORD PTR tv309[rsp]
  00246	48 89 44 24 68	 mov	 QWORD PTR tv216[rsp], rax
  0024b	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR _Size$[rsp]
  00253	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR _Data$[rsp]
  0025b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv216[rsp]
  00260	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
  00266	48 89 44 24 70	 mov	 QWORD PTR tv310[rsp], rax
  0026b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR _Size$[rsp]
  00273	48 39 44 24 70	 cmp	 QWORD PTR tv310[rsp], rax
  00278	74 10		 je	 SHORT $LN16@Insert_str

; 518  :             _State |= _Ostr_t::badbit;

  0027a	8b 44 24 20	 mov	 eax, DWORD PTR _State$[rsp]
  0027e	83 c8 04	 or	 eax, 4
  00281	89 44 24 20	 mov	 DWORD PTR _State$[rsp], eax

; 519  :         } else {

  00285	e9 d6 00 00 00	 jmp	 $LN17@Insert_str
$LN16@Insert_str:

; 520  :             for (; 0 < _Pad; --_Pad) { // pad on right

  0028a	eb 0d		 jmp	 SHORT $LN7@Insert_str
$LN5@Insert_str:
  0028c	48 8b 44 24 28	 mov	 rax, QWORD PTR _Pad$[rsp]
  00291	48 ff c8	 dec	 rax
  00294	48 89 44 24 28	 mov	 QWORD PTR _Pad$[rsp], rax
$LN7@Insert_str:
  00299	48 83 7c 24 28
	00		 cmp	 QWORD PTR _Pad$[rsp], 0
  0029f	0f 86 bb 00 00
	00		 jbe	 $LN17@Insert_str

; 521  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  002a5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  002ad	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002b0	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  002b4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  002bc	48 03 c8	 add	 rcx, rax
  002bf	48 8b c1	 mov	 rax, rcx
  002c2	48 8b c8	 mov	 rcx, rax
  002c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  002cb	48 89 44 24 78	 mov	 QWORD PTR tv311[rsp], rax
  002d0	48 8b 44 24 78	 mov	 rax, QWORD PTR tv311[rsp]
  002d5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv252[rsp], rax
  002dd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  002e5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002e8	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  002ec	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  002f4	48 03 c8	 add	 rcx, rax
  002f7	48 8b c1	 mov	 rax, rcx
  002fa	48 8b c8	 mov	 rcx, rax
  002fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
  00303	88 44 24 26	 mov	 BYTE PTR tv312[rsp], al
  00307	0f b6 44 24 26	 movzx	 eax, BYTE PTR tv312[rsp]
  0030c	88 44 24 27	 mov	 BYTE PTR tv250[rsp], al
  00310	0f b6 54 24 27	 movzx	 edx, BYTE PTR tv250[rsp]
  00315	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv252[rsp]
  0031d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  00323	89 44 24 40	 mov	 DWORD PTR tv313[rsp], eax
  00327	8b 44 24 40	 mov	 eax, DWORD PTR tv313[rsp]
  0032b	89 44 24 44	 mov	 DWORD PTR $T3[rsp], eax
  0032f	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00334	89 44 24 48	 mov	 DWORD PTR $T4[rsp], eax
  00338	48 8d 54 24 44	 lea	 rdx, QWORD PTR $T3[rsp]
  0033d	48 8d 4c 24 48	 lea	 rcx, QWORD PTR $T4[rsp]
  00342	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00347	0f b6 c0	 movzx	 eax, al
  0034a	85 c0		 test	 eax, eax
  0034c	74 0d		 je	 SHORT $LN18@Insert_str

; 522  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

  0034e	8b 44 24 20	 mov	 eax, DWORD PTR _State$[rsp]
  00352	83 c8 04	 or	 eax, 4
  00355	89 44 24 20	 mov	 DWORD PTR _State$[rsp], eax

; 523  :                     break;

  00359	eb 05		 jmp	 SHORT $LN17@Insert_str
$LN18@Insert_str:

; 524  :                 }
; 525  :             }

  0035b	e9 2c ff ff ff	 jmp	 $LN5@Insert_str
$LN17@Insert_str:

; 526  :         }
; 527  : 
; 528  :         _Ostr.width(0);

  00360	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  00368	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0036b	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0036f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  00377	48 03 c8	 add	 rcx, rax
  0037a	48 8b c1	 mov	 rax, rcx
  0037d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv273[rsp], rax
  00385	33 d2		 xor	 edx, edx
  00387	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv273[rsp]
  0038f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEAA_J_J@Z
  00395	90		 npad	 1
  00396	eb 00		 jmp	 SHORT $LN12@Insert_str
$LN24@Insert_str:
$LN12@Insert_str:

; 529  :         _CATCH_IO_(_Ostr_t, _Ostr)
; 530  :     }
; 531  : 
; 532  :     _Ostr.setstate(_State);

  00398	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  003a0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003a3	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  003a7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _Ostr$[rsp]
  003af	48 03 c8	 add	 rcx, rax
  003b2	48 8b c1	 mov	 rax, rcx
  003b5	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv302[rsp], rax
  003bd	45 33 c0	 xor	 r8d, r8d
  003c0	8b 54 24 20	 mov	 edx, DWORD PTR _State$[rsp]
  003c4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv302[rsp]
  003cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 533  :     return _Ostr;

  003d2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _Ostr$[rsp]
  003da	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR $T5[rsp], rax
  003e2	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR _Ok$[rsp]
  003ea	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  003ef	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR $T5[rsp]

; 534  : }

  003f7	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003ff	48 33 cc	 xor	 rcx, rsp
  00402	e8 00 00 00 00	 call	 __security_check_cookie
  00407	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0040e	c3		 ret	 0
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ENDP ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv307 = 36
tv189 = 37
tv312 = 38
tv250 = 39
_Pad$ = 40
tv136 = 48
tv308 = 52
$T1 = 56
$T2 = 60
tv313 = 64
$T3 = 68
$T4 = 72
tv306 = 80
tv191 = 88
tv309 = 96
tv216 = 104
tv310 = 112
tv311 = 120
tv252 = 128
tv273 = 136
tv287 = 144
tv302 = 152
$T5 = 160
_Ok$ = 168
__$ArrayPad$ = 184
_Ostr$ = 208
_Data$ = 216
_Size$ = 224
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rbp]
  00010	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv307 = 36
tv189 = 37
tv312 = 38
tv250 = 39
_Pad$ = 40
tv136 = 48
tv308 = 52
$T1 = 56
$T2 = 60
tv313 = 64
$T3 = 68
$T4 = 72
tv306 = 80
tv191 = 88
tv309 = 96
tv216 = 104
tv310 = 112
tv311 = 120
tv252 = 128
tv273 = 136
tv287 = 144
tv302 = 152
$T5 = 160
_Ok$ = 168
__$ArrayPad$ = 184
_Ostr$ = 208
_Data$ = 216
_Size$ = 224
?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$1

; 529  :         _CATCH_IO_(_Ostr_t, _Ostr)

  0001b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00020	55		 push	 rbp
  00021	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00025	48 8b ea	 mov	 rbp, rdx
__catch$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$0:
  00028	48 8b 85 d0 00
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  0002f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00032	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00036	48 8b 8d d0 00
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  0003d	48 03 c8	 add	 rcx, rax
  00040	48 8b c1	 mov	 rax, rcx
  00043	48 89 85 90 00
	00 00		 mov	 QWORD PTR tv287[rbp], rax
  0004a	41 b0 01	 mov	 r8b, 1
  0004d	ba 04 00 00 00	 mov	 edx, 4
  00052	48 8b 8d 90 00
	00 00		 mov	 rcx, QWORD PTR tv287[rbp]
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0005f	90		 npad	 1
  00060	48 8d 05 00 00
	00 00		 lea	 rax, $LN24@catch$1
  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5d		 pop	 rbp
  0006c	c3		 ret	 0
  0006d	cc		 int	 3
?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR _Arg$[rsp]

; 1413 : }

  0000a	c3		 ret	 0
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ??$run@_J@?$check_rows_cols_for_overflow@$0?0@internal@Eigen@@SAX_J0@Z
_TEXT	SEGMENT
error$ = 32
tv68 = 36
tv69 = 40
max_index$ = 48
rows$ = 80
cols$ = 88
??$run@_J@?$check_rows_cols_for_overflow@$0?0@internal@Eigen@@SAX_J0@Z PROC ; Eigen::internal::check_rows_cols_for_overflow<-1>::run<__int64>, COMDAT

; 41   :   {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 42   :     // http://hg.mozilla.org/mozilla-central/file/6c8a909977d3/xpcom/ds/CheckedInt.h#l242
; 43   :     // we assume Index is signed
; 44   :     Index max_index = (std::size_t(1) << (8 * sizeof(Index) - 1)) - 1; // assume Index is signed

  0000e	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00018	48 89 44 24 30	 mov	 QWORD PTR max_index$[rsp], rax

; 45   :     bool error = (rows == 0 || cols == 0) ? false

  0001d	48 83 7c 24 50
	00		 cmp	 QWORD PTR rows$[rsp], 0
  00023	74 37		 je	 SHORT $LN4@run
  00025	48 83 7c 24 58
	00		 cmp	 QWORD PTR cols$[rsp], 0
  0002b	74 2f		 je	 SHORT $LN4@run
  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR max_index$[rsp]
  00032	48 99		 cdq
  00034	48 f7 7c 24 58	 idiv	 QWORD PTR cols$[rsp]
  00039	48 39 44 24 50	 cmp	 QWORD PTR rows$[rsp], rax
  0003e	7e 0a		 jle	 SHORT $LN5@run
  00040	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  00048	eb 08		 jmp	 SHORT $LN6@run
$LN5@run:
  0004a	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN6@run:
  00052	8b 44 24 24	 mov	 eax, DWORD PTR tv68[rsp]
  00056	89 44 24 28	 mov	 DWORD PTR tv69[rsp], eax
  0005a	eb 08		 jmp	 SHORT $LN7@run
$LN4@run:
  0005c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN7@run:
  00064	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv69[rsp]
  00069	88 44 24 20	 mov	 BYTE PTR error$[rsp], al

; 46   :                : (rows > max_index / cols);
; 47   :     if (error)

  0006d	0f b6 44 24 20	 movzx	 eax, BYTE PTR error$[rsp]
  00072	85 c0		 test	 eax, eax
  00074	74 05		 je	 SHORT $LN2@run

; 48   :       throw_std_bad_alloc();

  00076	e8 00 00 00 00	 call	 ?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
$LN2@run:

; 49   :   }

  0007b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007f	c3		 ret	 0
??$run@_J@?$check_rows_cols_for_overflow@$0?0@internal@Eigen@@SAX_J0@Z ENDP ; Eigen::internal::check_rows_cols_for_overflow<-1>::run<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\AssignEvaluator.h
;	COMDAT ??$call_assignment_no_alias@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z
_TEXT	SEGMENT
actualDst$ = 32
dst$ = 64
src$ = 72
func$ = 80
??$call_assignment_no_alias@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z PROC ; Eigen::internal::call_assignment_no_alias<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,Eigen::internal::assign_op<double,double> >, COMDAT

; 874  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 875  :   enum {
; 876  :     NeedToTranspose = (    (int(Dst::RowsAtCompileTime) == 1 && int(Src::ColsAtCompileTime) == 1)
; 877  :                         || (int(Dst::ColsAtCompileTime) == 1 && int(Src::RowsAtCompileTime) == 1)
; 878  :                       ) && int(Dst::SizeAtCompileTime) != 1
; 879  :   };
; 880  : 
; 881  :   typedef typename internal::conditional<NeedToTranspose, Transpose<Dst>, Dst>::type ActualDstTypeCleaned;
; 882  :   typedef typename internal::conditional<NeedToTranspose, Transpose<Dst>, Dst&>::type ActualDstType;
; 883  :   ActualDstType actualDst(dst);

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR dst$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR actualDst$[rsp], rax

; 884  : 
; 885  :   // TODO check whether this is the right place to perform these checks:
; 886  :   EIGEN_STATIC_ASSERT_LVALUE(Dst)
; 887  :   EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(ActualDstTypeCleaned,Src)
; 888  :   EIGEN_CHECK_BINARY_COMPATIBILIY(Func,typename ActualDstTypeCleaned::Scalar,typename Src::Scalar);
; 889  : 
; 890  :   Assignment<ActualDstTypeCleaned,Src,Func>::run(actualDst, src, func);

  0001d	4c 8b 44 24 50	 mov	 r8, QWORD PTR func$[rsp]
  00022	48 8b 54 24 48	 mov	 rdx, QWORD PTR src$[rsp]
  00027	48 8b 4c 24 20	 mov	 rcx, QWORD PTR actualDst$[rsp]
  0002c	e8 00 00 00 00	 call	 ?run@?$Assignment@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@UDense2Dense@52@X@internal@Eigen@@SAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@3@AEBU?$assign_op@NN@23@@Z ; Eigen::internal::Assignment<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,Eigen::internal::assign_op<double,double>,Eigen::internal::Dense2Dense,void>::run

; 891  : }

  00031	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00035	c3		 ret	 0
??$call_assignment_no_alias@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z ENDP ; Eigen::internal::call_assignment_no_alias<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,Eigen::internal::assign_op<double,double> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\Memory.h
;	COMDAT ??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z
_TEXT	SEGMENT
result$ = 32
size$ = 64
??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z PROC ; Eigen::internal::conditional_aligned_new_auto<double,1>, COMDAT

; 400  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 401  :   if(size==0)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR size$[rsp], 0
  0000f	75 04		 jne	 SHORT $LN2@conditiona

; 402  :     return 0; // short-cut. Also fixes Bug 884

  00011	33 c0		 xor	 eax, eax
  00013	eb 3d		 jmp	 SHORT $LN5@conditiona
$LN2@conditiona:

; 403  :   check_size_for_overflow<T>(size);

  00015	48 8b 4c 24 40	 mov	 rcx, QWORD PTR size$[rsp]
  0001a	e8 00 00 00 00	 call	 ??$check_size_for_overflow@N@internal@Eigen@@YAX_K@Z ; Eigen::internal::check_size_for_overflow<double>

; 404  :   T *result = reinterpret_cast<T*>(conditional_aligned_malloc<Align>(sizeof(T)*size));

  0001f	48 8b 44 24 40	 mov	 rax, QWORD PTR size$[rsp]
  00024	48 c1 e0 03	 shl	 rax, 3
  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 ??$conditional_aligned_malloc@$00@internal@Eigen@@YAPEAX_K@Z ; Eigen::internal::conditional_aligned_malloc<1>
  00030	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 405  :   if(NumTraits<T>::RequireInitialization)

  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	74 12		 je	 SHORT $LN3@conditiona

; 406  :   {
; 407  :     EIGEN_TRY
; 408  :     {
; 409  :       construct_elements_of_array(result, size);

  0003b	48 8b 54 24 40	 mov	 rdx, QWORD PTR size$[rsp]
  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00045	e8 00 00 00 00	 call	 ??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z ; Eigen::internal::construct_elements_of_array<double>
  0004a	90		 npad	 1
  0004b	eb 00		 jmp	 SHORT $LN3@conditiona
$LN9@conditiona:
$LN3@conditiona:

; 410  :     }
; 411  :     EIGEN_CATCH(...)
; 412  :     {
; 413  :       conditional_aligned_free<Align>(result);
; 414  :       EIGEN_THROW;
; 415  :     }
; 416  :   }
; 417  :   return result;

  0004d	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
$LN5@conditiona:

; 418  : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
$LN10@conditiona:
??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ENDP ; Eigen::internal::conditional_aligned_new_auto<double,1>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
result$ = 32
size$ = 64
?catch$0@?0???$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z@4HA PROC ; `Eigen::internal::conditional_aligned_new_auto<double,1>'::`1'::catch$0

; 412  :     {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z$0:

; 413  :       conditional_aligned_free<Align>(result);

  0000d	48 8b 4d 20	 mov	 rcx, QWORD PTR result$[rbp]
  00011	e8 00 00 00 00	 call	 ??$conditional_aligned_free@$00@internal@Eigen@@YAXPEAX@Z ; Eigen::internal::conditional_aligned_free<1>

; 414  :       EIGEN_THROW;

  00016	33 d2		 xor	 edx, edx
  00018	33 c9		 xor	 ecx, ecx
  0001a	e8 00 00 00 00	 call	 _CxxThrowException
  0001f	90		 npad	 1

; 415  :     }

  00020	48 8d 05 00 00
	00 00		 lea	 rax, $LN9@catch$0
  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
  0002d	cc		 int	 3
?catch$0@?0???$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z@4HA ENDP ; `Eigen::internal::conditional_aligned_new_auto<double,1>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\AssignEvaluator.h
;	COMDAT ?run@?$Assignment@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@UDense2Dense@52@X@internal@Eigen@@SAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@3@AEBU?$assign_op@NN@23@@Z
_TEXT	SEGMENT
dst$ = 48
src$ = 56
func$ = 64
?run@?$Assignment@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@UDense2Dense@52@X@internal@Eigen@@SAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@3@AEBU?$assign_op@NN@23@@Z PROC ; Eigen::internal::Assignment<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,Eigen::internal::assign_op<double,double>,Eigen::internal::Dense2Dense,void>::run, COMDAT

; 949  :   {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 950  : #ifndef EIGEN_NO_DEBUG
; 951  :     internal::check_for_aliasing(dst, src);

  00013	48 8b 54 24 38	 mov	 rdx, QWORD PTR src$[rsp]
  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dst$[rsp]
  0001d	e8 00 00 00 00	 call	 ??$check_for_aliasing@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@@internal@Eigen@@YAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@@Z ; Eigen::internal::check_for_aliasing<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28> >

; 952  : #endif
; 953  : 
; 954  :     call_dense_assignment_loop(dst, src, func);

  00022	4c 8b 44 24 40	 mov	 r8, QWORD PTR func$[rsp]
  00027	48 8b 54 24 38	 mov	 rdx, QWORD PTR src$[rsp]
  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dst$[rsp]
  00031	e8 00 00 00 00	 call	 ??$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z ; Eigen::internal::call_dense_assignment_loop<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,Eigen::internal::assign_op<double,double> >

; 955  :   }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
?run@?$Assignment@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@UDense2Dense@52@X@internal@Eigen@@SAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@3@AEBU?$assign_op@NN@23@@Z ENDP ; Eigen::internal::Assignment<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,Eigen::internal::assign_op<double,double>,Eigen::internal::Dense2Dense,void>::run
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\Memory.h
;	COMDAT ??$check_size_for_overflow@N@internal@Eigen@@YAX_K@Z
_TEXT	SEGMENT
size$ = 48
??$check_size_for_overflow@N@internal@Eigen@@YAX_K@Z PROC ; Eigen::internal::check_size_for_overflow<double>, COMDAT

; 317  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 318  :   if(size > std::size_t(-1) / sizeof(T))

  00009	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00013	48 39 44 24 30	 cmp	 QWORD PTR size$[rsp], rax
  00018	76 05		 jbe	 SHORT $LN2@check_size

; 319  :     throw_std_bad_alloc();

  0001a	e8 00 00 00 00	 call	 ?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
$LN2@check_size:

; 320  : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
??$check_size_for_overflow@N@internal@Eigen@@YAX_K@Z ENDP ; Eigen::internal::check_size_for_overflow<double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\Memory.h
;	COMDAT ??$conditional_aligned_malloc@$00@internal@Eigen@@YAPEAX_K@Z
_TEXT	SEGMENT
size$ = 48
??$conditional_aligned_malloc@$00@internal@Eigen@@YAPEAX_K@Z PROC ; Eigen::internal::conditional_aligned_malloc<1>, COMDAT

; 240  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 241  :   return aligned_malloc(size);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR size$[rsp]
  0000e	e8 00 00 00 00	 call	 ?aligned_malloc@internal@Eigen@@YAPEAX_K@Z ; Eigen::internal::aligned_malloc

; 242  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??$conditional_aligned_malloc@$00@internal@Eigen@@YAPEAX_K@Z ENDP ; Eigen::internal::conditional_aligned_malloc<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\Memory.h
;	COMDAT ??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z
_TEXT	SEGMENT
i$ = 32
$T1 = 40
ptr$ = 64
size$ = 72
??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z PROC ; Eigen::internal::construct_elements_of_array<double>, COMDAT

; 296  : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 297  :   std::size_t i;
; 298  :   EIGEN_TRY
; 299  :   {
; 300  :       for (i = 0; i < size; ++i) ::new (ptr + i) T;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00017	eb 0d		 jmp	 SHORT $LN4@construct_
$LN2@construct_:
  00019	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0001e	48 ff c0	 inc	 rax
  00021	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN4@construct_:
  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR size$[rsp]
  0002b	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00030	73 22		 jae	 SHORT $LN3@construct_
  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR ptr$[rsp]
  00037	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0003c	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  00040	48 8b d0	 mov	 rdx, rax
  00043	b9 08 00 00 00	 mov	 ecx, 8
  00048	e8 00 00 00 00	 call	 ??2@YAPEAX_KPEAX@Z	; operator new
  0004d	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00052	eb c5		 jmp	 SHORT $LN2@construct_
$LN3@construct_:

; 301  :       return ptr;

  00054	48 8b 44 24 40	 mov	 rax, QWORD PTR ptr$[rsp]
  00059	eb 04		 jmp	 SHORT $LN6@construct_
  0005b	eb 00		 jmp	 SHORT $LN9@construct_
$LN10@construct_:
$LN9@construct_:

; 302  :   }
; 303  :   EIGEN_CATCH(...)
; 304  :   {
; 305  :     destruct_elements_of_array(ptr, i);
; 306  :     EIGEN_THROW;
; 307  :   }
; 308  :   return NULL;

  0005d	33 c0		 xor	 eax, eax
$LN6@construct_:

; 309  : }

  0005f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00063	c3		 ret	 0
  00064	cc		 int	 3
$LN11@construct_:
??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z ENDP ; Eigen::internal::construct_elements_of_array<double>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
$T1 = 40
ptr$ = 64
size$ = 72
?catch$0@?0???$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z@4HA PROC ; `Eigen::internal::construct_elements_of_array<double>'::`1'::catch$0

; 304  :   {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z$0:

; 305  :     destruct_elements_of_array(ptr, i);

  0000d	48 8b 55 20	 mov	 rdx, QWORD PTR i$[rbp]
  00011	48 8b 4d 40	 mov	 rcx, QWORD PTR ptr$[rbp]
  00015	e8 00 00 00 00	 call	 ??$destruct_elements_of_array@N@internal@Eigen@@YAXPEAN_K@Z ; Eigen::internal::destruct_elements_of_array<double>

; 306  :     EIGEN_THROW;

  0001a	33 d2		 xor	 edx, edx
  0001c	33 c9		 xor	 ecx, ecx
  0001e	e8 00 00 00 00	 call	 _CxxThrowException
  00023	90		 npad	 1

; 307  :   }

  00024	48 8d 05 00 00
	00 00		 lea	 rax, $LN10@catch$0
  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5d		 pop	 rbp
  00030	c3		 ret	 0
  00031	cc		 int	 3
?catch$0@?0???$construct_elements_of_array@N@internal@Eigen@@YAPEANPEAN_K@Z@4HA ENDP ; `Eigen::internal::construct_elements_of_array<double>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\Transpose.h
;	COMDAT ??$check_for_aliasing@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@@internal@Eigen@@YAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@@Z
_TEXT	SEGMENT
dst$ = 48
src$ = 56
??$check_for_aliasing@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@@internal@Eigen@@YAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@@Z PROC ; Eigen::internal::check_for_aliasing<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28> >, COMDAT

; 453  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 454  :   if((!Dst::IsVectorAtCompileTime) && dst.rows()>1 && dst.cols()>1)

  0000e	33 c0		 xor	 eax, eax
  00010	83 f8 01	 cmp	 eax, 1
  00013	74 2f		 je	 SHORT $LN2@check_for_
  00015	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dst$[rsp]
  0001a	e8 00 00 00 00	 call	 ?rows@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::rows
  0001f	48 83 f8 01	 cmp	 rax, 1
  00023	7e 1f		 jle	 SHORT $LN2@check_for_
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dst$[rsp]
  0002a	e8 00 00 00 00	 call	 ?cols@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::cols
  0002f	48 83 f8 01	 cmp	 rax, 1
  00033	7e 0f		 jle	 SHORT $LN2@check_for_

; 455  :     internal::checkTransposeAliasing_impl<Dst, Src>::run(dst, src);

  00035	48 8b 54 24 38	 mov	 rdx, QWORD PTR src$[rsp]
  0003a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dst$[rsp]
  0003f	e8 00 00 00 00	 call	 ?run@?$checkTransposeAliasing_impl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@3@@Z ; Eigen::internal::checkTransposeAliasing_impl<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,0>::run
$LN2@check_for_:

; 456  : }

  00044	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00048	c3		 ret	 0
??$check_for_aliasing@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@@internal@Eigen@@YAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@@Z ENDP ; Eigen::internal::check_for_aliasing<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\AssignEvaluator.h
;	COMDAT ??$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z
_TEXT	SEGMENT
srcEvaluator$ = 48
dstEvaluator$ = 56
kernel$ = 72
__$ArrayPad$ = 104
dst$ = 128
src$ = 136
func$ = 144
??$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z PROC ; Eigen::internal::call_dense_assignment_loop<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,Eigen::internal::assign_op<double,double> >, COMDAT

; 770  : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 771  :   typedef evaluator<DstXprType> DstEvaluatorType;
; 772  :   typedef evaluator<SrcXprType> SrcEvaluatorType;
; 773  : 
; 774  :   SrcEvaluatorType srcEvaluator(src);

  00022	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  0002a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR srcEvaluator$[rsp]
  0002f	e8 00 00 00 00	 call	 ??0?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@@Z ; Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >::evaluator<Eigen::Matrix<double,28,28,0,28,28> >
  00034	90		 npad	 1

; 775  : 
; 776  :   // NOTE To properly handle A = (A*A.transpose())/s with A rectangular,
; 777  :   // we need to resize the destination after the source evaluator has been created.
; 778  :   resize_if_allowed(dst, src, func);

  00035	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR func$[rsp]
  0003d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  00045	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dst$[rsp]
  0004d	e8 00 00 00 00	 call	 ??$resize_if_allowed@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@NN@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z ; Eigen::internal::resize_if_allowed<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,double,double>

; 779  : 
; 780  :   DstEvaluatorType dstEvaluator(dst);

  00052	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dst$[rsp]
  0005a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR dstEvaluator$[rsp]
  0005f	e8 00 00 00 00	 call	 ??0?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@Z ; Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >
  00064	90		 npad	 1

; 781  : 
; 782  :   typedef generic_dense_assignment_kernel<DstEvaluatorType,SrcEvaluatorType,Functor> Kernel;
; 783  :   Kernel kernel(dstEvaluator, srcEvaluator, func, dst.const_cast_derived());

  00065	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dst$[rsp]
  0006d	e8 00 00 00 00	 call	 ?const_cast_derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::const_cast_derived
  00072	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00077	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR func$[rsp]
  0007f	4c 8d 44 24 30	 lea	 r8, QWORD PTR srcEvaluator$[rsp]
  00084	48 8d 54 24 38	 lea	 rdx, QWORD PTR dstEvaluator$[rsp]
  00089	48 8d 4c 24 48	 lea	 rcx, QWORD PTR kernel$[rsp]
  0008e	e8 00 00 00 00	 call	 ??0?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAA@AEAU?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@12@AEBU?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@12@AEBU?$assign_op@NN@12@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@Z ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>

; 784  : 
; 785  :   dense_assignment_loop<Kernel>::run(kernel);

  00093	48 8d 4c 24 48	 lea	 rcx, QWORD PTR kernel$[rsp]
  00098	e8 00 00 00 00	 call	 ?run@?$dense_assignment_loop@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@$02$0A@@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@23@@Z ; Eigen::internal::dense_assignment_loop<Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>,3,0>::run
  0009d	90		 npad	 1

; 786  : }

  0009e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR dstEvaluator$[rsp]
  000a3	e8 00 00 00 00	 call	 ??1?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ
  000a8	90		 npad	 1
  000a9	48 8d 4c 24 30	 lea	 rcx, QWORD PTR srcEvaluator$[rsp]
  000ae	e8 00 00 00 00	 call	 ??1?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ
  000b3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b8	48 33 cc	 xor	 rcx, rsp
  000bb	e8 00 00 00 00	 call	 __security_check_cookie
  000c0	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000c4	c3		 ret	 0
??$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z ENDP ; Eigen::internal::call_dense_assignment_loop<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,Eigen::internal::assign_op<double,double> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
srcEvaluator$ = 48
dstEvaluator$ = 56
kernel$ = 72
__$ArrayPad$ = 104
dst$ = 128
src$ = 136
func$ = 144
?dtor$0@?0???$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z@4HA PROC ; `Eigen::internal::call_dense_assignment_loop<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,Eigen::internal::assign_op<double,double> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 30	 lea	 rcx, QWORD PTR srcEvaluator$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z@4HA ENDP ; `Eigen::internal::call_dense_assignment_loop<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,Eigen::internal::assign_op<double,double> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
srcEvaluator$ = 48
dstEvaluator$ = 56
kernel$ = 72
__$ArrayPad$ = 104
dst$ = 128
src$ = 136
func$ = 144
?dtor$1@?0???$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z@4HA PROC ; `Eigen::internal::call_dense_assignment_loop<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,Eigen::internal::assign_op<double,double> >'::`1'::dtor$1
  00018	40 55		 push	 rbp
  0001a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001e	48 8b ea	 mov	 rbp, rdx
  00021	48 8d 4d 38	 lea	 rcx, QWORD PTR dstEvaluator$[rbp]
  00025	e8 00 00 00 00	 call	 ??1?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5d		 pop	 rbp
  0002f	c3		 ret	 0
?dtor$1@?0???$call_dense_assignment_loop@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@U?$assign_op@NN@internal@2@@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z@4HA ENDP ; `Eigen::internal::call_dense_assignment_loop<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,Eigen::internal::assign_op<double,double> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ PROC ; Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >::~evaluator<Eigen::Matrix<double,28,28,0,28,28> >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ
  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ ENDP ; Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >::~evaluator<Eigen::Matrix<double,28,28,0,28,28> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ PROC ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >::~evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??1?$evaluator_base@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >::~evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >
  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ ENDP ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >::~evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ PROC ; Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >::~evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ
  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ENDP ; Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >::~evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ PROC ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::~evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??1?$evaluator_base@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >::~evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >
  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??1?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@XZ ENDP ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::~evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\AssignEvaluator.h
;	COMDAT ?run@?$dense_assignment_loop@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@$02$0A@@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@23@@Z
_TEXT	SEGMENT
index$1 = 32
size$ = 40
tv72 = 48
alignedEnd$ = 56
alignedStart$ = 64
kernel$ = 96
?run@?$dense_assignment_loop@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@$02$0A@@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@23@@Z PROC ; Eigen::internal::dense_assignment_loop<Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>,3,0>::run, COMDAT

; 419  :   {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 420  :     const Index size = kernel.size();

  00009	48 8b 4c 24 60	 mov	 rcx, QWORD PTR kernel$[rsp]
  0000e	e8 00 00 00 00	 call	 ?size@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEBA_JXZ ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::size
  00013	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 421  :     typedef typename Kernel::Scalar Scalar;
; 422  :     typedef typename Kernel::PacketType PacketType;
; 423  :     enum {
; 424  :       requestedAlignment = Kernel::AssignmentTraits::LinearRequiredAlignment,
; 425  :       packetSize = unpacket_traits<PacketType>::size,
; 426  :       dstIsAligned = int(Kernel::AssignmentTraits::DstAlignment)>=int(requestedAlignment),
; 427  :       dstAlignment = packet_traits<Scalar>::AlignedOnScalar ? int(requestedAlignment)
; 428  :                                                             : int(Kernel::AssignmentTraits::DstAlignment),
; 429  :       srcAlignment = Kernel::AssignmentTraits::JointAlignment
; 430  :     };
; 431  :     const Index alignedStart = dstIsAligned ? 0 : internal::first_aligned<requestedAlignment>(kernel.dstDataPtr(), size);

  00018	33 c0		 xor	 eax, eax
  0001a	83 f8 01	 cmp	 eax, 1
  0001d	74 0b		 je	 SHORT $LN6@run
  0001f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv72[rsp], 0
  00028	eb 1c		 jmp	 SHORT $LN7@run
$LN6@run:
  0002a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR kernel$[rsp]
  0002f	e8 00 00 00 00	 call	 ?dstDataPtr@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEBAPEBNXZ ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::dstDataPtr
  00034	48 8b 54 24 28	 mov	 rdx, QWORD PTR size$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 ??$first_aligned@$0CA@N_J@internal@Eigen@@YA_JPEBN_J@Z ; Eigen::internal::first_aligned<32,double,__int64>
  00041	48 89 44 24 30	 mov	 QWORD PTR tv72[rsp], rax
$LN7@run:
  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR tv72[rsp]
  0004b	48 89 44 24 40	 mov	 QWORD PTR alignedStart$[rsp], rax

; 432  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

  00050	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  00055	48 99		 cdq
  00057	48 83 e2 03	 and	 rdx, 3
  0005b	48 03 c2	 add	 rax, rdx
  0005e	48 c1 f8 02	 sar	 rax, 2
  00062	48 c1 e0 02	 shl	 rax, 2
  00066	48 89 44 24 38	 mov	 QWORD PTR alignedEnd$[rsp], rax

; 433  : 
; 434  :     unaligned_dense_assignment_loop<dstIsAligned!=0>::run(kernel, 0, alignedStart);

  0006b	45 33 c0	 xor	 r8d, r8d
  0006e	33 d2		 xor	 edx, edx
  00070	48 8b 4c 24 60	 mov	 rcx, QWORD PTR kernel$[rsp]
  00075	e8 00 00 00 00	 call	 ??$run@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@@?$unaligned_dense_assignment_loop@$00@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@12@_J1@Z ; Eigen::internal::unaligned_dense_assignment_loop<1>::run<Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0> >

; 435  : 
; 436  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

  0007a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR index$1[rsp], 0
  00083	eb 0e		 jmp	 SHORT $LN4@run
$LN2@run:
  00085	48 8b 44 24 20	 mov	 rax, QWORD PTR index$1[rsp]
  0008a	48 83 c0 04	 add	 rax, 4
  0008e	48 89 44 24 20	 mov	 QWORD PTR index$1[rsp], rax
$LN4@run:
  00093	48 8b 44 24 38	 mov	 rax, QWORD PTR alignedEnd$[rsp]
  00098	48 39 44 24 20	 cmp	 QWORD PTR index$1[rsp], rax
  0009d	7d 11		 jge	 SHORT $LN3@run

; 437  :       kernel.template assignPacket<dstAlignment, srcAlignment, PacketType>(index);

  0009f	48 8b 54 24 20	 mov	 rdx, QWORD PTR index$1[rsp]
  000a4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR kernel$[rsp]
  000a9	e8 00 00 00 00	 call	 ??$assignPacket@$0CA@$0CA@U__m256d@@@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAAX_J@Z ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::assignPacket<32,32,__m256d>
  000ae	eb d5		 jmp	 SHORT $LN2@run
$LN3@run:

; 438  : 
; 439  :     unaligned_dense_assignment_loop<>::run(kernel, alignedEnd, size);

  000b0	4c 8b 44 24 28	 mov	 r8, QWORD PTR size$[rsp]
  000b5	48 8b 54 24 38	 mov	 rdx, QWORD PTR alignedEnd$[rsp]
  000ba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR kernel$[rsp]
  000bf	e8 00 00 00 00	 call	 ??$run@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@@?$unaligned_dense_assignment_loop@$0A@@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@12@_J1@Z ; Eigen::internal::unaligned_dense_assignment_loop<0>::run<Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0> >

; 440  :   }

  000c4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000c8	c3		 ret	 0
?run@?$dense_assignment_loop@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@$02$0A@@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@23@@Z ENDP ; Eigen::internal::dense_assignment_loop<Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>,3,0>::run
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\AssignEvaluator.h
;	COMDAT ??0?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAA@AEAU?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@12@AEBU?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@12@AEBU?$assign_op@NN@12@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@Z
_TEXT	SEGMENT
this$ = 8
dst$ = 16
src$ = 24
func$ = 32
dstExpr$ = 40
??0?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAA@AEAU?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@12@AEBU?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@12@AEBU?$assign_op@NN@12@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@Z PROC ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>, COMDAT

; 635  :   {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 634  :     : m_dst(dst), m_src(src), m_functor(func), m_dstExpr(dstExpr)

  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00019	48 8b 4c 24 10	 mov	 rcx, QWORD PTR dst$[rsp]
  0001e	48 89 08	 mov	 QWORD PTR [rax], rcx
  00021	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00026	48 8b 4c 24 18	 mov	 rcx, QWORD PTR src$[rsp]
  0002b	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0002f	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR func$[rsp]
  00039	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  0003d	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00042	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dstExpr$[rsp]
  00047	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 636  :     #ifdef EIGEN_DEBUG_ASSIGN
; 637  :     AssignmentTraits::debug();
; 638  :     #endif
; 639  :   }

  0004b	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00050	c3		 ret	 0
??0?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAA@AEAU?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@12@AEBU?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@12@AEBU?$assign_op@NN@12@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@Z ENDP ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ??0?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@Z
_TEXT	SEGMENT
this$ = 48
m$ = 56
??0?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@Z PROC ; Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >, COMDAT

; 284  :   { }

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 283  :     : evaluator<PlainObjectBase<XprType> >(m)

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR m$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >

; 284  :   { }

  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
??0?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@Z ENDP ; Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ??1?$evaluator_base@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$evaluator_base@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ PROC ; Eigen::internal::evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >::~evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >, COMDAT

; 122  :   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ~evaluator_base() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	c3		 ret	 0
??1?$evaluator_base@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ENDP ; Eigen::internal::evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >::~evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ??0?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@@Z
_TEXT	SEGMENT
this$ = 48
m$ = 56
??0?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@@Z PROC ; Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >::evaluator<Eigen::Matrix<double,28,28,0,28,28> >, COMDAT

; 284  :   { }

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 283  :     : evaluator<PlainObjectBase<XprType> >(m)

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR m$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >

; 284  :   { }

  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
??0?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@@Z ENDP ; Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >::evaluator<Eigen::Matrix<double,28,28,0,28,28> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ??1?$evaluator_base@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$evaluator_base@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ PROC ; Eigen::internal::evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >::~evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >, COMDAT

; 122  :   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ~evaluator_base() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	c3		 ret	 0
??1?$evaluator_base@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ ENDP ; Eigen::internal::evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >::~evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\Transpose.h
;	COMDAT ?run@?$checkTransposeAliasing_impl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@3@@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
?run@?$checkTransposeAliasing_impl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@3@@Z PROC ; Eigen::internal::checkTransposeAliasing_impl<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,0>::run, COMDAT

; 447  :     {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 448  :     }

  0000a	c3		 ret	 0
?run@?$checkTransposeAliasing_impl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@3@@Z ENDP ; Eigen::internal::checkTransposeAliasing_impl<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,0>::run
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ?cols@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?cols@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::cols, COMDAT

; 145  :     Index cols() const EIGEN_NOEXCEPT { return m_storage.cols(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?cols@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEBA_JXZ ; Eigen::DenseStorage<double,-1,-1,-1,0>::cols
  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?cols@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::cols
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ?rows@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?rows@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::rows, COMDAT

; 143  :     Index rows() const EIGEN_NOEXCEPT { return m_storage.rows(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?rows@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEBA_JXZ ; Eigen::DenseStorage<double,-1,-1,-1,0>::rows
  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?rows@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::rows
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\EigenBase.h
;	COMDAT ?const_cast_derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ
_TEXT	SEGMENT
this$ = 8
?const_cast_derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ PROC ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::const_cast_derived, COMDAT

; 53   :   { return *static_cast<Derived*>(const_cast<EigenBase*>(this)); }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
?const_cast_derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ENDP ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::const_cast_derived
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\AssignEvaluator.h
;	COMDAT ?dstDataPtr@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEBAPEBNXZ
_TEXT	SEGMENT
this$ = 48
?dstDataPtr@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEBAPEBNXZ PROC ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::dstDataPtr, COMDAT

; 711  :   {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 712  :     return m_dstExpr.data();

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00012	e8 00 00 00 00	 call	 ?data@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAPEANXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::data

; 713  :   }

  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	c3		 ret	 0
?dstDataPtr@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEBAPEBNXZ ENDP ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::dstDataPtr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\AssignEvaluator.h
;	COMDAT ?size@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?size@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEBA_JXZ PROC ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::size, COMDAT

; 641  :   EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index size() const EIGEN_NOEXCEPT { return m_dstExpr.size(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00012	e8 00 00 00 00	 call	 ?size@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::size
  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	c3		 ret	 0
?size@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEBA_JXZ ENDP ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z
_TEXT	SEGMENT
tv85 = 32
tv91 = 40
this$ = 64
m$ = 72
??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z PROC ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >, COMDAT

; 197  :   {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00013	e8 00 00 00 00	 call	 ??0?$evaluator_base@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >::evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >
  00018	90		 npad	 1

; 196  :     : m_d(m.data(),IsVectorAtCompileTime ? 0 : m.outerStride())

  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001e	48 89 44 24 28	 mov	 QWORD PTR tv91[rsp], rax
  00023	33 c0		 xor	 eax, eax
  00025	85 c0		 test	 eax, eax
  00027	74 0b		 je	 SHORT $LN3@evaluator
  00029	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv85[rsp], 0
  00032	eb 0f		 jmp	 SHORT $LN4@evaluator
$LN3@evaluator:
  00034	48 8b 4c 24 48	 mov	 rcx, QWORD PTR m$[rsp]
  00039	e8 00 00 00 00	 call	 ?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$02@Eigen@@QEBA_JXZ ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,-1,0,-1,-1>,3>::outerStride
  0003e	48 89 44 24 20	 mov	 QWORD PTR tv85[rsp], rax
$LN4@evaluator:
  00043	48 8b 4c 24 48	 mov	 rcx, QWORD PTR m$[rsp]
  00048	e8 00 00 00 00	 call	 ?data@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAPEBNXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::data
  0004d	4c 8b 44 24 20	 mov	 r8, QWORD PTR tv85[rsp]
  00052	48 8b d0	 mov	 rdx, rax
  00055	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv91[rsp]
  0005a	e8 00 00 00 00	 call	 ??0?$plainobjectbase_evaluator_data@N$0?0@internal@Eigen@@QEAA@PEBN_J@Z ; Eigen::internal::plainobjectbase_evaluator_data<double,-1>::plainobjectbase_evaluator_data<double,-1>
  0005f	90		 npad	 1

; 198  :     EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
; 199  :   }

  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z ENDP ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv85 = 32
tv91 = 40
this$ = 64
m$ = 72
?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z@4HA PROC ; `Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$evaluator_base@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >::~evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@@Z@4HA ENDP ; `Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z
_TEXT	SEGMENT
tv85 = 32
tv91 = 40
this$ = 64
m$ = 72
??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z PROC ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >, COMDAT

; 197  :   {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00013	e8 00 00 00 00	 call	 ??0?$evaluator_base@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >::evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >
  00018	90		 npad	 1

; 196  :     : m_d(m.data(),IsVectorAtCompileTime ? 0 : m.outerStride())

  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001e	48 89 44 24 28	 mov	 QWORD PTR tv91[rsp], rax
  00023	33 c0		 xor	 eax, eax
  00025	85 c0		 test	 eax, eax
  00027	74 0b		 je	 SHORT $LN3@evaluator
  00029	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv85[rsp], 0
  00032	eb 0f		 jmp	 SHORT $LN4@evaluator
$LN3@evaluator:
  00034	48 8b 4c 24 48	 mov	 rcx, QWORD PTR m$[rsp]
  00039	e8 00 00 00 00	 call	 ?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@$02@Eigen@@QEBA_JXZ ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,28,28,0,28,28>,3>::outerStride
  0003e	48 89 44 24 20	 mov	 QWORD PTR tv85[rsp], rax
$LN4@evaluator:
  00043	48 8b 4c 24 48	 mov	 rcx, QWORD PTR m$[rsp]
  00048	e8 00 00 00 00	 call	 ?data@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAPEBNXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::data
  0004d	4c 8b 44 24 20	 mov	 r8, QWORD PTR tv85[rsp]
  00052	48 8b d0	 mov	 rdx, rax
  00055	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv91[rsp]
  0005a	e8 00 00 00 00	 call	 ??0?$plainobjectbase_evaluator_data@N$0BM@@internal@Eigen@@QEAA@PEBN_J@Z ; Eigen::internal::plainobjectbase_evaluator_data<double,28>::plainobjectbase_evaluator_data<double,28>
  0005f	90		 npad	 1

; 198  :     EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
; 199  :   }

  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
??0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z ENDP ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv85 = 32
tv91 = 40
this$ = 64
m$ = 72
?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z@4HA PROC ; `Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1?$evaluator_base@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ ; Eigen::internal::evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >::~evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEAA@AEBV?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@2@@Z@4HA ENDP ; `Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseStorage.h
;	COMDAT ?cols@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?cols@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEBA_JXZ PROC ; Eigen::DenseStorage<double,-1,-1,-1,0>::cols, COMDAT

; 473  :     EIGEN_DEVICE_FUNC Index cols(void) const EIGEN_NOEXCEPT {return m_cols;}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0000e	c3		 ret	 0
?cols@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseStorage<double,-1,-1,-1,0>::cols
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseStorage.h
;	COMDAT ?rows@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?rows@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEBA_JXZ PROC ; Eigen::DenseStorage<double,-1,-1,-1,0>::rows, COMDAT

; 472  :     EIGEN_DEVICE_FUNC Index rows(void) const EIGEN_NOEXCEPT {return m_rows;}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0000e	c3		 ret	 0
?rows@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseStorage<double,-1,-1,-1,0>::rows
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ??0?$plainobjectbase_evaluator_data@N$0?0@internal@Eigen@@QEAA@PEBN_J@Z
_TEXT	SEGMENT
this$ = 8
ptr$ = 16
outerStride$ = 24
??0?$plainobjectbase_evaluator_data@N$0?0@internal@Eigen@@QEAA@PEBN_J@Z PROC ; Eigen::internal::plainobjectbase_evaluator_data<double,-1>::plainobjectbase_evaluator_data<double,-1>, COMDAT

; 154  :   plainobjectbase_evaluator_data(const Scalar* ptr, Index outerStride) : data(ptr), m_outerStride(outerStride) {}

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00014	48 8b 4c 24 10	 mov	 rcx, QWORD PTR ptr$[rsp]
  00019	48 89 08	 mov	 QWORD PTR [rax], rcx
  0001c	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 8b 4c 24 18	 mov	 rcx, QWORD PTR outerStride$[rsp]
  00026	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0002a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0002f	c3		 ret	 0
??0?$plainobjectbase_evaluator_data@N$0?0@internal@Eigen@@QEAA@PEBN_J@Z ENDP ; Eigen::internal::plainobjectbase_evaluator_data<double,-1>::plainobjectbase_evaluator_data<double,-1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ??0?$evaluator_base@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$evaluator_base@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ PROC ; Eigen::internal::evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >::evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >, COMDAT

; 121  :   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE evaluator_base() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
??0?$evaluator_base@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@QEAA@XZ ENDP ; Eigen::internal::evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >::evaluator_base<Eigen::Matrix<double,-1,-1,0,-1,-1> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ??0?$plainobjectbase_evaluator_data@N$0BM@@internal@Eigen@@QEAA@PEBN_J@Z
_TEXT	SEGMENT
this$ = 48
ptr$ = 56
outerStride$ = 64
??0?$plainobjectbase_evaluator_data@N$0BM@@internal@Eigen@@QEAA@PEBN_J@Z PROC ; Eigen::internal::plainobjectbase_evaluator_data<double,28>::plainobjectbase_evaluator_data<double,28>, COMDAT

; 140  :   {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 139  :   plainobjectbase_evaluator_data(const Scalar* ptr, Index outerStride) : data(ptr)

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ptr$[rsp]
  0001d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 141  : #ifndef EIGEN_INTERNAL_DEBUGGING
; 142  :     EIGEN_UNUSED_VARIABLE(outerStride);

  00020	48 8d 4c 24 40	 lea	 rcx, QWORD PTR outerStride$[rsp]
  00025	e8 00 00 00 00	 call	 ??$ignore_unused_variable@_J@internal@Eigen@@YAXAEB_J@Z ; Eigen::internal::ignore_unused_variable<__int64>

; 143  : #endif
; 144  :     eigen_internal_assert(outerStride==OuterStride);
; 145  :   }

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
??0?$plainobjectbase_evaluator_data@N$0BM@@internal@Eigen@@QEAA@PEBN_J@Z ENDP ; Eigen::internal::plainobjectbase_evaluator_data<double,28>::plainobjectbase_evaluator_data<double,28>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ??0?$evaluator_base@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$evaluator_base@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ PROC ; Eigen::internal::evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >::evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >, COMDAT

; 121  :   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE evaluator_base() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
??0?$evaluator_base@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@internal@Eigen@@QEAA@XZ ENDP ; Eigen::internal::evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >::evaluator_base<Eigen::Matrix<double,28,28,0,28,28> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ?data@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAPEANXZ
_TEXT	SEGMENT
this$ = 48
?data@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAPEANXZ PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::data, COMDAT

; 252  :     { return m_storage.data(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?data@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAPEANXZ ; Eigen::DenseStorage<double,-1,-1,-1,0>::data
  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?data@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAPEANXZ ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ?data@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAPEBNXZ
_TEXT	SEGMENT
this$ = 48
?data@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAPEBNXZ PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::data, COMDAT

; 248  :     { return m_storage.data(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?data@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEBAPEBNXZ ; Eigen::DenseStorage<double,-1,-1,-1,0>::data
  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?data@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAPEBNXZ ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseCoeffsBase.h
;	COMDAT ?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$02@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$02@Eigen@@QEBA_JXZ PROC ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,-1,0,-1,-1>,3>::outerStride, COMDAT

; 586  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 587  :       return derived().outerStride();

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::derived
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ?outerStride@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEBA_JXZ ; Eigen::Matrix<double,-1,-1,0,-1,-1>::outerStride
  0001b	90		 npad	 1

; 588  :     }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$02@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,-1,0,-1,-1>,3>::outerStride
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\EigenBase.h
;	COMDAT ?size@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
tv65 = 32
this$ = 64
?size@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::size, COMDAT

; 67   :   inline Index size() const EIGEN_NOEXCEPT { return rows() * cols(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?rows@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::rows
  00013	48 89 44 24 20	 mov	 QWORD PTR tv65[rsp], rax
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ?cols@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::cols
  00022	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv65[rsp]
  00027	48 0f af c8	 imul	 rcx, rax
  0002b	48 8b c1	 mov	 rax, rcx
  0002e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00032	c3		 ret	 0
?size@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\PlainObjectBase.h
;	COMDAT ?data@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAPEBNXZ
_TEXT	SEGMENT
this$ = 48
?data@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAPEBNXZ PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::data, COMDAT

; 248  :     { return m_storage.data(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?data@?$DenseStorage@N$0DBA@$0BM@$0BM@$0A@@Eigen@@QEBAPEBNXZ ; Eigen::DenseStorage<double,784,28,28,0>::data
  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?data@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAPEBNXZ ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseCoeffsBase.h
;	COMDAT ?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@$02@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@$02@Eigen@@QEBA_JXZ PROC ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,28,28,0,28,28>,3>::outerStride, COMDAT

; 586  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 587  :       return derived().outerStride();

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?derived@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::derived
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ?outerStride@?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEBA_JXZ ; Eigen::Matrix<double,28,28,0,28,28>::outerStride
  0001b	90		 npad	 1

; 588  :     }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
?outerStride@?$DenseCoeffsBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@$02@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,28,28,0,28,28>,3>::outerStride
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\Matrix.h
;	COMDAT ?outerStride@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?outerStride@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEBA_JXZ PROC ; Eigen::Matrix<double,-1,-1,0,-1,-1>::outerStride, COMDAT

; 429  :     inline Index outerStride() const EIGEN_NOEXCEPT { return this->innerSize(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?innerSize@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::innerSize
  00013	90		 npad	 1
  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
?outerStride@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEBA_JXZ ENDP ; Eigen::Matrix<double,-1,-1,0,-1,-1>::outerStride
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseStorage.h
;	COMDAT ?data@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAPEANXZ
_TEXT	SEGMENT
this$ = 8
?data@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAPEANXZ PROC ; Eigen::DenseStorage<double,-1,-1,-1,0>::data, COMDAT

; 495  :     EIGEN_DEVICE_FUNC T *data() { return m_data; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000d	c3		 ret	 0
?data@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAPEANXZ ENDP ; Eigen::DenseStorage<double,-1,-1,-1,0>::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseStorage.h
;	COMDAT ?data@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEBAPEBNXZ
_TEXT	SEGMENT
this$ = 8
?data@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEBAPEBNXZ PROC ; Eigen::DenseStorage<double,-1,-1,-1,0>::data, COMDAT

; 494  :     EIGEN_DEVICE_FUNC const T *data() const { return m_data; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000d	c3		 ret	 0
?data@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEBAPEBNXZ ENDP ; Eigen::DenseStorage<double,-1,-1,-1,0>::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\EigenBase.h
;	COMDAT ?cols@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?cols@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::cols, COMDAT

; 63   :   inline Index cols() const EIGEN_NOEXCEPT { return derived().cols(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::derived
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ?cols@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::cols
  0001b	90		 npad	 1
  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
?cols@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::cols
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\EigenBase.h
;	COMDAT ?rows@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?rows@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::rows, COMDAT

; 60   :   inline Index rows() const EIGEN_NOEXCEPT { return derived().rows(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::derived
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ?rows@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::rows
  0001b	90		 npad	 1
  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
?rows@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::rows
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\EigenBase.h
;	COMDAT ?derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ
_TEXT	SEGMENT
this$ = 8
?derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ PROC ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::derived, COMDAT

; 49   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
?derived@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ENDP ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::derived
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\Matrix.h
;	COMDAT ?outerStride@?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?outerStride@?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEBA_JXZ PROC ; Eigen::Matrix<double,28,28,0,28,28>::outerStride, COMDAT

; 429  :     inline Index outerStride() const EIGEN_NOEXCEPT { return this->innerSize(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?innerSize@?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::DenseBase<Eigen::Matrix<double,28,28,0,28,28> >::innerSize
  00013	90		 npad	 1
  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
?outerStride@?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@QEBA_JXZ ENDP ; Eigen::Matrix<double,28,28,0,28,28>::outerStride
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseStorage.h
;	COMDAT ?data@?$DenseStorage@N$0DBA@$0BM@$0BM@$0A@@Eigen@@QEBAPEBNXZ
_TEXT	SEGMENT
this$ = 8
?data@?$DenseStorage@N$0DBA@$0BM@$0BM@$0A@@Eigen@@QEBAPEBNXZ PROC ; Eigen::DenseStorage<double,784,28,28,0>::data, COMDAT

; 266  :     EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c3		 ret	 0
?data@?$DenseStorage@N$0DBA@$0BM@$0BM@$0A@@Eigen@@QEBAPEBNXZ ENDP ; Eigen::DenseStorage<double,784,28,28,0>::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseBase.h
;	COMDAT ?innerSize@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
tv83 = 32
tv85 = 40
this$ = 64
?innerSize@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::innerSize, COMDAT

; 236  :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 237  :       return IsVectorAtCompileTime ? this->size()

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	74 11		 je	 SHORT $LN5@innerSize
  0000f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00014	e8 00 00 00 00	 call	 ?size@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::size
  00019	48 89 44 24 28	 mov	 QWORD PTR tv85[rsp], rax
  0001e	eb 30		 jmp	 SHORT $LN6@innerSize
$LN5@innerSize:
  00020	33 c0		 xor	 eax, eax
  00022	85 c0		 test	 eax, eax
  00024	74 11		 je	 SHORT $LN3@innerSize
  00026	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002b	e8 00 00 00 00	 call	 ?cols@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::cols
  00030	48 89 44 24 20	 mov	 QWORD PTR tv83[rsp], rax
  00035	eb 0f		 jmp	 SHORT $LN4@innerSize
$LN3@innerSize:
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003c	e8 00 00 00 00	 call	 ?rows@?$EigenBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::rows
  00041	48 89 44 24 20	 mov	 QWORD PTR tv83[rsp], rax
$LN4@innerSize:
  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR tv83[rsp]
  0004b	48 89 44 24 28	 mov	 QWORD PTR tv85[rsp], rax
$LN6@innerSize:
  00050	48 8b 44 24 28	 mov	 rax, QWORD PTR tv85[rsp]

; 238  :            : int(IsRowMajor) ? this->cols() : this->rows();
; 239  :     }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
?innerSize@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::innerSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\DenseBase.h
;	COMDAT ?innerSize@?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
tv83 = 32
tv85 = 40
this$ = 64
?innerSize@?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::DenseBase<Eigen::Matrix<double,28,28,0,28,28> >::innerSize, COMDAT

; 236  :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 237  :       return IsVectorAtCompileTime ? this->size()

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	74 11		 je	 SHORT $LN5@innerSize
  0000f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00014	e8 00 00 00 00	 call	 ?size@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::size
  00019	48 89 44 24 28	 mov	 QWORD PTR tv85[rsp], rax
  0001e	eb 30		 jmp	 SHORT $LN6@innerSize
$LN5@innerSize:
  00020	33 c0		 xor	 eax, eax
  00022	85 c0		 test	 eax, eax
  00024	74 11		 je	 SHORT $LN3@innerSize
  00026	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002b	e8 00 00 00 00	 call	 ?cols@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::cols
  00030	48 89 44 24 20	 mov	 QWORD PTR tv83[rsp], rax
  00035	eb 0f		 jmp	 SHORT $LN4@innerSize
$LN3@innerSize:
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003c	e8 00 00 00 00	 call	 ?rows@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::rows
  00041	48 89 44 24 20	 mov	 QWORD PTR tv83[rsp], rax
$LN4@innerSize:
  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR tv83[rsp]
  0004b	48 89 44 24 28	 mov	 QWORD PTR tv85[rsp], rax
$LN6@innerSize:
  00050	48 8b 44 24 28	 mov	 rax, QWORD PTR tv85[rsp]

; 238  :            : int(IsRowMajor) ? this->cols() : this->rows();
; 239  :     }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
?innerSize@?$DenseBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseBase<Eigen::Matrix<double,28,28,0,28,28> >::innerSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\EigenBase.h
;	COMDAT ?size@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
tv65 = 32
this$ = 64
?size@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::size, COMDAT

; 67   :   inline Index size() const EIGEN_NOEXCEPT { return rows() * cols(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?rows@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::rows
  00013	48 89 44 24 20	 mov	 QWORD PTR tv65[rsp], rax
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ?cols@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::cols
  00022	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv65[rsp]
  00027	48 0f af c8	 imul	 rcx, rax
  0002b	48 8b c1	 mov	 rax, rcx
  0002e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00032	c3		 ret	 0
?size@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\EigenBase.h
;	COMDAT ?cols@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?cols@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::cols, COMDAT

; 63   :   inline Index cols() const EIGEN_NOEXCEPT { return derived().cols(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?derived@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::derived
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ?cols@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::cols
  0001b	90		 npad	 1
  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
?cols@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::cols
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\EigenBase.h
;	COMDAT ?rows@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 48
?rows@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::rows, COMDAT

; 60   :   inline Index rows() const EIGEN_NOEXCEPT { return derived().rows(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ?derived@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBAAEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@XZ ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::derived
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ?rows@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::rows
  0001b	90		 npad	 1
  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
?rows@?$EigenBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::Matrix<double,28,28,0,28,28> >::rows
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\AssignEvaluator.h
;	COMDAT ??$resize_if_allowed@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@NN@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z
_TEXT	SEGMENT
dstRows$ = 32
dstCols$ = 40
dst$ = 64
src$ = 72
__formal$ = 80
??$resize_if_allowed@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@NN@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z PROC ; Eigen::internal::resize_if_allowed<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,double,double>, COMDAT

; 760  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 761  :   Index dstRows = src.rows();

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR src$[rsp]
  00018	e8 00 00 00 00	 call	 ?rows@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::rows
  0001d	48 89 44 24 20	 mov	 QWORD PTR dstRows$[rsp], rax

; 762  :   Index dstCols = src.cols();

  00022	48 8b 4c 24 48	 mov	 rcx, QWORD PTR src$[rsp]
  00027	e8 00 00 00 00	 call	 ?cols@?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> >::cols
  0002c	48 89 44 24 28	 mov	 QWORD PTR dstCols$[rsp], rax

; 763  :   if(((dst.rows()!=dstRows) || (dst.cols()!=dstCols)))

  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dst$[rsp]
  00036	e8 00 00 00 00	 call	 ?rows@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::rows
  0003b	48 3b 44 24 20	 cmp	 rax, QWORD PTR dstRows$[rsp]
  00040	75 11		 jne	 SHORT $LN3@resize_if_
  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dst$[rsp]
  00047	e8 00 00 00 00	 call	 ?cols@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::cols
  0004c	48 3b 44 24 28	 cmp	 rax, QWORD PTR dstCols$[rsp]
  00051	74 14		 je	 SHORT $LN2@resize_if_
$LN3@resize_if_:

; 764  :     dst.resize(dstRows, dstCols);

  00053	4c 8b 44 24 28	 mov	 r8, QWORD PTR dstCols$[rsp]
  00058	48 8b 54 24 20	 mov	 rdx, QWORD PTR dstRows$[rsp]
  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dst$[rsp]
  00062	e8 00 00 00 00	 call	 ?resize@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAX_J0@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::resize
$LN2@resize_if_:

; 765  :   eigen_assert(dst.rows() == dstRows && dst.cols() == dstCols);

  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dst$[rsp]
  0006c	e8 00 00 00 00	 call	 ?rows@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::rows
  00071	48 3b 44 24 20	 cmp	 rax, QWORD PTR dstRows$[rsp]
  00076	75 11		 jne	 SHORT $LN5@resize_if_
  00078	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dst$[rsp]
  0007d	e8 00 00 00 00	 call	 ?cols@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::cols
  00082	48 3b 44 24 28	 cmp	 rax, QWORD PTR dstCols$[rsp]
  00087	74 1c		 je	 SHORT $LN6@resize_if_
$LN5@resize_if_:
  00089	41 b8 fd 02 00
	00		 mov	 r8d, 765		; 000002fdH
  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1MO@GPGLNDGM@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAm?$AAa?$AAr?$AAi?$AAj?$AA?2@
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@DGNPLEBJ@?$AAd?$AAs?$AAt?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd@
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a3	33 c0		 xor	 eax, eax
$LN6@resize_if_:

; 766  : }

  000a5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a9	c3		 ret	 0
??$resize_if_allowed@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@2@NN@internal@Eigen@@YAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@1@AEBU?$assign_op@NN@01@@Z ENDP ; Eigen::internal::resize_if_allowed<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,28,28,0,28,28>,double,double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\util\Memory.h
;	COMDAT ??$first_aligned@$0CA@N_J@internal@Eigen@@YA_JPEBN_J@Z
_TEXT	SEGMENT
first$1 = 0
tv73 = 8
ScalarSize$ = 16
AlignmentSize$ = 24
AlignmentMask$ = 32
array$ = 64
size$ = 72
??$first_aligned@$0CA@N_J@internal@Eigen@@YA_JPEBN_J@Z PROC ; Eigen::internal::first_aligned<32,double,__int64>, COMDAT

; 470  : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 471  :   const Index ScalarSize = sizeof(Scalar);

  0000e	48 c7 44 24 10
	08 00 00 00	 mov	 QWORD PTR ScalarSize$[rsp], 8

; 472  :   const Index AlignmentSize = Alignment / ScalarSize;

  00017	48 c7 44 24 18
	04 00 00 00	 mov	 QWORD PTR AlignmentSize$[rsp], 4

; 473  :   const Index AlignmentMask = AlignmentSize-1;

  00020	48 c7 44 24 20
	03 00 00 00	 mov	 QWORD PTR AlignmentMask$[rsp], 3

; 474  : 
; 475  :   if(AlignmentSize<=1)

  00029	33 c0		 xor	 eax, eax
  0002b	85 c0		 test	 eax, eax
  0002d	74 06		 je	 SHORT $LN2@first_alig

; 476  :   {
; 477  :     // Either the requested alignment if smaller than a scalar, or it exactly match a 1 scalar
; 478  :     // so that all elements of the array have the same alignment.
; 479  :     return 0;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 6a		 jmp	 SHORT $LN1@first_alig

; 480  :   }

  00033	eb 68		 jmp	 SHORT $LN3@first_alig
$LN2@first_alig:

; 481  :   else if( (UIntPtr(array) & (sizeof(Scalar)-1)) || (Alignment%ScalarSize)!=0)

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR array$[rsp]
  0003a	48 83 e0 07	 and	 rax, 7
  0003e	48 85 c0	 test	 rax, rax
  00041	75 06		 jne	 SHORT $LN6@first_alig
  00043	33 c0		 xor	 eax, eax
  00045	85 c0		 test	 eax, eax
  00047	74 09		 je	 SHORT $LN4@first_alig
$LN6@first_alig:

; 482  :   {
; 483  :     // The array is not aligned to the size of a single scalar, or the requested alignment is not a multiple of the scalar size.
; 484  :     // Consequently, no element of the array is well aligned.
; 485  :     return size;

  00049	48 8b 44 24 48	 mov	 rax, QWORD PTR size$[rsp]
  0004e	eb 4d		 jmp	 SHORT $LN1@first_alig

; 486  :   }

  00050	eb 4b		 jmp	 SHORT $LN5@first_alig
$LN4@first_alig:

; 487  :   else
; 488  :   {
; 489  :     Index first = (AlignmentSize - (Index((UIntPtr(array)/sizeof(Scalar))) & AlignmentMask)) & AlignmentMask;

  00052	33 d2		 xor	 edx, edx
  00054	48 8b 44 24 40	 mov	 rax, QWORD PTR array$[rsp]
  00059	b9 08 00 00 00	 mov	 ecx, 8
  0005e	48 f7 f1	 div	 rcx
  00061	48 83 e0 03	 and	 rax, 3
  00065	b9 04 00 00 00	 mov	 ecx, 4
  0006a	48 2b c8	 sub	 rcx, rax
  0006d	48 8b c1	 mov	 rax, rcx
  00070	48 83 e0 03	 and	 rax, 3
  00074	48 89 04 24	 mov	 QWORD PTR first$1[rsp], rax

; 490  :     return (first < size) ? first : size;

  00078	48 8b 44 24 48	 mov	 rax, QWORD PTR size$[rsp]
  0007d	48 39 04 24	 cmp	 QWORD PTR first$1[rsp], rax
  00081	7d 0b		 jge	 SHORT $LN8@first_alig
  00083	48 8b 04 24	 mov	 rax, QWORD PTR first$1[rsp]
  00087	48 89 44 24 08	 mov	 QWORD PTR tv73[rsp], rax
  0008c	eb 0a		 jmp	 SHORT $LN9@first_alig
$LN8@first_alig:
  0008e	48 8b 44 24 48	 mov	 rax, QWORD PTR size$[rsp]
  00093	48 89 44 24 08	 mov	 QWORD PTR tv73[rsp], rax
$LN9@first_alig:
  00098	48 8b 44 24 08	 mov	 rax, QWORD PTR tv73[rsp]
$LN5@first_alig:
$LN3@first_alig:
$LN1@first_alig:

; 491  :   }
; 492  : }

  0009d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a1	c3		 ret	 0
??$first_aligned@$0CA@N_J@internal@Eigen@@YA_JPEBN_J@Z ENDP ; Eigen::internal::first_aligned<32,double,__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\AssignEvaluator.h
;	COMDAT ??$run@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@@?$unaligned_dense_assignment_loop@$00@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@12@_J1@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
__formal$ = 24
??$run@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@@?$unaligned_dense_assignment_loop@$00@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@12@_J1@Z PROC ; Eigen::internal::unaligned_dense_assignment_loop<1>::run<Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0> >, COMDAT

; 389  :   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&, Index, Index) {}

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	c3		 ret	 0
??$run@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@@?$unaligned_dense_assignment_loop@$00@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@12@_J1@Z ENDP ; Eigen::internal::unaligned_dense_assignment_loop<1>::run<Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\AssignEvaluator.h
;	COMDAT ??$assignPacket@$0CA@$0CA@U__m256d@@@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAAX_J@Z
_TEXT	SEGMENT
tv76 = 0
tv87 = 8
tv92 = 16
tv90 = 24
tv94 = 32
$T1 = 64
this$ = 176
index$ = 184
??$assignPacket@$0CA@$0CA@U__m256d@@@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAAX_J@Z PROC ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::assignPacket<32,32,__m256d>, COMDAT

; 680  :   {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00012	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  00017	48 83 e5 e0	 and	 rbp, -32		; ffffffffffffffe0H

; 681  :     m_functor.template assignPacket<StoreMode>(&m_dst.coeffRef(index), m_src.template packet<LoadMode,PacketType>(index));

  0001b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	48 89 45 20	 mov	 QWORD PTR tv94[rbp], rax
  0002b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00033	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00037	48 89 45 00	 mov	 QWORD PTR tv76[rbp], rax
  0003b	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR index$[rsp]
  00043	48 8d 55 40	 lea	 rdx, QWORD PTR $T1[rbp]
  00047	48 8b 4d 00	 mov	 rcx, QWORD PTR tv76[rbp]
  0004b	e8 00 00 00 00	 call	 ??$packet@$0CA@U__m256d@@@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEBA?AU__m256d@@_J@Z ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >::packet<32,__m256d>
  00050	48 89 45 10	 mov	 QWORD PTR tv92[rbp], rax
  00054	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0005c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005f	48 89 45 08	 mov	 QWORD PTR tv87[rbp], rax
  00063	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR index$[rsp]
  0006b	48 8b 4d 08	 mov	 rcx, QWORD PTR tv87[rbp]
  0006f	e8 00 00 00 00	 call	 ?coeffRef@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAAAEAN_J@Z ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::coeffRef
  00074	48 89 45 18	 mov	 QWORD PTR tv90[rbp], rax
  00078	4c 8b 45 10	 mov	 r8, QWORD PTR tv92[rbp]
  0007c	48 8b 55 18	 mov	 rdx, QWORD PTR tv90[rbp]
  00080	48 8b 4d 20	 mov	 rcx, QWORD PTR tv94[rbp]
  00084	e8 00 00 00 00	 call	 ??$assignPacket@$0CA@U__m256d@@@?$assign_op@NN@internal@Eigen@@QEBAXPEANAEBU__m256d@@@Z ; Eigen::internal::assign_op<double,double>::assignPacket<32,__m256d>

; 682  :   }

  00089	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00090	5d		 pop	 rbp
  00091	c3		 ret	 0
??$assignPacket@$0CA@$0CA@U__m256d@@@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAAX_J@Z ENDP ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::assignPacket<32,32,__m256d>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\AssignEvaluator.h
;	COMDAT ??$run@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@@?$unaligned_dense_assignment_loop@$0A@@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@12@_J1@Z
_TEXT	SEGMENT
index$1 = 32
kernel$ = 64
start$ = 72
end$ = 80
??$run@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@@?$unaligned_dense_assignment_loop@$0A@@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@12@_J1@Z PROC ; Eigen::internal::unaligned_dense_assignment_loop<0>::run<Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0> >, COMDAT

; 409  :   {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 410  :     for (Index index = start; index < end; ++index)

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR index$1[rsp], rax
  0001d	eb 0d		 jmp	 SHORT $LN4@run
$LN2@run:
  0001f	48 8b 44 24 20	 mov	 rax, QWORD PTR index$1[rsp]
  00024	48 ff c0	 inc	 rax
  00027	48 89 44 24 20	 mov	 QWORD PTR index$1[rsp], rax
$LN4@run:
  0002c	48 8b 44 24 50	 mov	 rax, QWORD PTR end$[rsp]
  00031	48 39 44 24 20	 cmp	 QWORD PTR index$1[rsp], rax
  00036	7d 11		 jge	 SHORT $LN3@run

; 411  :       kernel.assignCoeff(index);

  00038	48 8b 54 24 20	 mov	 rdx, QWORD PTR index$1[rsp]
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR kernel$[rsp]
  00042	e8 00 00 00 00	 call	 ?assignCoeff@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAAX_J@Z ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::assignCoeff
  00047	eb d6		 jmp	 SHORT $LN2@run
$LN3@run:

; 412  :   }

  00049	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004d	c3		 ret	 0
??$run@V?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@@?$unaligned_dense_assignment_loop@$0A@@internal@Eigen@@SAXAEAV?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@12@_J1@Z ENDP ; Eigen::internal::unaligned_dense_assignment_loop<0>::run<Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\AssignEvaluator.h
;	COMDAT ?assignCoeff@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAAX_J@Z
_TEXT	SEGMENT
tv75 = 32
tv86 = 40
tv91 = 48
tv89 = 56
tv93 = 64
this$ = 96
index$ = 104
?assignCoeff@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAAX_J@Z PROC ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::assignCoeff, COMDAT

; 659  :   {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 660  :     m_functor.assignCoeff(m_dst.coeffRef(index), m_src.coeff(index));

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 89 44 24 40	 mov	 QWORD PTR tv93[rsp], rax
  0001c	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00025	48 89 44 24 20	 mov	 QWORD PTR tv75[rsp], rax
  0002a	48 8b 54 24 68	 mov	 rdx, QWORD PTR index$[rsp]
  0002f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv75[rsp]
  00034	e8 00 00 00 00	 call	 ?coeff@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEBAAEBN_J@Z ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >::coeff
  00039	48 89 44 24 30	 mov	 QWORD PTR tv91[rsp], rax
  0003e	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00043	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00046	48 89 44 24 28	 mov	 QWORD PTR tv86[rsp], rax
  0004b	48 8b 54 24 68	 mov	 rdx, QWORD PTR index$[rsp]
  00050	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv86[rsp]
  00055	e8 00 00 00 00	 call	 ?coeffRef@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAAAEAN_J@Z ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::coeffRef
  0005a	48 89 44 24 38	 mov	 QWORD PTR tv89[rsp], rax
  0005f	4c 8b 44 24 30	 mov	 r8, QWORD PTR tv91[rsp]
  00064	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv89[rsp]
  00069	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv93[rsp]
  0006e	e8 00 00 00 00	 call	 ?assignCoeff@?$assign_op@NN@internal@Eigen@@QEBAXAEANAEBN@Z ; Eigen::internal::assign_op<double,double>::assignCoeff

; 661  :   }

  00073	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00077	c3		 ret	 0
?assignCoeff@?$generic_dense_assignment_kernel@U?$evaluator@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@internal@Eigen@@U?$evaluator@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@23@U?$assign_op@NN@23@$0A@@internal@Eigen@@QEAAX_J@Z ENDP ; Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::internal::evaluator<Eigen::Matrix<double,28,28,0,28,28> >,Eigen::internal::assign_op<double,double>,0>::assignCoeff
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ?coeffRef@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAAAEAN_J@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
?coeffRef@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAAAEAN_J@Z PROC ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::coeffRef, COMDAT

; 227  :   {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 228  :     return const_cast<Scalar*>(m_d.data)[index];

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 8b 4c 24 10	 mov	 rcx, QWORD PTR index$[rsp]
  00017	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]

; 229  :   }

  0001b	c3		 ret	 0
?coeffRef@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@QEAAAEAN_J@Z ENDP ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::coeffRef
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ?coeff@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEBAAEBN_J@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
?coeff@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEBAAEBN_J@Z PROC ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >::coeff, COMDAT

; 212  :   {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 213  :     return m_d.data[index];

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 8b 4c 24 10	 mov	 rcx, QWORD PTR index$[rsp]
  00017	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]

; 214  :   }

  0001b	c3		 ret	 0
?coeff@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEBAAEBN_J@Z ENDP ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >::coeff
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\functors\AssignmentFunctors.h
;	COMDAT ?assignCoeff@?$assign_op@NN@internal@Eigen@@QEBAXAEANAEBN@Z
_TEXT	SEGMENT
this$ = 8
a$ = 16
b$ = 24
?assignCoeff@?$assign_op@NN@internal@Eigen@@QEBAXAEANAEBN@Z PROC ; Eigen::internal::assign_op<double,double>::assignCoeff, COMDAT

; 24   :   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a = b; }

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 8b 44 24 10	 mov	 rax, QWORD PTR a$[rsp]
  00014	48 8b 4c 24 18	 mov	 rcx, QWORD PTR b$[rsp]
  00019	c5 fb 10 01	 vmovsd	 xmm0, QWORD PTR [rcx]
  0001d	c5 fb 11 00	 vmovsd	 QWORD PTR [rax], xmm0
  00021	c3		 ret	 0
?assignCoeff@?$assign_op@NN@internal@Eigen@@QEBAXAEANAEBN@Z ENDP ; Eigen::internal::assign_op<double,double>::assignCoeff
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\CoreEvaluators.h
;	COMDAT ??$packet@$0CA@U__m256d@@@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEBA?AU__m256d@@_J@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
index$ = 64
??$packet@$0CA@U__m256d@@@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEBA?AU__m256d@@_J@Z PROC ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >::packet<32,__m256d>, COMDAT

; 244  :   {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 245  :     return ploadt<PacketType, LoadMode>(m_d.data + index);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR index$[rsp]
  00020	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 ??$ploadt@U__m256d@@$0CA@@internal@Eigen@@YA?AU__m256d@@PEBN@Z ; Eigen::internal::ploadt<__m256d,32>
  0002c	48 8b 44 24 38	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]
  00031	c5 fd 11 00	 vmovupd YMMWORD PTR [rax], ymm0
  00035	48 8b 44 24 38	 mov	 rax, QWORD PTR __$ReturnUdt$[rsp]

; 246  :   }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
??$packet@$0CA@U__m256d@@@?$evaluator@V?$PlainObjectBase@V?$Matrix@N$0BM@$0BM@$0A@$0BM@$0BM@@Eigen@@@Eigen@@@internal@Eigen@@QEBA?AU__m256d@@_J@Z ENDP ; Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double,28,28,0,28,28> > >::packet<32,__m256d>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\functors\AssignmentFunctors.h
;	COMDAT ??$assignPacket@$0CA@U__m256d@@@?$assign_op@NN@internal@Eigen@@QEBAXPEANAEBU__m256d@@@Z
_TEXT	SEGMENT
this$ = 48
a$ = 56
b$ = 64
??$assignPacket@$0CA@U__m256d@@@?$assign_op@NN@internal@Eigen@@QEBAXPEANAEBU__m256d@@@Z PROC ; Eigen::internal::assign_op<double,double>::assignPacket<32,__m256d>, COMDAT

; 28   :   { internal::pstoret<DstScalar,Packet,Alignment>(a,b); }

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00013	48 8b 54 24 40	 mov	 rdx, QWORD PTR b$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR a$[rsp]
  0001d	e8 00 00 00 00	 call	 ??$pstoret@NU__m256d@@$0CA@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z ; Eigen::internal::pstoret<double,__m256d,32>
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
??$assignPacket@$0CA@U__m256d@@@?$assign_op@NN@internal@Eigen@@QEBAXPEANAEBU__m256d@@@Z ENDP ; Eigen::internal::assign_op<double,double>::assignPacket<32,__m256d>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\GenericPacketMath.h
;	COMDAT ??$ploadt@U__m256d@@$0CA@@internal@Eigen@@YA?AU__m256d@@PEBN@Z
_TEXT	SEGMENT
$T1 = 0
$T2 = 32
from$ = 144
??$ploadt@U__m256d@@$0CA@@internal@Eigen@@YA?AU__m256d@@PEBN@Z PROC ; Eigen::internal::ploadt<__m256d,32>, COMDAT

; 965  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  00012	48 83 e5 e0	 and	 rbp, -32		; ffffffffffffffe0H

; 966  :   if(Alignment >= unpacket_traits<Packet>::alignment)

  00016	33 c0		 xor	 eax, eax
  00018	83 f8 01	 cmp	 eax, 1
  0001b	74 1b		 je	 SHORT $LN2@ploadt

; 967  :     return pload<Packet>(from);

  0001d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR from$[rsp]
  00025	e8 00 00 00 00	 call	 ??$pload@U__m256d@@@internal@Eigen@@YA?AU__m256d@@PEBN@Z ; Eigen::internal::pload<__m256d>
  0002a	c5 fd 11 45 00	 vmovupd YMMWORD PTR $T1[rbp], ymm0
  0002f	c5 fd 10 45 00	 vmovupd ymm0, YMMWORD PTR $T1[rbp]
  00034	eb 19		 jmp	 SHORT $LN1@ploadt
  00036	eb 17		 jmp	 SHORT $LN3@ploadt
$LN2@ploadt:

; 968  :   else
; 969  :     return ploadu<Packet>(from);

  00038	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR from$[rsp]
  00040	e8 00 00 00 00	 call	 ??$ploadu@U__m256d@@@internal@Eigen@@YA?AU__m256d@@PEBN@Z ; Eigen::internal::ploadu<__m256d>
  00045	c5 fd 11 45 20	 vmovupd YMMWORD PTR $T2[rbp], ymm0
  0004a	c5 fd 10 45 20	 vmovupd ymm0, YMMWORD PTR $T2[rbp]
$LN3@ploadt:
$LN1@ploadt:

; 970  : }

  0004f	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00056	5d		 pop	 rbp
  00057	c3		 ret	 0
??$ploadt@U__m256d@@$0CA@@internal@Eigen@@YA?AU__m256d@@PEBN@Z ENDP ; Eigen::internal::ploadt<__m256d,32>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\marij\OneDrive\Documenten\GitHub\Neural_Network\dependencies\Eigen\src\Core\GenericPacketMath.h
;	COMDAT ??$pstoret@NU__m256d@@$0CA@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z
_TEXT	SEGMENT
to$ = 48
from$ = 56
??$pstoret@NU__m256d@@$0CA@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z PROC ; Eigen::internal::pstoret<double,__m256d,32>, COMDAT

; 976  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 977  :   if(Alignment >= unpacket_traits<Packet>::alignment)

  0000e	33 c0		 xor	 eax, eax
  00010	83 f8 01	 cmp	 eax, 1
  00013	74 11		 je	 SHORT $LN2@pstoret

; 978  :     pstore(to, from);

  00015	48 8b 54 24 38	 mov	 rdx, QWORD PTR from$[rsp]
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR to$[rsp]
  0001f	e8 00 00 00 00	 call	 ??$pstore@NU__m256d@@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z ; Eigen::internal::pstore<double,__m256d>
  00024	eb 0f		 jmp	 SHORT $LN3@pstoret
$LN2@pstoret:

; 979  :   else
; 980  :     pstoreu(to, from);

  00026	48 8b 54 24 38	 mov	 rdx, QWORD PTR from$[rsp]
  0002b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR to$[rsp]
  00030	e8 00 00 00 00	 call	 ??$pstoreu@NU__m256d@@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z ; Eigen::internal::pstoreu<double,__m256d>
$LN3@pstoret:

; 981  : }

  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
??$pstoret@NU__m256d@@$0CA@@internal@Eigen@@YAXPEANAEBU__m256d@@@Z ENDP ; Eigen::internal::pstoret<double,__m256d,32>
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor', COMDAT
  00000	48 63 41 fc	 movsxd	 rax, DWORD PTR [rcx-4]
  00004	48 2b c8	 sub	 rcx, rax
  00007	e9 00 00 00 00	 jmp	 ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
_TEXT	ENDS
END
